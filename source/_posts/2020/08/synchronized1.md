---
title: synchronized的实现原理
date: 2020-08-15 20:49:14
tags: 
- 多线程
categories:
- Java
- 多线程
---

### 前言
  
  之前面试中有被问到Java锁机制相关的问题，本章就借助synchronized的实现原理来总结一下相关知识点。
<!-- more -->

### 对象头

  synchronized锁住的目标是Java中的对象，那么他到底依赖于什么控制的呢？
  答案就是----对象头。
  所以先来了解下对象头是什么。
> 一般对象的对象头由两部分组成
> 1.klass pointer(指针，指向其类元数据的信息),
> 2.Mark word(存储对象的运行时数据，包括哈希码，锁状态等)
> 如果是数组对象则还存有array length信息

  对象头上述三个结构中，与synchronized有关联的就是第二部分 Mark word。因为对象的锁信息是存在这里的。

{% img  /image/xxxx/xxxxx.png  '"xxxx"' %}
{% img  /image/synchronized/synchronized1.png  '"锁状态标记"' %}

### Java锁状态

  对象头的锁标记记录了对象当前的锁状态，接下来就来看看这几个状态是如何转换运作的。

 1.无锁状态
   没有对对象执行加锁操作

 2.偏向锁
   表示此时只有一个线程请求对象资源，没有其他线程竞争，那么对象就会偏向该线程，并在对象头中存储该线程标识

 3.轻量级锁
   当有其他的线程来竞争该对象资源，因为对象已被占用，当前为偏向锁状态，就会执行锁升级，让偏向锁升级为轻量级锁，来竞争的线程自旋等待锁释放

 4.重量级锁
   如果等待时间过长，自旋的消耗就显得不划算，这时就会将轻量级锁升级为重量级锁，让线程停止自旋，直接阻塞，这个判断条件是根据自旋次数来判断的

 这四种状态会依照对应的条件向上变化，也就是锁升级，但不会降级。
 这种机制最大程度的平衡了加锁过程的消耗(线程的等待时间和阻塞唤醒线程的消耗)，不会一味的阻塞线程导致需要频繁的唤醒，也不会因为线程一直自旋等待占用系统资源。

### synchronized的运行机制
  
  之前提到，synchronized的加锁实际上就是修改的对象头的锁标记，那么在有线程竞争的情况下，具体的修改过程是怎样的呢？
  答案是---CAS
  不同的线程会将对象头的mark word复制一份过来，然后在使用CAS进行修改操作。
  修改成功的也就获得了对象的锁资源，修改失败的进入自旋等待。

### synchronized示例

### 小结