---
title: synchronized的实现原理
date: 2020-08-15 20:49:14
tags: 
- 多线程
categories:
- Java
- 多线程
---

### 前言
  
  之前面试中有被问到Java锁机制相关的问题，本章就借助synchronized的实现原理来总结一下相关知识点。
<!-- more -->

### 对象头

#### 对象头的结构
  synchronized锁住的目标是Java中的对象，那么他到底依赖于什么控制的呢？
  答案就是----对象头。
  所以先来了解下对象头是啥样的：
> 一般对象的对象头由两部分组成
> 1.klass pointer(指针，指向其类元数据的信息),
> 2.Mark word(存储对象的运行时数据，包括哈希码，锁状态等)
> 如果是数组对象则还存有array length信息

#### Mark word
  对象头的三个结构中，与synchronized关联紧密的就是第二部分 Mark word。
  因为他维护着对象的锁标记信息。

{% img  /image/xxxx/xxxxx.png  '"xxxx"' %}
{% img  /image/synchronized/synchronized1.png  '"锁状态标记"' %}

### 锁升级

  对象头中记录了对象不同的锁状态，当触发了对应条件时就会引起其状态的变化，这个过程被称作锁升级。

  1. 无锁状态
     锁的初始状态
  2. 偏向锁
     偏向锁与无锁状态的lock标记一样都是01，可以理解偏向锁是一种特殊的无锁状态，是无锁到有锁的过渡。
     当有线程获取到锁资源时就会升级为偏向锁，并在对象头中记录偏向的线程标识，也就是获取到锁资源的线程。
     >引入偏向锁是因为在一个线程多次获取同一个锁的场景下，如果每次都按照竞争锁的方式去操作未免会造成平白的消耗。
     >而偏向锁记录了当前拥有锁的线程的标识信息，当同一线程多次去获取该锁时可以直接依据该标识判断，从而减小获取锁的消耗。
  3. 轻量级锁
     偏向锁是无竞争场景下的，假设这样一种情况：
     thread1先获取到了某个对象的锁，thread2慢了一步，获取失败。
     那么此时如何处理thread2？
     这里的设计是按照乐观的设想，thread1会很快释放锁资源，所以将偏向锁升级为轻量级锁，让thread2自旋不断尝试获取锁资源。
  4. 重量级锁
     轻量级锁是在乐观设想的前提下让获取失败的线程自旋等待。
     但如果考虑到最坏的情况，thread1因为某些原因占用时间超出了可接受的范围，如果让thread2一直自旋，甚至后面又来了N个
     线程也在自旋，这样就浪费了大量的CPU资源，显然是不合理的。
     所以当线程自旋一定次数还未获得锁资源时，轻量级锁就会升级为重量级锁，让这些尝试获取锁资源的线程通通阻塞，等待锁被释放后再唤醒他们。

#### 锁升级的具体过程
  
  锁升级的逻辑其实比较好理解，其目的就是为了优化及提高加锁解锁的性能。
  但这个过程具体是如何操作的呢？
  前文说到，Mark word中存储了对象的锁标记，线程占用锁资源的本质就是修改了对象头Mark word的相关信息。
  而为了保证多个线程去竞争同一个锁的并发场景的安全，这里的修改都采用了CAS操作。
  
  无锁升级为偏向锁存在于无竞争场景，这里就不再多做赘述。
  先看看偏向锁升级为轻量级锁的过程：
  1. thread1尝试获取
   

 这四种状态会依照对应的条件向上变化，也就是锁升级，但不会降级。
 这种机制最大程度的平衡了加锁过程的消耗(线程的等待时间和阻塞唤醒线程的消耗)，不会一味的阻塞线程导致需要频繁的唤醒，也不会因为线程一直自旋等待占用系统资源。

### synchronized的运行机制
  
  之前提到，synchronized的加锁实际上就是修改的对象头的锁标记，那么在有线程竞争的情况下，具体的修改过程是怎样的呢？
  答案是---CAS
  不同的线程会将对象头的mark word复制一份过来，然后在使用CAS进行修改操作。
  修改成功的也就获得了对象的锁资源，修改失败的进入自旋等待。

### synchronized示例

### 小结