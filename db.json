{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/image/redis1-1.png","path":"image/redis1-1.png","modified":0,"renderable":0},{"_id":"source/image/CountDownLatch/CountDownLatch1.png","path":"image/CountDownLatch/CountDownLatch1.png","modified":0,"renderable":0},{"_id":"source/image/ThinkingInJava/ThinkingInJava3-1.png","path":"image/ThinkingInJava/ThinkingInJava3-1.png","modified":0,"renderable":0},{"_id":"source/image/ThreadLocal/ThreadLocal1.png","path":"image/ThreadLocal/ThreadLocal1.png","modified":0,"renderable":0},{"_id":"source/image/aop/aop1.png","path":"image/aop/aop1.png","modified":0,"renderable":0},{"_id":"source/image/aop/aop2.png","path":"image/aop/aop2.png","modified":0,"renderable":0},{"_id":"source/image/innoDBLock/InnoDBLock.png","path":"image/innoDBLock/InnoDBLock.png","modified":0,"renderable":0},{"_id":"source/image/innoDBLock/InnoDBLock2.png","path":"image/innoDBLock/InnoDBLock2.png","modified":0,"renderable":0},{"_id":"source/image/innoDBLock/InnoDBLock3.png","path":"image/innoDBLock/InnoDBLock3.png","modified":0,"renderable":0},{"_id":"source/image/skiplist/skiplist1.png","path":"image/skiplist/skiplist1.png","modified":0,"renderable":0},{"_id":"source/image/skiplist/skiplist2.png","path":"image/skiplist/skiplist2.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/rel-16x16.ico","path":"images/rel-16x16.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/rel-32x32.ico","path":"images/rel-32x32.ico","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"source/image/home.png","path":"image/home.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"source/image/synchronized/synchronized1.png","path":"image/synchronized/synchronized1.png","modified":0,"renderable":0},{"_id":"source/image/synchronized/synchronized2.png","path":"image/synchronized/synchronized2.png","modified":0,"renderable":0},{"_id":"source/image/synchronized/synchronized3.png","path":"image/synchronized/synchronized3.png","modified":0,"renderable":0},{"_id":"source/image/synchronized/synchronized4.png","path":"image/synchronized/synchronized4.png","modified":0,"renderable":0},{"_id":"source/image/synchronized/synchronized6.png","path":"image/synchronized/synchronized6.png","modified":0,"renderable":0},{"_id":"source/image/synchronized/synchronized7.png","path":"image/synchronized/synchronized7.png","modified":0,"renderable":0},{"_id":"source/image/synchronized/synchronized9.png","path":"image/synchronized/synchronized9.png","modified":0,"renderable":0},{"_id":"source/image/synchronized/synchronized8.png","path":"image/synchronized/synchronized8.png","modified":0,"renderable":0},{"_id":"source/image/synchronized/synchronized5.png","path":"image/synchronized/synchronized5.png","modified":0,"renderable":0},{"_id":"source/image/synchronized/synchronized10.png","path":"image/synchronized/synchronized10.png","modified":0,"renderable":0},{"_id":"source/image/lock/lock1.png","path":"image/lock/lock1.png","modified":0,"renderable":0},{"_id":"source/image/lock/lock2.png","path":"image/lock/lock2.png","modified":0,"renderable":0},{"_id":"source/image/lock/lock3.png","path":"image/lock/lock3.png","modified":0,"renderable":0},{"_id":"source/image/lock/lock4.png","path":"image/lock/lock4.png","modified":0,"renderable":0},{"_id":"source/image/lock/lock5.png","path":"image/lock/lock5.png","modified":0,"renderable":0},{"_id":"source/image/lock/lock6.png","path":"image/lock/lock6.png","modified":0,"renderable":0},{"_id":"source/image/final/final1.png","path":"image/final/final1.png","modified":0,"renderable":0},{"_id":"source/image/final/final2.png","path":"image/final/final2.png","modified":0,"renderable":0},{"_id":"source/image/final/final3.png","path":"image/final/final3.png","modified":0,"renderable":0},{"_id":"source/image/LinkedHashMap/LinkedHashMap1.png","path":"image/LinkedHashMap/LinkedHashMap1.png","modified":0,"renderable":0},{"_id":"source/image/LinkedHashMap/LinkedHashMap2.png","path":"image/LinkedHashMap/LinkedHashMap2.png","modified":0,"renderable":0},{"_id":"source/image/HTTP/http-request1.png","path":"image/HTTP/http-request1.png","modified":0,"renderable":0},{"_id":"source/image/HTTP/http-request2.png","path":"image/HTTP/http-request2.png","modified":0,"renderable":0},{"_id":"source/image/HTTP/http-request3.png","path":"image/HTTP/http-request3.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1588901095564},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1588901095564},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1588901095564},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1588901095579},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1588901095579},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1588901095579},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1588901095579},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1588901095579},{"_id":"themes/next/_config.yml","hash":"27286c03fd60436784d92e446f322f9aa1fa6d64","modified":1597469092662},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1588901095579},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1588901095579},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1588901095610},{"_id":"source/_posts/helloworld.md","hash":"ddff16d348dafba28ecbb9df8a01b53bb05bc271","modified":1597495873255},{"_id":"source/categories/index.md","hash":"5db56924be69fc1021f5ec2a159384e1f361084f","modified":1597494845007},{"_id":"source/tags/index.md","hash":"a537802086f74f5b4931e393b0773c5bf3163c2e","modified":1597494845016},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1588901095564},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1588901095564},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1588901095564},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1588901095564},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1588901095564},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1588901095564},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1588901095564},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1588901095564},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1588901095564},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1588901095564},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1588901095564},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1588901095579},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1588901095579},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1588901095579},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1588901095579},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1588901095579},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1588901095579},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1588901095579},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1588901095579},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1588901095579},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1588901095579},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1588901095579},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1588901095579},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1588901095579},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1588901095579},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1588901095579},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1588901095579},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1588901095579},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1588901095579},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1588901095579},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1588901095579},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1588901095579},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1588901095579},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1588901095595},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1588901095595},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1588901095595},{"_id":"themes/next/languages/tr.yml","hash":"46e09f2119cbfbcf93fb8dbd267dccabeb8b0cda","modified":1588901095595},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1588901095595},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1588901095595},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1588901095595},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1588901095595},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1588901095595},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1588901095595},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1588901095610},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1588901095610},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1588901095610},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1588901095610},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1588901095610},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1588901095610},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1588901095626},{"_id":"source/image/redis1-1.png","hash":"2a0347e36ede662ef5aa31d0f9625247feb7383e","modified":1590302159329},{"_id":"source/image/CountDownLatch/CountDownLatch1.png","hash":"f1f0fc8af7d1be04dff8090e30f9be63a6f4403e","modified":1594715859049},{"_id":"source/image/ThinkingInJava/ThinkingInJava3-1.png","hash":"7759e4e45f2b35d33e901259a586e7aa6adeb4d0","modified":1591683519857},{"_id":"source/image/ThreadLocal/ThreadLocal1.png","hash":"e41c1c887b2ef826e953ff14f35f9c5b29ca5a2c","modified":1593752679001},{"_id":"source/image/aop/aop1.png","hash":"55816e2025ca9f0b6ebb0d25723169d130a83862","modified":1594627298212},{"_id":"source/image/aop/aop2.png","hash":"3935c424c15bad507508466ce6e8698c5cf8be4c","modified":1594633790976},{"_id":"source/image/innoDBLock/InnoDBLock.png","hash":"7869ad361e06aaf67401e28397babda60d97e139","modified":1591177573155},{"_id":"source/image/innoDBLock/InnoDBLock2.png","hash":"e4872db6bd68244c636355e1ca7150e01c6d9000","modified":1591179230438},{"_id":"source/image/innoDBLock/InnoDBLock3.png","hash":"2e9020a8a6399950d1303072fadd69d276129911","modified":1591185646256},{"_id":"source/image/skiplist/skiplist1.png","hash":"fce80d905c072df39de3ee1a8aab26e29a51aefd","modified":1596081478648},{"_id":"source/image/skiplist/skiplist2.png","hash":"befe6203599fb70e4ede65fa0c9227c05ada6203","modified":1596286399718},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1588901095564},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1588901095564},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1588901095564},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1588901095564},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1588901095579},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1588901095579},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1588901095579},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1588901095579},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1588901095579},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1588901095579},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1588901095579},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1588901095579},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1588901095579},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1588901095579},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1588901095579},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1588901095579},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1588901095579},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1588901095595},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1588901095595},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1588901095595},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1588901095595},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0e650e97d5fadc4b8a9a0fec00fe7db642dc3f76","modified":1597467089614},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1588901095595},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1588901095595},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1588901095595},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1588901095595},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1588901095595},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1588901095595},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1588901095610},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1588901095610},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1588901095610},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1588901095610},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1588901095610},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1588901095610},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1588901095610},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1588901095626},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1588901095626},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1588901095626},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1588901095626},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1588901095626},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1588901095626},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1588901095626},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1588901095626},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1588901095626},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1588901095626},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1588901095626},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1588901095626},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1588901095626},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1588901095626},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1588901095626},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1588901095626},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1588901095626},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1588901095626},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1588901095626},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1588901095626},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1588901095657},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1588901095657},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1588901095657},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1588901095657},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1588901095657},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1588901095657},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1588901095657},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1588901095657},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1588901095657},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1588901095657},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1588901095657},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1588901095673},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1588901095673},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1588901095673},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1588901095673},{"_id":"themes/next/source/images/rel-16x16.ico","hash":"2dfa2e3bf16ec55f76ea2d0852e198b66787db88","modified":1590458433477},{"_id":"themes/next/source/images/rel-32x32.ico","hash":"18a54583cd2c28167be748ea23ddb779453948c7","modified":1590458541730},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1588901095673},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1588901095673},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1588901095673},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1588901095673},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1588901095673},{"_id":"themes/next/source/js/utils.js","hash":"53ce574c301a8b958e7f825beb193c77fb975e33","modified":1588901095673},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1588901095673},{"_id":"source/image/home.png","hash":"53245e397605dd1532ba29e7e1b3fb112a8dfedd","modified":1591188273194},{"_id":"source/_posts/2020/05/arrayList1.md","hash":"9093b1c7f7279182384a52ce0dfe80c0c2918e00","modified":1597494844995},{"_id":"source/_posts/2020/05/hashMap1.md","hash":"1fa354313f1c950b993b6ae4b724d473734dea69","modified":1597494844996},{"_id":"source/_posts/2020/05/mysql1.md","hash":"d5a0de32ba1ffa7577ad18f98f1a6d09f04620e2","modified":1597494844996},{"_id":"source/_posts/2020/05/redis1.md","hash":"b870804ae07ebeb7c550f5030df49248d57902f2","modified":1597494844997},{"_id":"source/_posts/2020/05/视频操作.md","hash":"d4f1ad159a54ee762ed35fd2b3793e1882d7a3c0","modified":1597494844997},{"_id":"source/_posts/2020/06/DelayQueue1.md","hash":"87995be0f58e71a794a8b8040373e3e673083912","modified":1597494844998},{"_id":"source/_posts/2020/06/PriorityQueue1.md","hash":"aa5fd5080e85d0aa89b9c6818335b6841c096fdc","modified":1597494844998},{"_id":"source/_posts/2020/06/ProcessAndThread1.md","hash":"37638ccf359ba776f5931b56bd3ff467fc41d001","modified":1621090293413},{"_id":"source/_posts/2020/06/RocketMq1.md","hash":"08d83c16c254b8c76c801f4fdbabc088b84e352b","modified":1597494844999},{"_id":"source/_posts/2020/06/RocketMq2.md","hash":"d20179930b7ef64e057dc3d290c91cec7819e301","modified":1597494844999},{"_id":"source/_posts/2020/06/ThinkingInJava1.md","hash":"49ac3cbf04bf617775ae8e7104eb364bcbbbb1cf","modified":1597494844999},{"_id":"source/_posts/2020/06/ThinkingInJava2.md","hash":"2e5734041ac4783ed4d0af2c4f0f429779371f11","modified":1597494845000},{"_id":"source/_posts/2020/06/ThinkingInJava3.md","hash":"2f42236518530d1c45505991d8782d8922a75871","modified":1597494845000},{"_id":"source/_posts/2020/06/ThinkingInJava4.md","hash":"4ef909c85b841770aca1172b78c76ecd7cc84ec2","modified":1597494845001},{"_id":"source/_posts/2020/06/ThinkingInJava5.md","hash":"ecc1b419c9f01cf6e92fd5631d32ce8bfdc86832","modified":1597494845001},{"_id":"source/_posts/2020/06/ThinkingInJava6.md","hash":"e9c09d627900ecde6c11e52ed2dfb9f25d1b929f","modified":1597494845001},{"_id":"source/_posts/2020/06/ThinkingInJava7.md","hash":"e47f8f71f199aabe4342f948c6bffe0df4d9ec8e","modified":1597494845002},{"_id":"source/_posts/2020/06/ThinkingInJava8.md","hash":"be9ed6e19a0d4be9e0eaca6bb6ddf86652c74de8","modified":1597494845002},{"_id":"source/_posts/2020/06/bitwiseOperator.md","hash":"d8f6c4b676a2dec06d2782ecceadfb24d8799a8f","modified":1597494845003},{"_id":"source/_posts/2020/06/innoDBLock.md","hash":"0d95be60e22a6bc222064014f7467c19537a4977","modified":1621090155629},{"_id":"source/_posts/2020/06/jvm1.md","hash":"b623b37d58868415b428a193c64d562272f95e0a","modified":1597494845003},{"_id":"source/_posts/2020/06/redis2.md","hash":"24f727866244fce9a61be706d4080e893a3d79b9","modified":1597494845004},{"_id":"source/_posts/2020/07/AQS1.md","hash":"544367fb76a52acf3287c36fa78f195e1d1bde01","modified":1620652570471},{"_id":"source/_posts/2020/07/CountDownLatch1.md","hash":"e3f5110ece6d767ba007a026989a63719c17bf8a","modified":1597494845005},{"_id":"source/_posts/2020/07/ThreadLocal1.md","hash":"f27b79db6dacd8a11006ff2abbd4b553fd67db8f","modified":1597494845005},{"_id":"source/_posts/2020/07/skipList1.md","hash":"dd539bbb0f0cbf9b9285cef9f62c69539bb77f81","modified":1620194128019},{"_id":"source/_posts/2020/07/aop1.md","hash":"7e44edb1de9343eaa18ec57c641f0eb766452f5f","modified":1604932172543},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1588901095595},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1588901095595},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1588901095595},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1588901095595},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1588901095595},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1588901095595},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1588901095595},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1588901095595},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1588901095595},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1588901095595},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1588901095595},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1588901095595},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1588901095595},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1588901095595},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1588901095595},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1588901095595},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1588901095595},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1588901095595},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1588901095595},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1588901095610},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1588901095610},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1588901095610},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1588901095610},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1588901095610},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1588901095610},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1588901095610},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1588901095610},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1588901095610},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1588901095610},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1588901095610},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1588901095610},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1588901095610},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1588901095610},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1588901095610},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1588901095610},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1588901095610},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1588901095610},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1588901095610},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1588901095610},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1588901095610},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1588901095610},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1588901095610},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1588901095610},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1588901095610},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1588901095610},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1588901095610},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1588901095610},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1588901095610},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1588901095626},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1588901095626},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1588901095626},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1588901095626},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1588901095626},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1588901095626},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1588901095626},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1588901095626},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1588901095626},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1588901095626},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1588901095626},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1588901095657},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1588901095657},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1588901095657},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1588901095657},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1588901095657},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1588901095673},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1588901095673},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1588901095673},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1588901095673},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1588901095657},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1588901095657},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1588901095673},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1588901095673},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1588901095673},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1588901095626},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1588901095642},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1588901095642},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1588901095642},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1588901095657},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1588901095657},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1588901095657},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1588901095657},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1588901095657},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1588901095657},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1588901095657},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1588901095673},{"_id":"public/search.xml","hash":"d5e34a3b521dc26a1f0902dd52c09e612afd86be","modified":1635076809120},{"_id":"public/categories/index.html","hash":"7dc43027744b54f2564aba295a618d71c2c3b014","modified":1634391682332},{"_id":"public/tags/index.html","hash":"67f04b4e703b9389020021d878ee12fd1a20f5a1","modified":1634391682332},{"_id":"public/2093/02/12/helloworld/index.html","hash":"ba9f8f54163aaccfa01d5fffa3eebc20dbf18e42","modified":1634391682332},{"_id":"public/archives/page/3/index.html","hash":"d1d6cae2865887b0f52cd71a2c144afb4a9c97bb","modified":1634391682332},{"_id":"public/archives/2020/page/3/index.html","hash":"8a87edce015964e4febcb4189dfda4decb9b0ebc","modified":1634391682332},{"_id":"public/archives/2020/05/index.html","hash":"138a1b2be78bb9943968195637c20a1d068f8f63","modified":1634391682332},{"_id":"public/archives/2020/06/page/2/index.html","hash":"b39c1a9628ced74ca2bb147454dfd473fc172379","modified":1634391682332},{"_id":"public/archives/2020/07/index.html","hash":"7bac27840446756521df3aa325f9cb94fa31abff","modified":1634391682332},{"_id":"public/archives/2093/index.html","hash":"330bc3fae18838ca2a08b99155cca4c61ea644f0","modified":1634391682332},{"_id":"public/archives/2093/02/index.html","hash":"7aeee354d4f057bd8213cd411fdb9fddbc2cdb56","modified":1634391682332},{"_id":"public/categories/MySql/index.html","hash":"08c055bb9b161e70476de3e59310d46da4cebf56","modified":1634391682332},{"_id":"public/categories/Java/index.html","hash":"58d06bf064877fbc4906a6f6ab53303683eb3153","modified":1634391682332},{"_id":"public/categories/redis/index.html","hash":"fa69c21e418168fd3b4268586c2c3e33daaba2c6","modified":1634391682332},{"_id":"public/categories/操作系统/index.html","hash":"2f84d501c20fc1cf40d8ab23aa5f67c73af46aed","modified":1634391682332},{"_id":"public/categories/Java/Collection/index.html","hash":"34a48735276871a67546e7d84485f9d1ba8477b9","modified":1634391682332},{"_id":"public/categories/Java/Map/index.html","hash":"20ff116f084071fa6dde1b85335b45c278fa6c39","modified":1634391682332},{"_id":"public/categories/MQ/index.html","hash":"d0a709f3aed7746051432f8bed865a6c11ad9701","modified":1634391682332},{"_id":"public/categories/读书笔记/index.html","hash":"04885bdafbee840aa4ed1a3f700ae2ece46d2b2a","modified":1634391682332},{"_id":"public/categories/Java/JUC/index.html","hash":"15da79b4b55cfd3f14cc86f8f10dbeb04c961d22","modified":1634391682332},{"_id":"public/categories/Java/工具/index.html","hash":"3d411c35de037817bd77041871c061f0df9b1e80","modified":1634391682332},{"_id":"public/categories/Java/Collection/List/index.html","hash":"cdcd534e60a223fe8283aafe3fc9bb64c38eeeaa","modified":1634391682332},{"_id":"public/categories/Java/基础/index.html","hash":"c6ee4ea1d1c638791e5cce4b816484ad70e863f6","modified":1634391682332},{"_id":"public/categories/JVM/index.html","hash":"cfe8d4948c0c017595e42cf1a83edc68e812da76","modified":1634391682332},{"_id":"public/categories/Java/Collection/Queue/index.html","hash":"5cc98a89b96c2c7b99cf637bbbc72ff258b57f86","modified":1634391682332},{"_id":"public/categories/Java/多线程/index.html","hash":"9bbc8b88b9a1de1c92187deeb51d979f0f8c8fb7","modified":1634391682332},{"_id":"public/categories/MQ/RocketMQ/index.html","hash":"12b7ec7339ece36e92b23728b18489561328bdb8","modified":1634391682332},{"_id":"public/categories/数据结构/index.html","hash":"7f388881eb21b2d5626b8ca3d17ecc9779fcb7cc","modified":1634391682332},{"_id":"public/categories/读书笔记/ThinkingInJava/index.html","hash":"79081b6fe718e6ae41db4d7713f60491ce647539","modified":1634391682332},{"_id":"public/categories/spring/index.html","hash":"1495ab0f5c9b202a84ba4914cad1e441b3e5642e","modified":1604932040730},{"_id":"public/categories/数据结构/链表/index.html","hash":"920773a3bb9fd866fa0d00a8d5c3097e93782ab8","modified":1634391682332},{"_id":"public/categories/spring/AOP/index.html","hash":"cec44916a5e0763d7546f4ffd257384a4a84742a","modified":1604932040730},{"_id":"public/tags/MySql索引/index.html","hash":"a93fb42d67b76fdf1de084e4952419eb20395482","modified":1634391682332},{"_id":"public/tags/Java容器/index.html","hash":"8cbfa820fcc60a27305da288f3c22518a00e476c","modified":1634391682332},{"_id":"public/tags/redis/index.html","hash":"2dc5a4b496334dbe83a3e6c21720be23ff19b99e","modified":1634391682332},{"_id":"public/tags/工具/index.html","hash":"5d46bf9aff5eb3ea6d40aecaeeab19f1f37b962f","modified":1634391682332},{"_id":"public/tags/进程/index.html","hash":"4527fc9d7e1869e2cfa202731bc928442fc42a6f","modified":1634391682332},{"_id":"public/tags/RocketMQ/index.html","hash":"6b9f5ddeadb48cf839c3ce7ce98f0b4a2b5486d3","modified":1634391682332},{"_id":"public/tags/ThinkingInJava/index.html","hash":"1febc5e46340ac18b9653e389c0cb58ba9ee0776","modified":1634391682332},{"_id":"public/tags/位运算符/index.html","hash":"7289a7b6a21c073389b8b92897f35e8b149ed92f","modified":1634391682332},{"_id":"public/tags/InnoDB锁/index.html","hash":"fc73ce65c66d73f07498a1a25f2cf50f1b42950a","modified":1634391682332},{"_id":"public/tags/JVM/index.html","hash":"e7776cb76f9bff4cdd791160130d04d812558124","modified":1634391682332},{"_id":"public/tags/多线程/index.html","hash":"d2ad439bbb8c11d7998435c9a545fbb3c1008a2a","modified":1634391682332},{"_id":"public/tags/JUC/index.html","hash":"f63ec053a4ec09b08eddde4d607e6ab1d9b550fd","modified":1634391682332},{"_id":"public/tags/数据结构/index.html","hash":"c744996ac25af41719644deb2dcb47aba32749a9","modified":1634391682332},{"_id":"public/2020/07/21/skipList1/index.html","hash":"65b14bc5ee944d88cdebce5aab1629f054abd129","modified":1634391682332},{"_id":"public/2020/07/14/AQS1/index.html","hash":"f37b289c982aa71fce582e93c78a437d80c289fc","modified":1634391682332},{"_id":"public/2020/07/13/CountDownLatch1/index.html","hash":"4924a6a896172e8dcaa785b4f42000ee6fb2bb92","modified":1634391682332},{"_id":"public/2020/07/12/aop1/index.html","hash":"c472471bba841fd08076e64a5dda6055a89d7343","modified":1634391682332},{"_id":"public/2020/07/02/ThreadLocal1/index.html","hash":"2d83239cf0338305be8c8aa1f2182cbcbd82fa94","modified":1634391682332},{"_id":"public/2020/06/30/DelayQueue1/index.html","hash":"00dfc0178f8fb2eeab335e1fe572bcb8fd50ce38","modified":1634391682332},{"_id":"public/2020/06/29/PriorityQueue1/index.html","hash":"da3cca0520bcebbe060c429e7d604e0c4839e33e","modified":1634391682332},{"_id":"public/2020/06/28/jvm1/index.html","hash":"0df981f993810e02792733267b60db52bfd713d2","modified":1634391682332},{"_id":"public/2020/06/27/redis2/index.html","hash":"54899ab626e576ebaea85f0b0b1f432ffd25d37a","modified":1634391682332},{"_id":"public/2020/06/25/ProcessAndThread1/index.html","hash":"20400c0cd07e62c4e44911db04009e2c30406c6a","modified":1634391682332},{"_id":"public/2020/06/24/RocketMq2/index.html","hash":"4b6097701f1ac2397e739fd04f2521f96f8e6afb","modified":1634391682332},{"_id":"public/2020/06/23/RocketMq1/index.html","hash":"cc0b9f68b687aa6d18b8b564c5f2054ba258bda6","modified":1634391682332},{"_id":"public/2020/06/17/ThinkingInJava8/index.html","hash":"677a96bafd88a3437ab7f3df44c34b9c8028224c","modified":1634391682332},{"_id":"public/2020/06/15/ThinkingInJava7/index.html","hash":"3ab14c8dc50282ee0037cc40984d64c9b7abfb6e","modified":1634391682332},{"_id":"public/2020/06/14/ThinkingInJava6/index.html","hash":"2552f1484ff0a5786a1d3c3971d535355a4c5635","modified":1634391682332},{"_id":"public/2020/06/11/ThinkingInJava5/index.html","hash":"f2289bc27afaf17e8726f17b444d36120b5e0f8d","modified":1634391682332},{"_id":"public/2020/06/09/ThinkingInJava4/index.html","hash":"d275927101aea16eeab8cd6ab888ec56205ee733","modified":1634391682332},{"_id":"public/2020/06/07/ThinkingInJava3/index.html","hash":"830a72c205219beba7ffed8878caf16ee11ac24f","modified":1634391682332},{"_id":"public/2020/06/07/ThinkingInJava2/index.html","hash":"5e653dc2cfe137af7e54804feade09f5e91366a0","modified":1634391682332},{"_id":"public/2020/06/06/ThinkingInJava1/index.html","hash":"0feeab50574662e3101c603f1f7ab9cb6b168809","modified":1634391682332},{"_id":"public/2020/06/03/innoDBLock/index.html","hash":"fa589cfe915921290da64bb23e571419dfd85bfd","modified":1634391682332},{"_id":"public/2020/06/02/bitwiseOperator/index.html","hash":"869703b9c5b846a6c4948cadd79de991c0255db4","modified":1634391682332},{"_id":"public/2020/05/30/hashMap1/index.html","hash":"2765a071a73d91194620777463ee92da83160e0d","modified":1634391682332},{"_id":"public/2020/05/26/arrayList1/index.html","hash":"e4b767cd1d1aae7e499c7ac1d7d753eddf896660","modified":1634391682332},{"_id":"public/2020/05/25/mysql1/index.html","hash":"5d8bc82695a02843cdb9896db53c87fc4136ce3f","modified":1634391682332},{"_id":"public/2020/05/24/redis1/index.html","hash":"4f5ed202c46ec49bf6d583df60659c1b47db4f15","modified":1634391682332},{"_id":"public/2020/05/09/视频操作/index.html","hash":"49d6638c0da97ca37fffe2b5118887a07c41d45c","modified":1634391682332},{"_id":"public/index.html","hash":"8b5365d3861aa6956f7de6b8429ecaf2f9548ffd","modified":1635076809120},{"_id":"public/page/2/index.html","hash":"1dbf34c69bd724eda9bbbc8d3e0462d3720f0f08","modified":1634391682332},{"_id":"public/page/3/index.html","hash":"6fb046d6e5e09816ac6a35a62fc6c776c27acbdf","modified":1634391682332},{"_id":"public/archives/index.html","hash":"e8e02a3d53bae362230bce8b095c15a9f61a5f2e","modified":1634391682332},{"_id":"public/archives/page/2/index.html","hash":"8fa6eb861558e30a9afc185ad2691e604510890c","modified":1634391682332},{"_id":"public/archives/2020/index.html","hash":"cf5d3fee810745d32306f365819f13172b41852a","modified":1634391682332},{"_id":"public/archives/2020/page/2/index.html","hash":"85b91de1cdc0dc9937b36d7fc3996d26c992ecff","modified":1634391682332},{"_id":"public/archives/2020/06/index.html","hash":"166750cdef73e0a5bbb83bc777d0f059a2e8e4ce","modified":1634391682332},{"_id":"public/tags/AOP/index.html","hash":"70fe050aa30f8e0aeac196e02c95f7531ffc4094","modified":1634391682332},{"_id":"public/image/CountDownLatch/CountDownLatch1.png","hash":"f1f0fc8af7d1be04dff8090e30f9be63a6f4403e","modified":1597494272374},{"_id":"public/image/ThinkingInJava/ThinkingInJava3-1.png","hash":"7759e4e45f2b35d33e901259a586e7aa6adeb4d0","modified":1597494272374},{"_id":"public/image/aop/aop1.png","hash":"55816e2025ca9f0b6ebb0d25723169d130a83862","modified":1597494272374},{"_id":"public/image/ThreadLocal/ThreadLocal1.png","hash":"e41c1c887b2ef826e953ff14f35f9c5b29ca5a2c","modified":1597494272374},{"_id":"public/image/aop/aop2.png","hash":"3935c424c15bad507508466ce6e8698c5cf8be4c","modified":1597494272374},{"_id":"public/image/innoDBLock/InnoDBLock2.png","hash":"e4872db6bd68244c636355e1ca7150e01c6d9000","modified":1597494272374},{"_id":"public/image/innoDBLock/InnoDBLock.png","hash":"7869ad361e06aaf67401e28397babda60d97e139","modified":1597494272374},{"_id":"public/image/innoDBLock/InnoDBLock3.png","hash":"2e9020a8a6399950d1303072fadd69d276129911","modified":1597494272374},{"_id":"public/image/skiplist/skiplist1.png","hash":"fce80d905c072df39de3ee1a8aab26e29a51aefd","modified":1597494272374},{"_id":"public/image/skiplist/skiplist2.png","hash":"befe6203599fb70e4ede65fa0c9227c05ada6203","modified":1597494272374},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1597494272374},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1597494272374},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1597494272374},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1597494272374},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1597494272374},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1597494272374},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1597494272374},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1597494272374},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1597494272374},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1597494272374},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1597494272374},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1597494272374},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1597494272374},{"_id":"public/images/rel-16x16.ico","hash":"2dfa2e3bf16ec55f76ea2d0852e198b66787db88","modified":1597494272374},{"_id":"public/images/rel-32x32.ico","hash":"18a54583cd2c28167be748ea23ddb779453948c7","modified":1597494272374},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1597494272374},{"_id":"public/image/redis1-1.png","hash":"2a0347e36ede662ef5aa31d0f9625247feb7383e","modified":1597494272374},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1597494272374},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1597494272374},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1597494272374},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1597494272374},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1597494272374},{"_id":"public/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1597494272374},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1597494272374},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1597494272374},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1597494272374},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1597494272374},{"_id":"public/css/main.css","hash":"9df7cbc434a3c4998258e64acaf239a02025d2c2","modified":1597494272374},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1597494272374},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1597494272374},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1597494272374},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1597494272374},{"_id":"public/image/home.png","hash":"53245e397605dd1532ba29e7e1b3fb112a8dfedd","modified":1597494272374},{"_id":"source/_posts/2020/08/synchronized1.md","hash":"3f2308e955fa57bc9ca3dbf7cee1f714b0902fa3","modified":1598102346238},{"_id":"public/2020/08/15/synchronized1/index.html","hash":"3b19aa3d7227b5ba63f38bd1ee5018133fb66a14","modified":1634391682332},{"_id":"public/archives/2020/08/index.html","hash":"1398a090017fc7e5378d34831135329f4e3b3c01","modified":1634391682332},{"_id":"source/image/synchronized/synchronized1.png","hash":"552154697cf4c45526fbc36341b3fea6f9a6d3ed","modified":1597844059980},{"_id":"public/image/synchronized/synchronized1.png","hash":"552154697cf4c45526fbc36341b3fea6f9a6d3ed","modified":1598092257850},{"_id":"source/_posts/2020/08/CurrentHashMap1.md","hash":"fa27b06ab4f42616a6e9ec7c83fb06400d1de4bd","modified":1597759203047},{"_id":"source/_posts/2020/08/volatile1.md","hash":"5a4cf1618092907765e5fc2e06810d241646d126","modified":1597759158328},{"_id":"public/2020/08/18/CurrentHashMap1/index.html","hash":"04c91ed680f51113731db834788bb61ac14b61d6","modified":1598538517910},{"_id":"public/2020/08/18/volatile1/index.html","hash":"1ca5a833d2e8555d29dd6b411a4fdeecea04ed2d","modified":1598538517910},{"_id":"public/archives/page/4/index.html","hash":"9a01af65ada8b81d4ef0e0274614e62d1ffca1d7","modified":1634391682332},{"_id":"public/page/4/index.html","hash":"847776b2db8170c9d2467e03cc6541fca6863a8d","modified":1634391682332},{"_id":"source/image/synchronized/synchronized3.png","hash":"d1fde8ffc71a6d2da744e73b8d2a91aa0ca7a59b","modified":1598538670913},{"_id":"source/image/synchronized/synchronized2.png","hash":"7064b0477f88edd4e98acc1bd1e75b291374b689","modified":1597843153936},{"_id":"source/image/synchronized/synchronized5.png","hash":"c9a693d6cb8a073ac8e2be421190d6b897b3859f","modified":1599054132442},{"_id":"source/image/synchronized/synchronized4.png","hash":"dea1bbb026ef873db3babb37e9f1a0441c43210a","modified":1599052314014},{"_id":"public/image/synchronized/synchronized5.png","hash":"c9a693d6cb8a073ac8e2be421190d6b897b3859f","modified":1599268634907},{"_id":"public/image/synchronized/synchronized2.png","hash":"7064b0477f88edd4e98acc1bd1e75b291374b689","modified":1598102339929},{"_id":"public/image/synchronized/synchronized3.png","hash":"d1fde8ffc71a6d2da744e73b8d2a91aa0ca7a59b","modified":1599052483364},{"_id":"public/image/synchronized/synchronized4.png","hash":"dea1bbb026ef873db3babb37e9f1a0441c43210a","modified":1599052483364},{"_id":"source/_posts/2020/08/synchronized2.md","hash":"f8750422b7b657b9c51d829e1a2f52b308d3d29f","modified":1604931998397},{"_id":"public/categories/多线程/index.html","hash":"453862467ed44a8e5f308f4bb84c462aac5f34ea","modified":1600869496182},{"_id":"public/archives/2020/page/4/index.html","hash":"87f70048e6480d71297142a2d10819a78b6f3cdc","modified":1634391682332},{"_id":"public/2020/08/27/synchronized2/index.html","hash":"0f42b19f18000ba2f9e928d908da74758dc17fb1","modified":1634391682332},{"_id":"source/image/synchronized/synchronized6.png","hash":"063b4b5bea42163e004b73bc2b0dc78934940bee","modified":1599054313784},{"_id":"source/image/synchronized/synchronized7.png","hash":"e76dbdac315eae426e7b9bb9779c6cb21d1c2c3c","modified":1599142025496},{"_id":"source/image/synchronized/synchronized9.png","hash":"b874a6e30504a47aeb8829b5ab58625b8928d950","modified":1599268562053},{"_id":"source/image/synchronized/synchronized8.png","hash":"85a75202cdb73e0321b9cddc996e4ff450fce93e","modified":1599268449067},{"_id":"public/image/synchronized/synchronized7.png","hash":"e76dbdac315eae426e7b9bb9779c6cb21d1c2c3c","modified":1599268634907},{"_id":"public/image/synchronized/synchronized6.png","hash":"063b4b5bea42163e004b73bc2b0dc78934940bee","modified":1599268634907},{"_id":"public/image/synchronized/synchronized9.png","hash":"b874a6e30504a47aeb8829b5ab58625b8928d950","modified":1599268634907},{"_id":"public/image/synchronized/synchronized8.png","hash":"85a75202cdb73e0321b9cddc996e4ff450fce93e","modified":1599268634907},{"_id":"source/image/synchronized/synchronized10.png","hash":"17634d30ddc2d30d662922d329a2a8e1d63b4068","modified":1599386501198},{"_id":"public/image/synchronized/synchronized10.png","hash":"17634d30ddc2d30d662922d329a2a8e1d63b4068","modified":1599386550756},{"_id":"source/_posts/2020/09/lock1.md","hash":"3c6dd9baae4855056375943abc59eaee06f8d18c","modified":1600347014470},{"_id":"public/archives/2020/09/index.html","hash":"e6e73c1bb37028ee2db68bb8eb5396c371dcb851","modified":1634391682332},{"_id":"public/categories/Java/page/2/index.html","hash":"c5263466d41341da44e2ededf7b97d7b0783f878","modified":1634391682332},{"_id":"public/2020/09/12/lock1/index.html","hash":"19997bcdc0d1f2b5531b8ab66cd5312bb3d29a1a","modified":1634391682332},{"_id":"source/image/lock/lock1.png","hash":"9ea0d803f2360b87cea86cfffef0ac924c8e39d2","modified":1600001568833},{"_id":"source/image/lock/lock2.png","hash":"d6fb38fd03001cbb5003e2682763019c60928cb0","modified":1600002153476},{"_id":"public/image/lock/lock1.png","hash":"9ea0d803f2360b87cea86cfffef0ac924c8e39d2","modified":1600002197862},{"_id":"public/image/lock/lock2.png","hash":"d6fb38fd03001cbb5003e2682763019c60928cb0","modified":1600002197862},{"_id":"source/image/lock/lock3.png","hash":"4b8ae9b456c6ac4b4a02a41bf2db4adfe7f250fb","modified":1600003146076},{"_id":"source/image/lock/lock4.png","hash":"9066d586f454599dabc25bb429c77ae82558968a","modified":1600003910848},{"_id":"public/image/lock/lock4.png","hash":"9066d586f454599dabc25bb429c77ae82558968a","modified":1600092083192},{"_id":"public/image/lock/lock3.png","hash":"4b8ae9b456c6ac4b4a02a41bf2db4adfe7f250fb","modified":1600092083192},{"_id":"source/image/lock/lock5.png","hash":"d80efc16fe7eaa2de0060506778aea7900c2b1b6","modified":1600092790140},{"_id":"source/image/lock/lock6.png","hash":"ea43a6b568ac0b504b7d3c89fbbad2df32a96462","modified":1600093851552},{"_id":"public/image/lock/lock5.png","hash":"d80efc16fe7eaa2de0060506778aea7900c2b1b6","modified":1600345401649},{"_id":"public/image/lock/lock6.png","hash":"ea43a6b568ac0b504b7d3c89fbbad2df32a96462","modified":1600345401649},{"_id":"source/_posts/2020/09/recipe1.md","hash":"8bcbbf51c13dfa3a3ad9a5508096b94fa6889835","modified":1600869838259},{"_id":"public/categories/料理/index.html","hash":"7b39b0778891deecd87d9d04fdbe5f6bdf370b22","modified":1634391682332},{"_id":"public/tags/料理/index.html","hash":"8aa46b0840d9e4b3135a6d88ff96cc1dc025d808","modified":1634391682332},{"_id":"public/2020/09/23/recipe1/index.html","hash":"df298030833159ff9921019d0f6541f794da1d47","modified":1634391682332},{"_id":"source/_posts/2020/11/spring-cache1.md","hash":"424d62ee46e611b76f44d06017116f489b47bf06","modified":1607697569915},{"_id":"public/categories/Spring/index.html","hash":"33b4b1a0b400df11fa3bdc4e1ffc97cc4bb71d90","modified":1635076809120},{"_id":"public/archives/2020/11/index.html","hash":"e2943e3cc0f7a4f371b1ecdeb8a83c0c1f0bcc4f","modified":1634391682332},{"_id":"public/tags/缓存/index.html","hash":"ba2f4fc0e43b7f6c7b3aaccc1cee84216978827b","modified":1634391682332},{"_id":"public/tags/SpringCache/index.html","hash":"3dce6207481f897aaa56e007eda293ae19a4be37","modified":1634391682332},{"_id":"public/2020/11/02/spring-cache1/index.html","hash":"52ee8ad79ef664ab265d3b8fa51e1351606201e6","modified":1634391682332},{"_id":"public/categories/Spring/AOP/index.html","hash":"def73a263a28ca56950324ceff950ef6aae37f2c","modified":1635076809120},{"_id":"public/categories/Spring/SpringCache/index.html","hash":"e8eb562ded8257d4a99a4dbb9a40588bd3dc7287","modified":1634391682332},{"_id":"source/image/final/final1.png","hash":"9530c49158f546351f10c80e239b5a1e90401f42","modified":1605188725557},{"_id":"source/image/final/final2.png","hash":"c8809227de419d92f67876009561ed7d8b508a66","modified":1605188748764},{"_id":"source/_posts/2020/11/itext-final1.md","hash":"d7a0d3be6969d5b28ab1b4cf336ec14e07e70bd8","modified":1605191524776},{"_id":"source/_posts/2020/11/mybatis-if1.md","hash":"53f50edfd37e56f76373a8c2d7c6ffced6a33e3c","modified":1605275651561},{"_id":"public/2020/11/11/itext-final1/index.html","hash":"83a3f1f2fa915476a1733438ea9e597f7d2fb8c9","modified":1634391682332},{"_id":"public/2020/11/11/mybatis-if1/index.html","hash":"90aaa8de66af801ead4a5f1bc47d800cb82c064f","modified":1634391682332},{"_id":"public/categories/MyBatis/index.html","hash":"8e7f84e6119b2954c0df1366ce9f436434d6136d","modified":1634391682332},{"_id":"public/tags/MyBatis/index.html","hash":"ffb04d42966b578710cf8791a462ee3064670866","modified":1634391682332},{"_id":"public/tags/final/index.html","hash":"a60266961da1cb589c19d9af575b02a1e734f6e8","modified":1634391682332},{"_id":"public/image/final/final2.png","hash":"c8809227de419d92f67876009561ed7d8b508a66","modified":1605188802229},{"_id":"public/image/final/final1.png","hash":"9530c49158f546351f10c80e239b5a1e90401f42","modified":1605188802229},{"_id":"source/image/final/final3.png","hash":"455960c0727dbedfbdd72400fdbfb2fdc29b3f4f","modified":1605190728873},{"_id":"public/image/final/final3.png","hash":"455960c0727dbedfbdd72400fdbfb2fdc29b3f4f","modified":1605275512144},{"_id":"source/_posts/2021/01/nio1.md","hash":"d71455ce0bf5f566843509cca4563ac8c3771ea9","modified":1610796542461},{"_id":"public/archives/2021/index.html","hash":"8b424e8461aa8b700ee9869f939d6c3ecbd7cfbb","modified":1634391682332},{"_id":"public/archives/2021/01/index.html","hash":"1421227df9f58796cffc5a34102c668db97b1dd0","modified":1634391682332},{"_id":"public/tags/NIO/index.html","hash":"453e73bc9dba1dbeb79079e952b7e320cf19aaa5","modified":1634391682332},{"_id":"public/2021/01/16/nio1/index.html","hash":"c409628df9e9a79a1bfc59dc7d9af040dde86fa7","modified":1634391682332},{"_id":"public/categories/Java/NIO/index.html","hash":"0e7be8ff8401d7cfc9399d2ed834c5021005bcd6","modified":1634391682332},{"_id":"source/_posts/2021/03/redis-sort1.md","hash":"7e682bf5a78481f956f76021a6f2bbc3b40a679c","modified":1614777392681},{"_id":"public/2021/03/02/redis-sort1/index.html","hash":"6357b122f39cd0313c12cd2cf2d5cde0b5c3a339","modified":1634391682332},{"_id":"public/archives/2021/03/index.html","hash":"5e4f760a9267ec6708e5a75a6f732248c2eb0cf2","modified":1634391682332},{"_id":"source/_posts/2021/03/LinkedHashMap1.md","hash":"bf319c182a05972e75449b1421024e563724cb35","modified":1615014955102},{"_id":"public/2021/03/04/LinkedHashMap1/index.html","hash":"47adc98a34a48422d558e89d00a27b372de831cf","modified":1634391682332},{"_id":"source/image/LinkedHashMap/LinkedHashMap1.png","hash":"0b595cb906e54347e178219051e0752f6f9c2d46","modified":1615014123102},{"_id":"source/image/LinkedHashMap/LinkedHashMap2.png","hash":"991cac05d1cca8d27d99c99b9e6caeef2816b074","modified":1615014498865},{"_id":"public/image/LinkedHashMap/LinkedHashMap2.png","hash":"991cac05d1cca8d27d99c99b9e6caeef2816b074","modified":1615014965615},{"_id":"public/image/LinkedHashMap/LinkedHashMap1.png","hash":"0b595cb906e54347e178219051e0752f6f9c2d46","modified":1615014965615},{"_id":"source/_posts/2021/03/sortAlgorithm1.md","hash":"5b85dfe2518d803bd83c76005bce2b5d934f7829","modified":1617421331632},{"_id":"public/2021/03/07/sortAlgorithm1/index.html","hash":"e9c8364cc38bac0b6c6bdaa2fcbbd2ea36a20fe2","modified":1634391682332},{"_id":"public/categories/算法/index.html","hash":"c407c6229ca20e562b4c97ffae5a132e340a99f3","modified":1634391682332},{"_id":"public/categories/算法/排序算法/index.html","hash":"bd835c1f666d5dad98aeb6d4ed7d7f24d6bee0b3","modified":1634391682332},{"_id":"public/tags/排序算法/index.html","hash":"1c80578781149b6f495c98fed3dcc7d4ed7889ea","modified":1634391682332},{"_id":"source/_posts/2021/04/greedy-algorithms.md","hash":"a2811d9ee1cdf831d08d91d179dce69c9c2e0ebe","modified":1618840680693},{"_id":"public/2021/04/12/greedy-algorithms/index.html","hash":"b77dd55af1e3cca1af294e2d161017181a0cb839","modified":1634391682332},{"_id":"public/archives/2021/04/index.html","hash":"5e27863b083e4151c1f79aadcbc23e3791ddecd7","modified":1634391682332},{"_id":"public/tags/贪心算法/index.html","hash":"b204d467ccc1ecf5d09033135c7ee777143e9729","modified":1618235720753},{"_id":"public/categories/算法/贪心算法/index.html","hash":"c29d008659ae597340003a9490aabb99dad3b240","modified":1618496214592},{"_id":"public/tags/算法笔记/index.html","hash":"9975d63189b46991e4cd309960524122660bbd65","modified":1634391682332},{"_id":"public/categories/算法/算法笔记/index.html","hash":"14189c39f7d458fa73364dbd36ba0334a231a87f","modified":1634391682332},{"_id":"public/categories/算法/算法笔记/贪心算法/index.html","hash":"e21320db88deea4faaede10cfada390e8d36c99d","modified":1634391682332},{"_id":"source/_posts/2021/04/twosum-algorithms.md","hash":"38729a8e1708b630e04eac3fb97b0aab6340665e","modified":1618747426040},{"_id":"public/2021/04/18/twosum-algorithms/index.html","hash":"42ff0aa9de992756cb7abd6344027c691e4202b1","modified":1618747431178},{"_id":"public/archives/page/5/index.html","hash":"2fc7bc01888badbf6b6420be6c067c7f746962a9","modified":1634391682332},{"_id":"public/page/5/index.html","hash":"d009a19158dbe25626f142b9dc0887839ceac80d","modified":1634391682332},{"_id":"public/categories/算法/算法笔记/双指针/index.html","hash":"660bce5999bf21b86369f3538fe917fd9c96be91","modified":1634391682332},{"_id":"source/_posts/2021/04/doublePointer-algorithms.md","hash":"b9783c752757d336dac0dca9bba6c8c0e0f43c6f","modified":1619096926362},{"_id":"public/2021/04/18/doublePointer-algorithms/index.html","hash":"6a98ac998513957e7ddd479b7611f2e95f07216b","modified":1634391682332},{"_id":"source/_posts/2021/04/binarySearch-algorithms.md","hash":"dc37d078875298c088b47a1f851cd46f418a682f","modified":1619360831616},{"_id":"public/categories/算法/算法笔记/二分查找/index.html","hash":"9593acc25b73c8ab43d887a4f3d2533a7044d08d","modified":1634391682332},{"_id":"public/2021/04/22/binarySearch-algorithms/index.html","hash":"17cb5bb4af93b784ed6e7c0e6f3b8efaa4332af7","modified":1634391682332},{"_id":"source/_posts/2021/04/dfs-algorithms.md","hash":"d481e9cbcdba81f103da42b08f29931eb710047b","modified":1619618425435},{"_id":"public/categories/算法/算法笔记/深度优先搜索/index.html","hash":"8b3f3a5ca14f41fec1ca50383cb2ba630d7eb9fc","modified":1634391682332},{"_id":"public/2021/04/27/dfs-algorithms/index.html","hash":"918cc7213de54ebd4e7e4a7e58868403c0f36f17","modified":1634391682332},{"_id":"source/_posts/2021/05/redis-distributed-lock.md","hash":"224c5e26bff2c6efaeb063ef32d711292ef5f291","modified":1620009136223},{"_id":"public/2021/05/01/redis-distributed-lock/index.html","hash":"2df3f1305618ad625d2bc5388dd6dac285f3413c","modified":1634391682332},{"_id":"public/archives/2021/05/index.html","hash":"90c6297a7e89693801b6d53872b9d165c30b2afb","modified":1634391682332},{"_id":"public/tags/分布式锁/index.html","hash":"e887969e2bcf79085e397f9aac3964ebb822368b","modified":1634391682332},{"_id":"source/_posts/2021/05/redis-persistence.md","hash":"ee0d53dc590e69fe1aadb7f07fbbfc78c1e33b14","modified":1625189582858},{"_id":"public/2021/05/03/redis-persistence/index.html","hash":"cff87c503637558c5cbe4c84754b5c282f257936","modified":1634391682332},{"_id":"source/_posts/2021/05/hashMap2.md","hash":"dc4b6b3a624ad681a60bfda241f5c198292acae3","modified":1621089804804},{"_id":"source/_posts/2021/05/AQS2.md","hash":"93f2f6a099690b73e2256dc4f021d2d44482fbc8","modified":1620655732365},{"_id":"public/2021/05/15/hashMap2/index.html","hash":"18aaae15b657daa4ddc6433dba90b77ff602ae45","modified":1634391682332},{"_id":"public/2021/05/10/AQS2/index.html","hash":"8ba93db8c402b5225c3c7bf8c81b23fd119dff9c","modified":1634391682332},{"_id":"public/archives/2021/page/2/index.html","hash":"4e94ed7feb097abf257d1c7ac0d87b5308c45079","modified":1634391682332},{"_id":"source/_posts/2021/05/hashMap3.md","hash":"5d31136c8f21a2c18cff2999e252e981c5ae4fdd","modified":1621089735589},{"_id":"public/2021/05/15/hashMap3/index.html","hash":"80dc6db2bad8b862453826654680c6cefaf62460","modified":1621089758292},{"_id":"source/_posts/2021/05/http-request.md","hash":"f1483e614f5cd699867cb48d11722dfb04413419","modified":1626011106460},{"_id":"public/2021/05/16/http-request/index.html","hash":"287480cb9611517de9b15fe8a73e5d41dd4d3ac8","modified":1634391682332},{"_id":"public/categories/计算机网络/index.html","hash":"071c469ad793f4050c0b4579b3a54230725f24a3","modified":1634391682332},{"_id":"public/tags/计算机网络/index.html","hash":"f6636dbb7126be81230ed2147d8caa644cdf871d","modified":1634391682332},{"_id":"source/image/http-request/http-request.png","hash":"b36cf9ef4b00acb5321e0b040655821e66acc0c7","modified":1625986939281},{"_id":"source/image/HTTP/http-request.png","hash":"b36cf9ef4b00acb5321e0b040655821e66acc0c7","modified":1625986939281},{"_id":"source/image/HTTP/http-request1.png","hash":"b36cf9ef4b00acb5321e0b040655821e66acc0c7","modified":1625986939281},{"_id":"source/image/HTTP/http-request3.png","hash":"db35e3c88572046342d7fdab9ce73bc66081fb88","modified":1626010126269},{"_id":"source/image/HTTP/http-request2.png","hash":"9bfc4d89dfb5eb0a017d2c5b7d4a5de66392703c","modified":1625988718229},{"_id":"public/image/HTTP/http-request1.png","hash":"b36cf9ef4b00acb5321e0b040655821e66acc0c7","modified":1626011213112},{"_id":"public/image/HTTP/http-request3.png","hash":"db35e3c88572046342d7fdab9ce73bc66081fb88","modified":1626011213112},{"_id":"public/image/HTTP/http-request2.png","hash":"9bfc4d89dfb5eb0a017d2c5b7d4a5de66392703c","modified":1626011213112},{"_id":"source/_posts/2021/08/golang-study-2.md","hash":"c4f5d9a823593271e72a8114d98dd9e910d118e0","modified":1635076768967},{"_id":"source/_posts/2021/08/golang-study-1.md","hash":"e04f9770303d4129bb6955280ce2987dc7cb2fd0","modified":1629610922375},{"_id":"public/categories/Go/index.html","hash":"13a98e99ad962d492f42795bac822e29345bd434","modified":1634391682332},{"_id":"public/categories/Go/学习笔记/index.html","hash":"1f7a95a9064d0f27b7c6de52fea716662dd4cf1a","modified":1634391682332},{"_id":"public/archives/2021/08/index.html","hash":"621a723e605778673420a17624336d080a42c037","modified":1634391682332},{"_id":"public/tags/Go学习笔记/index.html","hash":"f26c7f7fbf6db5a957d3c731a5b3e515845be01a","modified":1634391682332},{"_id":"public/2021/08/01/golang-study-1/index.html","hash":"ba5e260dc31c4aa6f118f8598359d08749e808fe","modified":1634391682332},{"_id":"public/2021/08/13/golang-study-2/index.html","hash":"7e7efed4db35e5dc0608029ed28114d9f57a9ad4","modified":1635076809120}],"Category":[{"name":"MySql","_id":"ckdvmudy10005nwb5cmxjbbfo"},{"name":"Java","_id":"ckdvmudy5000anwb5af0t6hzw"},{"name":"redis","_id":"ckdvmudy8000gnwb52awt2le6"},{"name":"操作系统","_id":"ckdvmudyf000ynwb57gotgvjj"},{"name":"Collection","parent":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudyh0013nwb56t31h8nv"},{"name":"Map","parent":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudyj001anwb5hfva9ayc"},{"name":"MQ","_id":"ckdvmudyp001knwb5e9hu9n8v"},{"name":"读书笔记","_id":"ckdvmudyr001tnwb56asdcwz6"},{"name":"JUC","parent":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudyt0020nwb5g9s25g65"},{"name":"工具","parent":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudyw002cnwb5c6189e1b"},{"name":"List","parent":"ckdvmudyh0013nwb56t31h8nv","_id":"ckdvmudz0002vnwb5cc0q1661"},{"name":"基础","parent":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudz20031nwb5bmgk3sbp"},{"name":"JVM","_id":"ckdvmudz20037nwb5cg9ibrtv"},{"name":"Queue","parent":"ckdvmudyh0013nwb56t31h8nv","_id":"ckdvmudz3003bnwb5b3xnd295"},{"name":"多线程","parent":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudz3003fnwb549ur2tp7"},{"name":"RocketMQ","parent":"ckdvmudyp001knwb5e9hu9n8v","_id":"ckdvmudz4003hnwb5h5olhghm"},{"name":"数据结构","_id":"ckdvmudz5003qnwb5h2wq9sn8"},{"name":"ThinkingInJava","parent":"ckdvmudyr001tnwb56asdcwz6","_id":"ckdvmudz5003tnwb5dnrjh8v3"},{"name":"spring","_id":"ckdvmudz6003wnwb589loaw6v"},{"name":"链表","parent":"ckdvmudz5003qnwb5h2wq9sn8","_id":"ckdvmudzd004jnwb528vd67xm"},{"name":"AOP","parent":"ckdvmudz6003wnwb589loaw6v","_id":"ckdvmudze004nnwb5beajcx6d"},{"name":"多线程","_id":"ckecwk71y0001b4b54ivp0cf1"},{"name":"料理","_id":"ckffgd5e900015cb5hn3b0y9e"},{"name":"Spring","_id":"ckhan3gq200018gb5gvdv22l5"},{"name":"AOP","parent":"ckhan3gq200018gb5gvdv22l5","_id":"ckhan6dxs0000mgb5aghhf6hb"},{"name":"SpringCache","parent":"ckhan3gq200018gb5gvdv22l5","_id":"ckhan8xl00000jkb56cus9ir9"},{"name":"MyBatis","_id":"ckhevyvca0002twb53p4s5gyc"},{"name":"NIO","parent":"ckdvmudy5000anwb5af0t6hzw","_id":"ckjzgmq7b0002dsb53atj2fff"},{"name":"算法","_id":"ckm0p6af40001pwb50ti8bj4a"},{"name":"排序算法","parent":"ckm0p6af40001pwb50ti8bj4a","_id":"ckm0p6afc0004pwb57epj78vr"},{"name":"贪心算法","parent":"ckm0p6af40001pwb50ti8bj4a","_id":"cknentlbr0000tcb52y7paq43"},{"name":"算法笔记","parent":"ckm0p6af40001pwb50ti8bj4a","_id":"ckniyw28k0000okb5ehmybmzj"},{"name":"贪心算法","parent":"ckniyw28k0000okb5ehmybmzj","_id":"ckniyw28l0001okb55t923hmb"},{"name":"双指针","parent":"ckniyw28k0000okb5ehmybmzj","_id":"cknn4fcf40002awb54qxjcgud"},{"name":"二分查找","parent":"ckniyw28k0000okb5ehmybmzj","_id":"cknsy278n0002cwb5hb2i0oxw"},{"name":"深度优先搜索","parent":"ckniyw28k0000okb5ehmybmzj","_id":"cko04d9qv00024gb59nwmfkfx"},{"name":"计算机网络","_id":"ckpe2giit0000lob5grd13tbz"},{"name":"Go","_id":"cksmrwxhl0002ywb50vah0pnb"},{"name":"学习笔记","parent":"cksmrwxhl0002ywb50vah0pnb","_id":"cksmrwxhy0007ywb5exv4fers"}],"Data":[],"Page":[{"title":"categories","date":"2020-05-09T03:29:38.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-05-09 11:29:38\ntype: categories\n---\n","updated":"2020-08-15T12:34:05.007Z","path":"categories/index.html","_id":"ckdvmudwg0001nwb55bzp1khr","comments":1,"layout":"page","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""},{"title":"tags","date":"2020-05-09T03:27:57.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-05-09 11:27:57\ntype: tags\n---\n","updated":"2020-08-15T12:34:05.016Z","path":"tags/index.html","_id":"ckdvmudwh0002nwb59j6y37pl","comments":1,"layout":"page","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"Hello World","date":"2093-02-11T16:00:00.000Z","_content":"\n{% img  /image/home.png %}","source":"_posts/helloworld.md","raw":"---\ntitle: Hello World\ndate: 2093-02-12 00:00:00\n\n---\n\n{% img  /image/home.png %}","slug":"helloworld","published":1,"updated":"2020-08-15T12:51:13.255Z","_id":"ckdvmudwa0000nwb5fo957npn","comments":1,"layout":"post","photos":[],"link":"","content":"<img src=\"/image/home.png\" class=\"\">","site":{"data":{}},"length":0,"excerpt":"","more":"<img src=\"/image/home.png\" class=\"\">"},{"title":"MySql-索引","date":"2020-05-25T07:54:19.000Z","_content":"\n### 索引结构-B+树\n\n#### B+树\nm阶B+树满足一下条件：\n1. 根结点的分支数量[k]范围为[2，m]\n2. 每个分支结点包含的分支数[x]范围为[ceil(m/2), m]\n3. 分支结点的关键字数量[y]等于[x-1]，所以[y]的范围是[ceil(m/2)-1, m-1]，关键字顺序递增\n4. 所有叶子结点都在同一层，且形成一个有序链表\n<!-- more -->\n\n#### 操作导致的结构变化\n\n##### 插入\n\n   * 所有节点都没有满，直接插入\n   * 节点满了，将节点拆分为左右两个节点，将中间的关键字提向上一节点\n          节点的拆分对性能影响较大(涉及磁盘的数据移动)，所以某些情况下会使用旋转操作代替节点拆分\n          当需要拆分的叶子节点左右节点存在未满的情况(一般优先检查左节点)，会将已满的叶子节点的关\n          键字分到未满的相邻节点，并替换上一级节点的关键字，确保排序正确\n\n##### 删除\n\n   删除根据填充因子(fill factor)判断是否变化节点\n   * 节点关键字数目满足要求，直接删除，如果该关键字还存在于非叶子节点中，用该关键字右边的关键字代替\n   * 节点关键字数目少，与其兄弟节点合并，并更新上一级节点关键字，确保排序正确\n\n\n### innoDB索引\n\n#### 聚簇索引与非聚簇索引\n\n1. 聚簇索引：索引项的顺序与表中记录的物理顺序一致，且叶子节点存储了对应数据行的数据。innoDB中主键即为聚簇索引\n2. 非聚簇索引：叶子节点存储的是对应逐渐的值，索引项的顺序与表中记录的物理顺序没有关联性。对非聚簇索引的查询最后都会落到聚簇索引的二次查询。\n\n#### 回表与索引覆盖\n\n1. 回表：通过非聚簇索引查询，先通过非聚簇索引定位到主键值，再通过聚簇索引得到行数据。因此走了两边B+树的遍历，被称为回表查询。\n2. 索引覆盖：针对组合索引来说，是指能在索引树中直接获取需要查询的全部数据，无需通过主键二次查询。避免了回表查询。\n\n### sql优化\n\n#### 执行计划explain\n\nexplain命令是对sql执行的分析，主要关注type和extra两个信息：\n* type： 使用索引的级别\n       1. all：全表扫描\n       2. index：全索引扫描，通常出现在查询数据可直接在索引树中获取到，不需要获取行数据\n       3. range：使用索引范围查询\n       4. ref：查找条件使用了索引但是部位主键或者唯一索引，存在重复的值\n       5. eq_ref：查找条件使用的索引为主键或者唯一索引\n       6. const：将主键放置到where后面作为条件查询，mysql优化器能对这次查询进行优化转为一个常量\n* extra：重要补充信息\n       1. using filesort：进行额外的排序操作，无法使用索引排序\n       2. using temporary：使用临时表保存中间结果，通常由于排序，分组，多表join导致\n       3. using index：使用了索引覆盖，说明无需回表查询\n       4. using index condition ：条件包含索引和未索引的列，优化器将首先解析索引的列，并在表中查找\n                                  其他条件的行（将索引下推），MySql5.6的新特性\n       5. using where：使用where中的条件来进行表扫描\n\n       ‘using where; using index’ 与 ‘using condition’相比前者更好\n\n#### 索引分析show index from\n\n对表中索引的相关分析，以下是相对重要的信息：\n* seq_in_index：该列在索引中的位置，索引单列则为1，组合索引则为索引定义中的顺序\n* collation：索引的存储顺序，A表示升序，NULL表示无分类\n* cardinality：唯一值数目的估计值，数值越大越好\n* sub_part：被编入索引的字符数量，NULL表示全被编入\n* null：索引是否包含NULL，YES表示有，NO表示没有。通常不建议索引带有NULL值\n\n#### 建议\n\n1. 索引的创建应选择区分度高的列，且避免有NULL值(建表字段建议都设置为非null的并加上默认值)\n2. 控制索引的长度，对于varchar等类型的列新建索引时，在保证高区分度的前提下，尽量取最短的前缀作为索引值\n3. 通过对sql的explain结果针对性优化，通常需要保证type的级别高于index。且需要注意extra中\n   出现using filesort或using temporary，这都是低效率的象征。\n4. 避免复杂的联表查询，最好控制在三张表左右的关联(受表的数量级影响)\n5. 排序，分组等操作需要注意是否能使用到索引\n   \n","source":"_posts/2020/05/mysql1.md","raw":"---\ntitle: MySql-索引\ndate: 2020-05-25 15:54:19\ntags:\n- MySql索引\ncategories: \n- MySql\n---\n\n### 索引结构-B+树\n\n#### B+树\nm阶B+树满足一下条件：\n1. 根结点的分支数量[k]范围为[2，m]\n2. 每个分支结点包含的分支数[x]范围为[ceil(m/2), m]\n3. 分支结点的关键字数量[y]等于[x-1]，所以[y]的范围是[ceil(m/2)-1, m-1]，关键字顺序递增\n4. 所有叶子结点都在同一层，且形成一个有序链表\n<!-- more -->\n\n#### 操作导致的结构变化\n\n##### 插入\n\n   * 所有节点都没有满，直接插入\n   * 节点满了，将节点拆分为左右两个节点，将中间的关键字提向上一节点\n          节点的拆分对性能影响较大(涉及磁盘的数据移动)，所以某些情况下会使用旋转操作代替节点拆分\n          当需要拆分的叶子节点左右节点存在未满的情况(一般优先检查左节点)，会将已满的叶子节点的关\n          键字分到未满的相邻节点，并替换上一级节点的关键字，确保排序正确\n\n##### 删除\n\n   删除根据填充因子(fill factor)判断是否变化节点\n   * 节点关键字数目满足要求，直接删除，如果该关键字还存在于非叶子节点中，用该关键字右边的关键字代替\n   * 节点关键字数目少，与其兄弟节点合并，并更新上一级节点关键字，确保排序正确\n\n\n### innoDB索引\n\n#### 聚簇索引与非聚簇索引\n\n1. 聚簇索引：索引项的顺序与表中记录的物理顺序一致，且叶子节点存储了对应数据行的数据。innoDB中主键即为聚簇索引\n2. 非聚簇索引：叶子节点存储的是对应逐渐的值，索引项的顺序与表中记录的物理顺序没有关联性。对非聚簇索引的查询最后都会落到聚簇索引的二次查询。\n\n#### 回表与索引覆盖\n\n1. 回表：通过非聚簇索引查询，先通过非聚簇索引定位到主键值，再通过聚簇索引得到行数据。因此走了两边B+树的遍历，被称为回表查询。\n2. 索引覆盖：针对组合索引来说，是指能在索引树中直接获取需要查询的全部数据，无需通过主键二次查询。避免了回表查询。\n\n### sql优化\n\n#### 执行计划explain\n\nexplain命令是对sql执行的分析，主要关注type和extra两个信息：\n* type： 使用索引的级别\n       1. all：全表扫描\n       2. index：全索引扫描，通常出现在查询数据可直接在索引树中获取到，不需要获取行数据\n       3. range：使用索引范围查询\n       4. ref：查找条件使用了索引但是部位主键或者唯一索引，存在重复的值\n       5. eq_ref：查找条件使用的索引为主键或者唯一索引\n       6. const：将主键放置到where后面作为条件查询，mysql优化器能对这次查询进行优化转为一个常量\n* extra：重要补充信息\n       1. using filesort：进行额外的排序操作，无法使用索引排序\n       2. using temporary：使用临时表保存中间结果，通常由于排序，分组，多表join导致\n       3. using index：使用了索引覆盖，说明无需回表查询\n       4. using index condition ：条件包含索引和未索引的列，优化器将首先解析索引的列，并在表中查找\n                                  其他条件的行（将索引下推），MySql5.6的新特性\n       5. using where：使用where中的条件来进行表扫描\n\n       ‘using where; using index’ 与 ‘using condition’相比前者更好\n\n#### 索引分析show index from\n\n对表中索引的相关分析，以下是相对重要的信息：\n* seq_in_index：该列在索引中的位置，索引单列则为1，组合索引则为索引定义中的顺序\n* collation：索引的存储顺序，A表示升序，NULL表示无分类\n* cardinality：唯一值数目的估计值，数值越大越好\n* sub_part：被编入索引的字符数量，NULL表示全被编入\n* null：索引是否包含NULL，YES表示有，NO表示没有。通常不建议索引带有NULL值\n\n#### 建议\n\n1. 索引的创建应选择区分度高的列，且避免有NULL值(建表字段建议都设置为非null的并加上默认值)\n2. 控制索引的长度，对于varchar等类型的列新建索引时，在保证高区分度的前提下，尽量取最短的前缀作为索引值\n3. 通过对sql的explain结果针对性优化，通常需要保证type的级别高于index。且需要注意extra中\n   出现using filesort或using temporary，这都是低效率的象征。\n4. 避免复杂的联表查询，最好控制在三张表左右的关联(受表的数量级影响)\n5. 排序，分组等操作需要注意是否能使用到索引\n   \n","slug":"mysql1","published":1,"updated":"2020-08-15T12:34:04.996Z","_id":"ckdvmudxz0003nwb52wo6hndg","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"索引结构-B-树\"><a href=\"#索引结构-B-树\" class=\"headerlink\" title=\"索引结构-B+树\"></a>索引结构-B+树</h3><h4 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h4><p>m阶B+树满足一下条件：</p>\n<ol>\n<li>根结点的分支数量[k]范围为[2，m]</li>\n<li>每个分支结点包含的分支数[x]范围为[ceil(m/2), m]</li>\n<li>分支结点的关键字数量[y]等于[x-1]，所以[y]的范围是[ceil(m/2)-1, m-1]，关键字顺序递增</li>\n<li>所有叶子结点都在同一层，且形成一个有序链表<a id=\"more\"></a>\n\n</li>\n</ol>\n<h4 id=\"操作导致的结构变化\"><a href=\"#操作导致的结构变化\" class=\"headerlink\" title=\"操作导致的结构变化\"></a>操作导致的结构变化</h4><h5 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h5><ul>\n<li>所有节点都没有满，直接插入</li>\n<li>节点满了，将节点拆分为左右两个节点，将中间的关键字提向上一节点<pre><code>节点的拆分对性能影响较大(涉及磁盘的数据移动)，所以某些情况下会使用旋转操作代替节点拆分\n当需要拆分的叶子节点左右节点存在未满的情况(一般优先检查左节点)，会将已满的叶子节点的关\n键字分到未满的相邻节点，并替换上一级节点的关键字，确保排序正确</code></pre></li>\n</ul>\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>   删除根据填充因子(fill factor)判断是否变化节点</p>\n<ul>\n<li>节点关键字数目满足要求，直接删除，如果该关键字还存在于非叶子节点中，用该关键字右边的关键字代替</li>\n<li>节点关键字数目少，与其兄弟节点合并，并更新上一级节点关键字，确保排序正确</li>\n</ul>\n<h3 id=\"innoDB索引\"><a href=\"#innoDB索引\" class=\"headerlink\" title=\"innoDB索引\"></a>innoDB索引</h3><h4 id=\"聚簇索引与非聚簇索引\"><a href=\"#聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"聚簇索引与非聚簇索引\"></a>聚簇索引与非聚簇索引</h4><ol>\n<li>聚簇索引：索引项的顺序与表中记录的物理顺序一致，且叶子节点存储了对应数据行的数据。innoDB中主键即为聚簇索引</li>\n<li>非聚簇索引：叶子节点存储的是对应逐渐的值，索引项的顺序与表中记录的物理顺序没有关联性。对非聚簇索引的查询最后都会落到聚簇索引的二次查询。</li>\n</ol>\n<h4 id=\"回表与索引覆盖\"><a href=\"#回表与索引覆盖\" class=\"headerlink\" title=\"回表与索引覆盖\"></a>回表与索引覆盖</h4><ol>\n<li>回表：通过非聚簇索引查询，先通过非聚簇索引定位到主键值，再通过聚簇索引得到行数据。因此走了两边B+树的遍历，被称为回表查询。</li>\n<li>索引覆盖：针对组合索引来说，是指能在索引树中直接获取需要查询的全部数据，无需通过主键二次查询。避免了回表查询。</li>\n</ol>\n<h3 id=\"sql优化\"><a href=\"#sql优化\" class=\"headerlink\" title=\"sql优化\"></a>sql优化</h3><h4 id=\"执行计划explain\"><a href=\"#执行计划explain\" class=\"headerlink\" title=\"执行计划explain\"></a>执行计划explain</h4><p>explain命令是对sql执行的分析，主要关注type和extra两个信息：</p>\n<ul>\n<li><p>type： 使用索引的级别</p>\n<pre><code>1. all：全表扫描\n2. index：全索引扫描，通常出现在查询数据可直接在索引树中获取到，不需要获取行数据\n3. range：使用索引范围查询\n4. ref：查找条件使用了索引但是部位主键或者唯一索引，存在重复的值\n5. eq_ref：查找条件使用的索引为主键或者唯一索引\n6. const：将主键放置到where后面作为条件查询，mysql优化器能对这次查询进行优化转为一个常量</code></pre></li>\n<li><p>extra：重要补充信息</p>\n<pre><code>1. using filesort：进行额外的排序操作，无法使用索引排序\n2. using temporary：使用临时表保存中间结果，通常由于排序，分组，多表join导致\n3. using index：使用了索引覆盖，说明无需回表查询\n4. using index condition ：条件包含索引和未索引的列，优化器将首先解析索引的列，并在表中查找\n                           其他条件的行（将索引下推），MySql5.6的新特性\n5. using where：使用where中的条件来进行表扫描\n\n‘using where; using index’ 与 ‘using condition’相比前者更好</code></pre></li>\n</ul>\n<h4 id=\"索引分析show-index-from\"><a href=\"#索引分析show-index-from\" class=\"headerlink\" title=\"索引分析show index from\"></a>索引分析show index from</h4><p>对表中索引的相关分析，以下是相对重要的信息：</p>\n<ul>\n<li>seq_in_index：该列在索引中的位置，索引单列则为1，组合索引则为索引定义中的顺序</li>\n<li>collation：索引的存储顺序，A表示升序，NULL表示无分类</li>\n<li>cardinality：唯一值数目的估计值，数值越大越好</li>\n<li>sub_part：被编入索引的字符数量，NULL表示全被编入</li>\n<li>null：索引是否包含NULL，YES表示有，NO表示没有。通常不建议索引带有NULL值</li>\n</ul>\n<h4 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h4><ol>\n<li>索引的创建应选择区分度高的列，且避免有NULL值(建表字段建议都设置为非null的并加上默认值)</li>\n<li>控制索引的长度，对于varchar等类型的列新建索引时，在保证高区分度的前提下，尽量取最短的前缀作为索引值</li>\n<li>通过对sql的explain结果针对性优化，通常需要保证type的级别高于index。且需要注意extra中<br>出现using filesort或using temporary，这都是低效率的象征。</li>\n<li>避免复杂的联表查询，最好控制在三张表左右的关联(受表的数量级影响)</li>\n<li>排序，分组等操作需要注意是否能使用到索引</li>\n</ol>\n","site":{"data":{}},"length":1699,"excerpt":"<h3 id=\"索引结构-B-树\"><a href=\"#索引结构-B-树\" class=\"headerlink\" title=\"索引结构-B+树\"></a>索引结构-B+树</h3><h4 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h4><p>m阶B+树满足一下条件：</p>\n<ol>\n<li>根结点的分支数量[k]范围为[2，m]</li>\n<li>每个分支结点包含的分支数[x]范围为[ceil(m/2), m]</li>\n<li>分支结点的关键字数量[y]等于[x-1]，所以[y]的范围是[ceil(m/2)-1, m-1]，关键字顺序递增</li>\n<li>所有叶子结点都在同一层，且形成一个有序链表","more":"</li>\n</ol>\n<h4 id=\"操作导致的结构变化\"><a href=\"#操作导致的结构变化\" class=\"headerlink\" title=\"操作导致的结构变化\"></a>操作导致的结构变化</h4><h5 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h5><ul>\n<li>所有节点都没有满，直接插入</li>\n<li>节点满了，将节点拆分为左右两个节点，将中间的关键字提向上一节点<pre><code>节点的拆分对性能影响较大(涉及磁盘的数据移动)，所以某些情况下会使用旋转操作代替节点拆分\n当需要拆分的叶子节点左右节点存在未满的情况(一般优先检查左节点)，会将已满的叶子节点的关\n键字分到未满的相邻节点，并替换上一级节点的关键字，确保排序正确</code></pre></li>\n</ul>\n<h5 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h5><p>   删除根据填充因子(fill factor)判断是否变化节点</p>\n<ul>\n<li>节点关键字数目满足要求，直接删除，如果该关键字还存在于非叶子节点中，用该关键字右边的关键字代替</li>\n<li>节点关键字数目少，与其兄弟节点合并，并更新上一级节点关键字，确保排序正确</li>\n</ul>\n<h3 id=\"innoDB索引\"><a href=\"#innoDB索引\" class=\"headerlink\" title=\"innoDB索引\"></a>innoDB索引</h3><h4 id=\"聚簇索引与非聚簇索引\"><a href=\"#聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"聚簇索引与非聚簇索引\"></a>聚簇索引与非聚簇索引</h4><ol>\n<li>聚簇索引：索引项的顺序与表中记录的物理顺序一致，且叶子节点存储了对应数据行的数据。innoDB中主键即为聚簇索引</li>\n<li>非聚簇索引：叶子节点存储的是对应逐渐的值，索引项的顺序与表中记录的物理顺序没有关联性。对非聚簇索引的查询最后都会落到聚簇索引的二次查询。</li>\n</ol>\n<h4 id=\"回表与索引覆盖\"><a href=\"#回表与索引覆盖\" class=\"headerlink\" title=\"回表与索引覆盖\"></a>回表与索引覆盖</h4><ol>\n<li>回表：通过非聚簇索引查询，先通过非聚簇索引定位到主键值，再通过聚簇索引得到行数据。因此走了两边B+树的遍历，被称为回表查询。</li>\n<li>索引覆盖：针对组合索引来说，是指能在索引树中直接获取需要查询的全部数据，无需通过主键二次查询。避免了回表查询。</li>\n</ol>\n<h3 id=\"sql优化\"><a href=\"#sql优化\" class=\"headerlink\" title=\"sql优化\"></a>sql优化</h3><h4 id=\"执行计划explain\"><a href=\"#执行计划explain\" class=\"headerlink\" title=\"执行计划explain\"></a>执行计划explain</h4><p>explain命令是对sql执行的分析，主要关注type和extra两个信息：</p>\n<ul>\n<li><p>type： 使用索引的级别</p>\n<pre><code>1. all：全表扫描\n2. index：全索引扫描，通常出现在查询数据可直接在索引树中获取到，不需要获取行数据\n3. range：使用索引范围查询\n4. ref：查找条件使用了索引但是部位主键或者唯一索引，存在重复的值\n5. eq_ref：查找条件使用的索引为主键或者唯一索引\n6. const：将主键放置到where后面作为条件查询，mysql优化器能对这次查询进行优化转为一个常量</code></pre></li>\n<li><p>extra：重要补充信息</p>\n<pre><code>1. using filesort：进行额外的排序操作，无法使用索引排序\n2. using temporary：使用临时表保存中间结果，通常由于排序，分组，多表join导致\n3. using index：使用了索引覆盖，说明无需回表查询\n4. using index condition ：条件包含索引和未索引的列，优化器将首先解析索引的列，并在表中查找\n                           其他条件的行（将索引下推），MySql5.6的新特性\n5. using where：使用where中的条件来进行表扫描\n\n‘using where; using index’ 与 ‘using condition’相比前者更好</code></pre></li>\n</ul>\n<h4 id=\"索引分析show-index-from\"><a href=\"#索引分析show-index-from\" class=\"headerlink\" title=\"索引分析show index from\"></a>索引分析show index from</h4><p>对表中索引的相关分析，以下是相对重要的信息：</p>\n<ul>\n<li>seq_in_index：该列在索引中的位置，索引单列则为1，组合索引则为索引定义中的顺序</li>\n<li>collation：索引的存储顺序，A表示升序，NULL表示无分类</li>\n<li>cardinality：唯一值数目的估计值，数值越大越好</li>\n<li>sub_part：被编入索引的字符数量，NULL表示全被编入</li>\n<li>null：索引是否包含NULL，YES表示有，NO表示没有。通常不建议索引带有NULL值</li>\n</ul>\n<h4 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h4><ol>\n<li>索引的创建应选择区分度高的列，且避免有NULL值(建表字段建议都设置为非null的并加上默认值)</li>\n<li>控制索引的长度，对于varchar等类型的列新建索引时，在保证高区分度的前提下，尽量取最短的前缀作为索引值</li>\n<li>通过对sql的explain结果针对性优化，通常需要保证type的级别高于index。且需要注意extra中<br>出现using filesort或using temporary，这都是低效率的象征。</li>\n<li>避免复杂的联表查询，最好控制在三张表左右的关联(受表的数量级影响)</li>\n<li>排序，分组等操作需要注意是否能使用到索引</li>\n</ol>"},{"title":"ArrayList(jdk1.8)","date":"2020-05-26T01:46:14.000Z","_content":"\n### ArrayList简介\n\n       ArrayList是java.util包下实现List接口的非线程安全的动态数组类\n       优点：基于数组结构，可通过下标快速定位，查询效率快；新增涉及扩容判断，在不扩容\n             的前提下，效率也较快\n       缺点：删除，扩容操作基于数组的复制，代价较高\n<!-- more -->\n类定义如下：\n{% codeblock lang:java %}\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{% endcodeblock %}\n\n#### 属性信息\n\n{% codeblock lang:java %}\n// 默认的初始容量(存储ArrayList数据的数组长度)\nprivate static final int DEFAULT_CAPACITY = 10;\n\n// 空实例的共享空数组\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n// 有默认大小的空实例的共享数组，与 EMPTY_ELEMENTDATA 区分开，是为了在第一次add的时候做判断\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n// 存储ArrayList元素的数组缓冲区\n// 这里使用transient避免elementData的序列化，是为了防止序列化对ArrayList开辟\n// 的预留空间处理，节省空间和时间\ntransient Object[] elementData;\n\n// ArrayList包含的元素个数\nprivate int size;\n\n// 结构变化(新增，删除，扩容)的次数，是Fail-Fast的判断标准\nprotected transient int modCount = 0;\n\n// 数组可分配的最大值\n// -8 根据源码注释是由于虚拟机限制，尝试分配更大空间会容易导致\n// OutOfMemoryError: Requested array size exceeds VM limit\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n{% endcodeblock %}\n\n#### 常用方法\n\n1. 构造方法\n{% codeblock lang:java %}\n// 指定初始化容量的构造方法\n// 可以看到容量为0的会将elementData指向 EMPTY_ELEMENTDATA 即实例共享的空数组\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n\n// 无参构造方法，这里elementData初始化为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，表示容量默认10\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n\n// 构造一个包含指定集合的list\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n{% endcodeblock %}\n\n2. 其他方法\n{% codeblock lang:java %}\n// 数组容量的判断\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    // 当数组为空且有默认容量时，取两者大的一个\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\n\n// 容量更新的判断\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n\n// 增加容量的操作\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    // 扩容为旧容量的1.5倍，x >> 1(向右位移1位) == x/2\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\n// 容量超出最大值的处理\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // 这里并不禁止使用Integer.MAX_VALUE\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n\n// 新增时的下标校验\nprivate void rangeCheckForAdd(int index) {\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n{% endcodeblock %}\n\n3. 基本操作方法\n{% codeblock lang:java %}\n// 新增方法\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n\n// 指定下标的新增方法\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    elementData[index] = element;\n    size++;\n}\n\n// 元素的替换\npublic E set(int index, E element) {\n    rangeCheck(index);\n    E oldValue = elementData(index);\n    elementData[index] = element;\n    return oldValue;\n}\n\n// 删除指定下标的元素\npublic E remove(int index) {\n    // 判断index是否大于size，大于则抛出IndexOutOfBoundsException\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        // 这里涉及对数组的复制\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n    return oldValue;\n}\n\n// 删除第一次出现的指定元素\npublic boolean remove(Object o) {\n    if (o == null) {\n        for (int index = 0; index < size; index++)\n            if (elementData[index] == null) {\n                // 跳过边界校验的删除操作\n                fastRemove(index);\n                return true;\n            }\n    } else {\n        for (int index = 0; index < size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\n\n// 清空操作\npublic void clear() {\n    modCount++;\n    // clear to let GC do its work\n    for (int i = 0; i < size; i++)\n        elementData[i] = null;\n    size = 0;\n}\n\n// 新增一个集合的元素\npublic boolean addAll(Collection<? extends E> c) {\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    ensureCapacityInternal(size + numNew);  // Increments modCount\n    // 使用数组复制操作\n    System.arraycopy(a, 0, elementData, size, numNew);\n    size += numNew;\n    return numNew != 0;\n}\n{% endcodeblock %}\n\n### 小结\n\n      这里只是列出了ArrayList部分常用方法的源码。ArrayList相对比较简单容易理解，但通过对源码的解读，\n    依然能有一些收获:\n    1. 使用时需要注意其基于数组复制的操作，例如扩容，删除等。\n    2. 数组大小默认是10，每次扩容会变为原来的1.5倍大小。建议按照实际场景提前设置默认容量，可以避免扩\n       容操作\n    3. 可以看到对于数组边界之类的判断，源码中做得很充分，能够有效保证代码的安全性\n    4. 对无用的数组元素及时赋值null，使其能够被GC处理\n    5. 方法封装的一些处理，根据不同场景的需要封装方法，而不是一味的将相同的代码封装为一个方法，使得代\n       码更容易被理解","source":"_posts/2020/05/arrayList1.md","raw":"---\ntitle: ArrayList(jdk1.8)\ndate: 2020-05-26 09:46:14\ntags:\n- Java容器\ncategories:\n- Java\n- Collection\n- List\n---\n\n### ArrayList简介\n\n       ArrayList是java.util包下实现List接口的非线程安全的动态数组类\n       优点：基于数组结构，可通过下标快速定位，查询效率快；新增涉及扩容判断，在不扩容\n             的前提下，效率也较快\n       缺点：删除，扩容操作基于数组的复制，代价较高\n<!-- more -->\n类定义如下：\n{% codeblock lang:java %}\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n{% endcodeblock %}\n\n#### 属性信息\n\n{% codeblock lang:java %}\n// 默认的初始容量(存储ArrayList数据的数组长度)\nprivate static final int DEFAULT_CAPACITY = 10;\n\n// 空实例的共享空数组\nprivate static final Object[] EMPTY_ELEMENTDATA = {};\n\n// 有默认大小的空实例的共享数组，与 EMPTY_ELEMENTDATA 区分开，是为了在第一次add的时候做判断\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n\n// 存储ArrayList元素的数组缓冲区\n// 这里使用transient避免elementData的序列化，是为了防止序列化对ArrayList开辟\n// 的预留空间处理，节省空间和时间\ntransient Object[] elementData;\n\n// ArrayList包含的元素个数\nprivate int size;\n\n// 结构变化(新增，删除，扩容)的次数，是Fail-Fast的判断标准\nprotected transient int modCount = 0;\n\n// 数组可分配的最大值\n// -8 根据源码注释是由于虚拟机限制，尝试分配更大空间会容易导致\n// OutOfMemoryError: Requested array size exceeds VM limit\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n{% endcodeblock %}\n\n#### 常用方法\n\n1. 构造方法\n{% codeblock lang:java %}\n// 指定初始化容量的构造方法\n// 可以看到容量为0的会将elementData指向 EMPTY_ELEMENTDATA 即实例共享的空数组\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n\n// 无参构造方法，这里elementData初始化为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，表示容量默认10\npublic ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n\n// 构造一个包含指定集合的list\npublic ArrayList(Collection<? extends E> c) {\n    elementData = c.toArray();\n    if ((size = elementData.length) != 0) {\n        // c.toArray might (incorrectly) not return Object[] (see 6260652)\n        if (elementData.getClass() != Object[].class)\n            elementData = Arrays.copyOf(elementData, size, Object[].class);\n    } else {\n        // replace with empty array.\n        this.elementData = EMPTY_ELEMENTDATA;\n    }\n}\n{% endcodeblock %}\n\n2. 其他方法\n{% codeblock lang:java %}\n// 数组容量的判断\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    // 当数组为空且有默认容量时，取两者大的一个\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n\n\n// 容量更新的判断\nprivate void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n\n// 增加容量的操作\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    // 扩容为旧容量的1.5倍，x >> 1(向右位移1位) == x/2\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\n// 容量超出最大值的处理\nprivate static int hugeCapacity(int minCapacity) {\n    if (minCapacity < 0) // overflow\n        throw new OutOfMemoryError();\n    // 这里并不禁止使用Integer.MAX_VALUE\n    return (minCapacity > MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n}\n\n// 新增时的下标校验\nprivate void rangeCheckForAdd(int index) {\n    if (index > size || index < 0)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n{% endcodeblock %}\n\n3. 基本操作方法\n{% codeblock lang:java %}\n// 新增方法\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n\n// 指定下标的新增方法\npublic void add(int index, E element) {\n    rangeCheckForAdd(index);\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    elementData[index] = element;\n    size++;\n}\n\n// 元素的替换\npublic E set(int index, E element) {\n    rangeCheck(index);\n    E oldValue = elementData(index);\n    elementData[index] = element;\n    return oldValue;\n}\n\n// 删除指定下标的元素\npublic E remove(int index) {\n    // 判断index是否大于size，大于则抛出IndexOutOfBoundsException\n    rangeCheck(index);\n    modCount++;\n    E oldValue = elementData(index);\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        // 这里涉及对数组的复制\n        System.arraycopy(elementData, index+1, elementData, index, numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n    return oldValue;\n}\n\n// 删除第一次出现的指定元素\npublic boolean remove(Object o) {\n    if (o == null) {\n        for (int index = 0; index < size; index++)\n            if (elementData[index] == null) {\n                // 跳过边界校验的删除操作\n                fastRemove(index);\n                return true;\n            }\n    } else {\n        for (int index = 0; index < size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\n\n// 清空操作\npublic void clear() {\n    modCount++;\n    // clear to let GC do its work\n    for (int i = 0; i < size; i++)\n        elementData[i] = null;\n    size = 0;\n}\n\n// 新增一个集合的元素\npublic boolean addAll(Collection<? extends E> c) {\n    Object[] a = c.toArray();\n    int numNew = a.length;\n    ensureCapacityInternal(size + numNew);  // Increments modCount\n    // 使用数组复制操作\n    System.arraycopy(a, 0, elementData, size, numNew);\n    size += numNew;\n    return numNew != 0;\n}\n{% endcodeblock %}\n\n### 小结\n\n      这里只是列出了ArrayList部分常用方法的源码。ArrayList相对比较简单容易理解，但通过对源码的解读，\n    依然能有一些收获:\n    1. 使用时需要注意其基于数组复制的操作，例如扩容，删除等。\n    2. 数组大小默认是10，每次扩容会变为原来的1.5倍大小。建议按照实际场景提前设置默认容量，可以避免扩\n       容操作\n    3. 可以看到对于数组边界之类的判断，源码中做得很充分，能够有效保证代码的安全性\n    4. 对无用的数组元素及时赋值null，使其能够被GC处理\n    5. 方法封装的一些处理，根据不同场景的需要封装方法，而不是一味的将相同的代码封装为一个方法，使得代\n       码更容易被理解","slug":"arrayList1","published":1,"updated":"2020-08-15T12:34:04.995Z","_id":"ckdvmudy00004nwb50dv20lum","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"ArrayList简介\"><a href=\"#ArrayList简介\" class=\"headerlink\" title=\"ArrayList简介\"></a>ArrayList简介</h3><pre><code>ArrayList是java.util包下实现List接口的非线程安全的动态数组类\n优点：基于数组结构，可通过下标快速定位，查询效率快；新增涉及扩容判断，在不扩容\n      的前提下，效率也较快\n缺点：删除，扩容操作基于数组的复制，代价较高</code></pre><a id=\"more\"></a>\n<p>类定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认的初始容量(存储ArrayList数据的数组长度)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空实例的共享空数组</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有默认大小的空实例的共享数组，与 EMPTY_ELEMENTDATA 区分开，是为了在第一次add的时候做判断</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储ArrayList元素的数组缓冲区</span></span><br><span class=\"line\"><span class=\"comment\">// 这里使用transient避免elementData的序列化，是为了防止序列化对ArrayList开辟</span></span><br><span class=\"line\"><span class=\"comment\">// 的预留空间处理，节省空间和时间</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ArrayList包含的元素个数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构变化(新增，删除，扩容)的次数，是Fail-Fast的判断标准</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组可分配的最大值</span></span><br><span class=\"line\"><span class=\"comment\">// -8 根据源码注释是由于虚拟机限制，尝试分配更大空间会容易导致</span></span><br><span class=\"line\"><span class=\"comment\">// OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ol>\n<li><p>构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定初始化容量的构造方法</span></span><br><span class=\"line\"><span class=\"comment\">// 可以看到容量为0的会将elementData指向 EMPTY_ELEMENTDATA 即实例共享的空数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无参构造方法，这里elementData初始化为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，表示容量默认10</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造一个包含指定集合的list</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[]<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\">            <span class=\"title\">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其他方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组容量的判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当数组为空且有默认容量时，取两者大的一个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 容量更新的判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 增加容量的操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容为旧容量的1.5倍，x &gt;&gt; 1(向右位移1位) == x/2</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 容量超出最大值的处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">// 这里并不禁止使用Integer.MAX_VALUE</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新增时的下标校验</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>基本操作方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新增方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定下标的新增方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素的替换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除指定下标的元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断index是否大于size，大于则抛出IndexOutOfBoundsException</span></span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 这里涉及对数组的复制</span></span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index, numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除第一次出现的指定元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 跳过边界校验的删除操作</span></span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清空操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">        elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新增一个集合的元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">    ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用数组复制操作</span></span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">    size += numNew;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  这里只是列出了ArrayList部分常用方法的源码。ArrayList相对比较简单容易理解，但通过对源码的解读，\n依然能有一些收获:\n1. 使用时需要注意其基于数组复制的操作，例如扩容，删除等。\n2. 数组大小默认是10，每次扩容会变为原来的1.5倍大小。建议按照实际场景提前设置默认容量，可以避免扩\n   容操作\n3. 可以看到对于数组边界之类的判断，源码中做得很充分，能够有效保证代码的安全性\n4. 对无用的数组元素及时赋值null，使其能够被GC处理\n5. 方法封装的一些处理，根据不同场景的需要封装方法，而不是一味的将相同的代码封装为一个方法，使得代\n   码更容易被理解</code></pre>","site":{"data":{}},"length":424,"excerpt":"<h3 id=\"ArrayList简介\"><a href=\"#ArrayList简介\" class=\"headerlink\" title=\"ArrayList简介\"></a>ArrayList简介</h3><pre><code>ArrayList是java.util包下实现List接口的非线程安全的动态数组类\n优点：基于数组结构，可通过下标快速定位，查询效率快；新增涉及扩容判断，在不扩容\n      的前提下，效率也较快\n缺点：删除，扩容操作基于数组的复制，代价较高</code></pre>","more":"<p>类定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractList</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">        <span class=\"keyword\">implements</span> <span class=\"title\">List</span>&lt;<span class=\"title\">E</span>&gt;, <span class=\"title\">RandomAccess</span>, <span class=\"title\">Cloneable</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认的初始容量(存储ArrayList数据的数组长度)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空实例的共享空数组</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 有默认大小的空实例的共享数组，与 EMPTY_ELEMENTDATA 区分开，是为了在第一次add的时候做判断</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储ArrayList元素的数组缓冲区</span></span><br><span class=\"line\"><span class=\"comment\">// 这里使用transient避免elementData的序列化，是为了防止序列化对ArrayList开辟</span></span><br><span class=\"line\"><span class=\"comment\">// 的预留空间处理，节省空间和时间</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] elementData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ArrayList包含的元素个数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构变化(新增，删除，扩容)的次数，是Fail-Fast的判断标准</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组可分配的最大值</span></span><br><span class=\"line\"><span class=\"comment\">// -8 根据源码注释是由于虚拟机限制，尝试分配更大空间会容易导致</span></span><br><span class=\"line\"><span class=\"comment\">// OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class=\"number\">8</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ol>\n<li><p>构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定初始化容量的构造方法</span></span><br><span class=\"line\"><span class=\"comment\">// 可以看到容量为0的会将elementData指向 EMPTY_ELEMENTDATA 即实例共享的空数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (initialCapacity == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无参构造方法，这里elementData初始化为 DEFAULTCAPACITY_EMPTY_ELEMENTDATA，表示容量默认10</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造一个包含指定集合的list</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    elementData = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size = elementData.length) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (elementData.getClass() != Object[]<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\">            <span class=\"title\">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// replace with empty array.</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>其他方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组容量的判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateCapacity</span><span class=\"params\">(Object[] elementData, <span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当数组为空且有默认容量时，取两者大的一个</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> minCapacity;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 容量更新的判断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 增加容量的操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容为旧容量的1.5倍，x &gt;&gt; 1(向右位移1位) == x/2</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 容量超出最大值的处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hugeCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> OutOfMemoryError();</span><br><span class=\"line\">    <span class=\"comment\">// 这里并不禁止使用Integer.MAX_VALUE</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">        MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新增时的下标校验</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">rangeCheckForAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &gt; size || index &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>基本操作方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新增方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定下标的新增方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheckForAdd(index);</span><br><span class=\"line\">    ensureCapacityInternal(size + <span class=\"number\">1</span>);  <span class=\"comment\">// Increments modCount!!</span></span><br><span class=\"line\">    System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">                     size - index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素的替换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    elementData[index] = element;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除指定下标的元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断index是否大于size，大于则抛出IndexOutOfBoundsException</span></span><br><span class=\"line\">    rangeCheck(index);</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E oldValue = elementData(index);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numMoved = size - index - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (numMoved &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 这里涉及对数组的复制</span></span><br><span class=\"line\">        System.arraycopy(elementData, index+<span class=\"number\">1</span>, elementData, index, numMoved);</span><br><span class=\"line\">    elementData[--size] = <span class=\"keyword\">null</span>; <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除第一次出现的指定元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (elementData[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 跳过边界校验的删除操作</span></span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>; index &lt; size; index++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[index])) &#123;</span><br><span class=\"line\">                fastRemove(index);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清空操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">        elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新增一个集合的元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Object[] a = c.toArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">    ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">    <span class=\"comment\">// 使用数组复制操作</span></span><br><span class=\"line\">    System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">    size += numNew;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  这里只是列出了ArrayList部分常用方法的源码。ArrayList相对比较简单容易理解，但通过对源码的解读，\n依然能有一些收获:\n1. 使用时需要注意其基于数组复制的操作，例如扩容，删除等。\n2. 数组大小默认是10，每次扩容会变为原来的1.5倍大小。建议按照实际场景提前设置默认容量，可以避免扩\n   容操作\n3. 可以看到对于数组边界之类的判断，源码中做得很充分，能够有效保证代码的安全性\n4. 对无用的数组元素及时赋值null，使其能够被GC处理\n5. 方法封装的一些处理，根据不同场景的需要封装方法，而不是一味的将相同的代码封装为一个方法，使得代\n   码更容易被理解</code></pre>"},{"title":"redis部分知识点梳理","date":"2020-05-24T06:28:18.000Z","_content":"\n### 基本数据类型\n\n1. String：键值对形式，最简单的数据类型\n   应用场景：计数(String有自增/递减令明令-incr/decr key)，简单缓存\n2. List：双向链表，按照插入顺序排序，可从左/右插入/弹出数据\n   应用场景：消息队列等\n3. Map：value值为map类型，可以处理更加复杂的数据结构\n   应用场景：一些对象的存储等\n4. Set：无序集合，自动排重，有交集，并集，差集等操作\n   应用场景：适合于对多个集合数据的处理\n5. ZSet：与set类似，相比set多了一个用来排序的属性score\n   应用场景：排行榜，带有权重的数据集合等\n<!-- more -->\n\n### 使用注意\n\n1. key的命名最好有一定规则，便于管理\n2. redis是单线程，串行执行命令。在线上环境禁止使用keys等命令导致阻塞\n3. 生命周期的设置，对热点数据的缓存生命周期应当避免过于集中，防止同一时间大量热点数据失效，请求全部直接进入数据库\n\n### 线上问题及解决方案\n\n1. 数据一致性\n   问题：如何保证数据库数据与缓存数据的一致性\n   解决方案： \n             1 查询时先取缓存，缓存为空取数据库并补充到缓存\n             2 更新操作先清空缓存，再更新数据库并补充到缓存\n             3 高并发场景下引入队列，将写操作和读操作放入队列依次执行，等待写操作完成再读\n2. 缓存雪崩\n   问题：缓存压力过大导致redis服务崩溃，请求全部进入数据库\n   解决方案： \n             1 使用redis高可用方案，主从+哨兵，redis cluster等防止服务崩溃\n             2 后备方案，如果服务仍然意外崩溃，及时限流&降级，防止连锁问题\n             3 对redis服务崩溃后的数据恢复问题，使用redis持久化\n3. 缓存穿透\n   问题：请求的key不在缓存中，绕过了缓存查数据库\n   解决方案： \n             1 查不到的数据也增加一个缓存(无法解决恶意攻击的问题)\n             2 使用布隆算法，识别key\n4. 缓存击穿\n   问题：热点数据key失效瞬间，大量请求直达数据库\n   解决方案： \n             1 针对缓存生命周期可设置永不失效或者使用定时任务维护达到不失效的效果\n             2 使用互斥锁，防止大量请求同时进入，待一个请求查询完成后重构缓存，后面的请求即可走缓存查询\n5. 并发竞争\n   问题：并发场景下，对同一个key的写操作\n   解决方案： \n             1 分布式锁确保同一时间只有一个实例操作\n             2 使用时间戳判断数据有效性\n\n### redis持久化\n\n1. RDB(默认方案)\n   实现方式：创建一个子进程，与父进程共享数据段，将数据写入一个临时文件，写入成功后会替换掉之前的文件\n   触发方式：在指定的时间间隔内执行了指定的操作次数\n   优点：只有一个数据文件，便于管理维护；性能较好；适用于大数据量的恢复   \n   缺点：由于是在指定时间间隔内执行，存在丢失部分数据的情况\n2. AOF\n   实现方式：将写命令以日志的形式存储在文件中，若文件过大，会触发文件重写操作，减小文件体积\n   优点：不存在数据丢失情况\n   缺点：相比RDB性能较差，文件大，恢复速度慢","source":"_posts/2020/05/redis1.md","raw":"---\ntitle: redis部分知识点梳理\ndate: 2020-05-24 14:28:18\ntags: \n- redis\ncategories: \n- redis\n---\n\n### 基本数据类型\n\n1. String：键值对形式，最简单的数据类型\n   应用场景：计数(String有自增/递减令明令-incr/decr key)，简单缓存\n2. List：双向链表，按照插入顺序排序，可从左/右插入/弹出数据\n   应用场景：消息队列等\n3. Map：value值为map类型，可以处理更加复杂的数据结构\n   应用场景：一些对象的存储等\n4. Set：无序集合，自动排重，有交集，并集，差集等操作\n   应用场景：适合于对多个集合数据的处理\n5. ZSet：与set类似，相比set多了一个用来排序的属性score\n   应用场景：排行榜，带有权重的数据集合等\n<!-- more -->\n\n### 使用注意\n\n1. key的命名最好有一定规则，便于管理\n2. redis是单线程，串行执行命令。在线上环境禁止使用keys等命令导致阻塞\n3. 生命周期的设置，对热点数据的缓存生命周期应当避免过于集中，防止同一时间大量热点数据失效，请求全部直接进入数据库\n\n### 线上问题及解决方案\n\n1. 数据一致性\n   问题：如何保证数据库数据与缓存数据的一致性\n   解决方案： \n             1 查询时先取缓存，缓存为空取数据库并补充到缓存\n             2 更新操作先清空缓存，再更新数据库并补充到缓存\n             3 高并发场景下引入队列，将写操作和读操作放入队列依次执行，等待写操作完成再读\n2. 缓存雪崩\n   问题：缓存压力过大导致redis服务崩溃，请求全部进入数据库\n   解决方案： \n             1 使用redis高可用方案，主从+哨兵，redis cluster等防止服务崩溃\n             2 后备方案，如果服务仍然意外崩溃，及时限流&降级，防止连锁问题\n             3 对redis服务崩溃后的数据恢复问题，使用redis持久化\n3. 缓存穿透\n   问题：请求的key不在缓存中，绕过了缓存查数据库\n   解决方案： \n             1 查不到的数据也增加一个缓存(无法解决恶意攻击的问题)\n             2 使用布隆算法，识别key\n4. 缓存击穿\n   问题：热点数据key失效瞬间，大量请求直达数据库\n   解决方案： \n             1 针对缓存生命周期可设置永不失效或者使用定时任务维护达到不失效的效果\n             2 使用互斥锁，防止大量请求同时进入，待一个请求查询完成后重构缓存，后面的请求即可走缓存查询\n5. 并发竞争\n   问题：并发场景下，对同一个key的写操作\n   解决方案： \n             1 分布式锁确保同一时间只有一个实例操作\n             2 使用时间戳判断数据有效性\n\n### redis持久化\n\n1. RDB(默认方案)\n   实现方式：创建一个子进程，与父进程共享数据段，将数据写入一个临时文件，写入成功后会替换掉之前的文件\n   触发方式：在指定的时间间隔内执行了指定的操作次数\n   优点：只有一个数据文件，便于管理维护；性能较好；适用于大数据量的恢复   \n   缺点：由于是在指定时间间隔内执行，存在丢失部分数据的情况\n2. AOF\n   实现方式：将写命令以日志的形式存储在文件中，若文件过大，会触发文件重写操作，减小文件体积\n   优点：不存在数据丢失情况\n   缺点：相比RDB性能较差，文件大，恢复速度慢","slug":"redis1","published":1,"updated":"2020-08-15T12:34:04.997Z","_id":"ckdvmudy30007nwb51bfjdigi","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><ol>\n<li>String：键值对形式，最简单的数据类型<br>应用场景：计数(String有自增/递减令明令-incr/decr key)，简单缓存</li>\n<li>List：双向链表，按照插入顺序排序，可从左/右插入/弹出数据<br>应用场景：消息队列等</li>\n<li>Map：value值为map类型，可以处理更加复杂的数据结构<br>应用场景：一些对象的存储等</li>\n<li>Set：无序集合，自动排重，有交集，并集，差集等操作<br>应用场景：适合于对多个集合数据的处理</li>\n<li>ZSet：与set类似，相比set多了一个用来排序的属性score<br>应用场景：排行榜，带有权重的数据集合等<a id=\"more\"></a>\n\n</li>\n</ol>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ol>\n<li>key的命名最好有一定规则，便于管理</li>\n<li>redis是单线程，串行执行命令。在线上环境禁止使用keys等命令导致阻塞</li>\n<li>生命周期的设置，对热点数据的缓存生命周期应当避免过于集中，防止同一时间大量热点数据失效，请求全部直接进入数据库</li>\n</ol>\n<h3 id=\"线上问题及解决方案\"><a href=\"#线上问题及解决方案\" class=\"headerlink\" title=\"线上问题及解决方案\"></a>线上问题及解决方案</h3><ol>\n<li>数据一致性<br>问题：如何保证数据库数据与缓存数据的一致性<br>解决方案： <pre><code>1 查询时先取缓存，缓存为空取数据库并补充到缓存\n2 更新操作先清空缓存，再更新数据库并补充到缓存\n3 高并发场景下引入队列，将写操作和读操作放入队列依次执行，等待写操作完成再读</code></pre></li>\n<li>缓存雪崩<br>问题：缓存压力过大导致redis服务崩溃，请求全部进入数据库<br>解决方案： <pre><code>1 使用redis高可用方案，主从+哨兵，redis cluster等防止服务崩溃\n2 后备方案，如果服务仍然意外崩溃，及时限流&amp;降级，防止连锁问题\n3 对redis服务崩溃后的数据恢复问题，使用redis持久化</code></pre></li>\n<li>缓存穿透<br>问题：请求的key不在缓存中，绕过了缓存查数据库<br>解决方案： <pre><code>1 查不到的数据也增加一个缓存(无法解决恶意攻击的问题)\n2 使用布隆算法，识别key</code></pre></li>\n<li>缓存击穿<br>问题：热点数据key失效瞬间，大量请求直达数据库<br>解决方案： <pre><code>1 针对缓存生命周期可设置永不失效或者使用定时任务维护达到不失效的效果\n2 使用互斥锁，防止大量请求同时进入，待一个请求查询完成后重构缓存，后面的请求即可走缓存查询</code></pre></li>\n<li>并发竞争<br>问题：并发场景下，对同一个key的写操作<br>解决方案： <pre><code>1 分布式锁确保同一时间只有一个实例操作\n2 使用时间戳判断数据有效性</code></pre></li>\n</ol>\n<h3 id=\"redis持久化\"><a href=\"#redis持久化\" class=\"headerlink\" title=\"redis持久化\"></a>redis持久化</h3><ol>\n<li>RDB(默认方案)<br>实现方式：创建一个子进程，与父进程共享数据段，将数据写入一个临时文件，写入成功后会替换掉之前的文件<br>触发方式：在指定的时间间隔内执行了指定的操作次数<br>优点：只有一个数据文件，便于管理维护；性能较好；适用于大数据量的恢复<br>缺点：由于是在指定时间间隔内执行，存在丢失部分数据的情况</li>\n<li>AOF<br>实现方式：将写命令以日志的形式存储在文件中，若文件过大，会触发文件重写操作，减小文件体积<br>优点：不存在数据丢失情况<br>缺点：相比RDB性能较差，文件大，恢复速度慢</li>\n</ol>\n","site":{"data":{}},"length":1109,"excerpt":"<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><ol>\n<li>String：键值对形式，最简单的数据类型<br>应用场景：计数(String有自增/递减令明令-incr/decr key)，简单缓存</li>\n<li>List：双向链表，按照插入顺序排序，可从左/右插入/弹出数据<br>应用场景：消息队列等</li>\n<li>Map：value值为map类型，可以处理更加复杂的数据结构<br>应用场景：一些对象的存储等</li>\n<li>Set：无序集合，自动排重，有交集，并集，差集等操作<br>应用场景：适合于对多个集合数据的处理</li>\n<li>ZSet：与set类似，相比set多了一个用来排序的属性score<br>应用场景：排行榜，带有权重的数据集合等","more":"</li>\n</ol>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ol>\n<li>key的命名最好有一定规则，便于管理</li>\n<li>redis是单线程，串行执行命令。在线上环境禁止使用keys等命令导致阻塞</li>\n<li>生命周期的设置，对热点数据的缓存生命周期应当避免过于集中，防止同一时间大量热点数据失效，请求全部直接进入数据库</li>\n</ol>\n<h3 id=\"线上问题及解决方案\"><a href=\"#线上问题及解决方案\" class=\"headerlink\" title=\"线上问题及解决方案\"></a>线上问题及解决方案</h3><ol>\n<li>数据一致性<br>问题：如何保证数据库数据与缓存数据的一致性<br>解决方案： <pre><code>1 查询时先取缓存，缓存为空取数据库并补充到缓存\n2 更新操作先清空缓存，再更新数据库并补充到缓存\n3 高并发场景下引入队列，将写操作和读操作放入队列依次执行，等待写操作完成再读</code></pre></li>\n<li>缓存雪崩<br>问题：缓存压力过大导致redis服务崩溃，请求全部进入数据库<br>解决方案： <pre><code>1 使用redis高可用方案，主从+哨兵，redis cluster等防止服务崩溃\n2 后备方案，如果服务仍然意外崩溃，及时限流&amp;降级，防止连锁问题\n3 对redis服务崩溃后的数据恢复问题，使用redis持久化</code></pre></li>\n<li>缓存穿透<br>问题：请求的key不在缓存中，绕过了缓存查数据库<br>解决方案： <pre><code>1 查不到的数据也增加一个缓存(无法解决恶意攻击的问题)\n2 使用布隆算法，识别key</code></pre></li>\n<li>缓存击穿<br>问题：热点数据key失效瞬间，大量请求直达数据库<br>解决方案： <pre><code>1 针对缓存生命周期可设置永不失效或者使用定时任务维护达到不失效的效果\n2 使用互斥锁，防止大量请求同时进入，待一个请求查询完成后重构缓存，后面的请求即可走缓存查询</code></pre></li>\n<li>并发竞争<br>问题：并发场景下，对同一个key的写操作<br>解决方案： <pre><code>1 分布式锁确保同一时间只有一个实例操作\n2 使用时间戳判断数据有效性</code></pre></li>\n</ol>\n<h3 id=\"redis持久化\"><a href=\"#redis持久化\" class=\"headerlink\" title=\"redis持久化\"></a>redis持久化</h3><ol>\n<li>RDB(默认方案)<br>实现方式：创建一个子进程，与父进程共享数据段，将数据写入一个临时文件，写入成功后会替换掉之前的文件<br>触发方式：在指定的时间间隔内执行了指定的操作次数<br>优点：只有一个数据文件，便于管理维护；性能较好；适用于大数据量的恢复<br>缺点：由于是在指定时间间隔内执行，存在丢失部分数据的情况</li>\n<li>AOF<br>实现方式：将写命令以日志的形式存储在文件中，若文件过大，会触发文件重写操作，减小文件体积<br>优点：不存在数据丢失情况<br>缺点：相比RDB性能较差，文件大，恢复速度慢</li>\n</ol>"},{"title":"DelayQueue(jdk1.8)","date":"2020-06-30T02:46:17.000Z","_content":"\n### DelayQueue简介\n\n    DelayQueue(延迟队列)是java.util.concurrent包下的适用于一些非即时执行场景下的并发集合。\n    数据以PriorityQueue的结构存储，借助ReentrantLock保证线程安全，使用Condition完成对线程\n    的精确控制。\n<!-- more -->\n\n类定义如下：\n\n{% codeblock lang:java %}\npublic class DelayQueue<E extends Delayed> extends AbstractQueue<E>\n    implements BlockingQueue<E> \n{% endcodeblock %}\n\n  从类定义可以看到，队列中的元素对象都需要实现Delayed接口，通过实现Delayed的compareTo()和getDelay()方法实现元素的排序和取出消费的判断。\n  而DelayQueue本身是BlockingQueue的一个实现，未到执行时间的元素对象不会被取出，而是阻塞当前线程让其等待至任务的执行时间。\n\n### 属性信息\n\n{% codeblock lang:java %}\n// 可重入锁，用来保证集合操作的线程安全\nprivate final transient ReentrantLock lock = new ReentrantLock();\n\n// 队列数据用优先级队列存储\nprivate final PriorityQueue<E> q = new PriorityQueue<E>();\n\n// 当前线程\nprivate Thread leader = null;\n\n// Condition用来控制线程\nprivate final Condition available = lock.newCondition();\n{% endcodeblock %}\n\n  这里定义的线程leader，参考的多线程的Leader/Follower模式设计。\n  其思想是当有多个消费者线程去获取队列的元素对象时，同一个时刻只有一个线程成为leader等待队首对象，当取得队首对象时就通知其他的线程取代他成为leader等待下一个队首。\n\n  Condition这里用来精确的控制线程，当等待的队首对象还未到执行时间时，会使用Condition的await()方法让当前线程等待。\n\n### 核心方法\n\n{% codeblock lang:java %}\n// 入队方法\npublic boolean offer(E e) {\n    final ReentrantLock lock = this.lock;\n    // 加锁\n    lock.lock();\n    try {\n        q.offer(e);// 调用PriorityQueue的入队方法\n        if (q.peek() == e) {\n            // 队首元素是新增的元素 唤醒等待线程来处理\n            leader = null;\n            available.signal();\n        }\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n// 弹出队首元素   仍然是用ReenTrantLock保证线程安全\npublic E poll() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        E first = q.peek();\n        if (first == null || first.getDelay(NANOSECONDS) > 0)\n            return null;\n        else\n            return q.poll();\n    } finally {\n        lock.unlock();\n    }\n}\n\n\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();// 加锁\n    try {\n        for (;;) {\n            E first = q.peek();\n            if (first == null)\n                available.await();// 无队首表明队列为空 则让线程等待\n            else {\n                long delay = first.getDelay(NANOSECONDS);// 获取队首任务的剩余执行时间\n                if (delay <= 0)\n                    return q.poll();// 队首任务可以执行 弹出\n                first = null; // don't retain ref while waiting\n                // 任务还需等待，判断leader\n                if (leader != null)\n                    // leader不为空，则当前线程等待，由leader线程等待队首任务\n                    available.await();\n                else {\n                \t// leader为空，当前线程成为新的leader\n                    Thread thisThread = Thread.currentThread();\n                    leader = thisThread;\n                    try {\n                        // 设置leader线程的等待时间，确保队首任务执行的时间点就能唤醒继续处理\n                        available.awaitNanos(delay);\n                    } finally {\n                        if (leader == thisThread)\n                            // 最后置空leader，避免线程处理任务的时候继续占用leader\n                            leader = null;\n                    }\n                }\n            }\n        }\n    } finally {\n        if (leader == null && q.peek() != null)\n        \t// leader为空并且有待处理的任务，唤醒其他线程\n            available.signal();\n        lock.unlock();\n    }\n}\n{% endcodeblock%}\n\n  DelayQueue最重要的方法便是take()，消费者线程通过调用take()去依次取出队首任务进行处理。\n  只要理解了Leader/Follower模式就不难理解take()的逻辑。\n\n### 示例\n\n  这里用一个单线程生产者/消费者的示例展示下DelayQueue的基本用法\n\n{% codeblock lang:java %}\n// DelayQueue队列元素类的定义\npublic class DelayTask implements Delayed {\n\n    // 延迟时间\n    private final Long delay;\n    // 执行时间\n    private final Long exprie;\n    // 创建时间\n    private final Long create;\n    // 任务信息\n    private final String msg;\n\n    public DelayTask(Long delay, String msg) {\n        this.delay = delay;\n        this.create = System.currentTimeMillis();\n        this.exprie = create + delay;\n        this.msg = msg;\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        long now = System.currentTimeMillis();\n        return unit.convert(exprie - now, TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    public int compareTo(Delayed o) {\n        long delay1 = getDelay(TimeUnit.SECONDS);\n        long delay2 = o.getDelay(TimeUnit.SECONDS);\n        return Long.compare(delay1, delay2);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"delay:\").append(getDelay(TimeUnit.SECONDS)).append(\"msg:\").append(msg);\n        return sb.toString();\n    }\n}\n\n// Delayed接口的定义\npublic interface Delayed extends Comparable<Delayed> {\n\n    /**\n     * Returns the remaining delay associated with this object, in the\n     * given time unit.\n     *\n     * @param unit the time unit\n     * @return the remaining delay; zero or negative values indicate\n     * that the delay has already elapsed\n     */\n    long getDelay(TimeUnit unit);\n}\n{% endcodeblock %}\n\n  DelayQueue中的元素类需要实现Delayed，实现getDelay()计算任务的剩余执行时间。\n  PriorityQueue中的元素都需要继承Comparable，否则无法排序，这里是通过让Delayed继承来实现，然后在子类中重写compareTo()。\n\n{% codeblock lang:java %}\n// 任务生产逻辑\npublic static void producer(DelayQueue<DelayTask> queue) {\n    new Thread(() -> {\n        for (int i = 0; i < 10; i++) {\n            String msg = \"aaaaa\" + i;\n            // 为了便于测试，这里每隔一段时间往队列中加任务\n            try {\n                TimeUnit.SECONDS.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            DelayTask task = new DelayTask(100000L, msg);\n            queue.offer(task);\n            logger.info(\"生产任务：{}\", task.toString());\n        }\n    }).start();\n}\n\n// 任务消费逻辑\npublic static void consumer(DelayQueue<DelayTask> queue) {\n    new Thread(() -> {\n        while (true) {\n            DelayTask task = null;\n            try {\n                // 调用take()取出任务\n                task = queue.take();\n            } catch (InterruptedException e) {\n                logger.info(\"消费任务异常：{}\", e.getLocalizedMessage());\n            }\n            if (null != task) {\n                logger.info(\"消费任务:{}\", task.toString());\n            } else {\n                logger.info(\"没有待消费的任务\");\n            }\n        }\n    }).start();\n}\n{% endcodeblock %}\n\n### 小结\n\n      DelayQueue可应用于一些执行时间较为灵活的场景，比如开课前30分钟发送通知，但是课程的时间并不\n    固定，就可以动态获取课程上课时间后定义一个延迟任务等待执行。\n      示例中为了方便采用的单线程，但实际开发中，应该用多个线程作为消费者去处理队列中的任务。特别\n    是当任务的逻辑较为复杂时，单线程处理会导致后续任务超时，至于线程数可以根据实际测试去设置。\n      在写示例的过程中，有想到一个问题，就是如果有较多的任务需要在同一个时间节点执行，这时一个\n    DelayQueue就无法处理。肯定会有大量的任务超时。我的想法是，如果不考虑其他方案，可能需要采用多\n    个DelayQueue，同一个队列中避免执行时间相同的任务。在实际开发中，我们也要注意是否会有大量任务\n    的执行时间点一样。\n","source":"_posts/2020/06/DelayQueue1.md","raw":"---\ntitle: DelayQueue(jdk1.8)\ndate: 2020-06-30 10:46:17\ntags:\n- Java容器\ncategories:\n- Java\n- JUC\n---\n\n### DelayQueue简介\n\n    DelayQueue(延迟队列)是java.util.concurrent包下的适用于一些非即时执行场景下的并发集合。\n    数据以PriorityQueue的结构存储，借助ReentrantLock保证线程安全，使用Condition完成对线程\n    的精确控制。\n<!-- more -->\n\n类定义如下：\n\n{% codeblock lang:java %}\npublic class DelayQueue<E extends Delayed> extends AbstractQueue<E>\n    implements BlockingQueue<E> \n{% endcodeblock %}\n\n  从类定义可以看到，队列中的元素对象都需要实现Delayed接口，通过实现Delayed的compareTo()和getDelay()方法实现元素的排序和取出消费的判断。\n  而DelayQueue本身是BlockingQueue的一个实现，未到执行时间的元素对象不会被取出，而是阻塞当前线程让其等待至任务的执行时间。\n\n### 属性信息\n\n{% codeblock lang:java %}\n// 可重入锁，用来保证集合操作的线程安全\nprivate final transient ReentrantLock lock = new ReentrantLock();\n\n// 队列数据用优先级队列存储\nprivate final PriorityQueue<E> q = new PriorityQueue<E>();\n\n// 当前线程\nprivate Thread leader = null;\n\n// Condition用来控制线程\nprivate final Condition available = lock.newCondition();\n{% endcodeblock %}\n\n  这里定义的线程leader，参考的多线程的Leader/Follower模式设计。\n  其思想是当有多个消费者线程去获取队列的元素对象时，同一个时刻只有一个线程成为leader等待队首对象，当取得队首对象时就通知其他的线程取代他成为leader等待下一个队首。\n\n  Condition这里用来精确的控制线程，当等待的队首对象还未到执行时间时，会使用Condition的await()方法让当前线程等待。\n\n### 核心方法\n\n{% codeblock lang:java %}\n// 入队方法\npublic boolean offer(E e) {\n    final ReentrantLock lock = this.lock;\n    // 加锁\n    lock.lock();\n    try {\n        q.offer(e);// 调用PriorityQueue的入队方法\n        if (q.peek() == e) {\n            // 队首元素是新增的元素 唤醒等待线程来处理\n            leader = null;\n            available.signal();\n        }\n        return true;\n    } finally {\n        // 释放锁\n        lock.unlock();\n    }\n}\n\n\n// 弹出队首元素   仍然是用ReenTrantLock保证线程安全\npublic E poll() {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        E first = q.peek();\n        if (first == null || first.getDelay(NANOSECONDS) > 0)\n            return null;\n        else\n            return q.poll();\n    } finally {\n        lock.unlock();\n    }\n}\n\n\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();// 加锁\n    try {\n        for (;;) {\n            E first = q.peek();\n            if (first == null)\n                available.await();// 无队首表明队列为空 则让线程等待\n            else {\n                long delay = first.getDelay(NANOSECONDS);// 获取队首任务的剩余执行时间\n                if (delay <= 0)\n                    return q.poll();// 队首任务可以执行 弹出\n                first = null; // don't retain ref while waiting\n                // 任务还需等待，判断leader\n                if (leader != null)\n                    // leader不为空，则当前线程等待，由leader线程等待队首任务\n                    available.await();\n                else {\n                \t// leader为空，当前线程成为新的leader\n                    Thread thisThread = Thread.currentThread();\n                    leader = thisThread;\n                    try {\n                        // 设置leader线程的等待时间，确保队首任务执行的时间点就能唤醒继续处理\n                        available.awaitNanos(delay);\n                    } finally {\n                        if (leader == thisThread)\n                            // 最后置空leader，避免线程处理任务的时候继续占用leader\n                            leader = null;\n                    }\n                }\n            }\n        }\n    } finally {\n        if (leader == null && q.peek() != null)\n        \t// leader为空并且有待处理的任务，唤醒其他线程\n            available.signal();\n        lock.unlock();\n    }\n}\n{% endcodeblock%}\n\n  DelayQueue最重要的方法便是take()，消费者线程通过调用take()去依次取出队首任务进行处理。\n  只要理解了Leader/Follower模式就不难理解take()的逻辑。\n\n### 示例\n\n  这里用一个单线程生产者/消费者的示例展示下DelayQueue的基本用法\n\n{% codeblock lang:java %}\n// DelayQueue队列元素类的定义\npublic class DelayTask implements Delayed {\n\n    // 延迟时间\n    private final Long delay;\n    // 执行时间\n    private final Long exprie;\n    // 创建时间\n    private final Long create;\n    // 任务信息\n    private final String msg;\n\n    public DelayTask(Long delay, String msg) {\n        this.delay = delay;\n        this.create = System.currentTimeMillis();\n        this.exprie = create + delay;\n        this.msg = msg;\n    }\n\n    @Override\n    public long getDelay(TimeUnit unit) {\n        long now = System.currentTimeMillis();\n        return unit.convert(exprie - now, TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    public int compareTo(Delayed o) {\n        long delay1 = getDelay(TimeUnit.SECONDS);\n        long delay2 = o.getDelay(TimeUnit.SECONDS);\n        return Long.compare(delay1, delay2);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"delay:\").append(getDelay(TimeUnit.SECONDS)).append(\"msg:\").append(msg);\n        return sb.toString();\n    }\n}\n\n// Delayed接口的定义\npublic interface Delayed extends Comparable<Delayed> {\n\n    /**\n     * Returns the remaining delay associated with this object, in the\n     * given time unit.\n     *\n     * @param unit the time unit\n     * @return the remaining delay; zero or negative values indicate\n     * that the delay has already elapsed\n     */\n    long getDelay(TimeUnit unit);\n}\n{% endcodeblock %}\n\n  DelayQueue中的元素类需要实现Delayed，实现getDelay()计算任务的剩余执行时间。\n  PriorityQueue中的元素都需要继承Comparable，否则无法排序，这里是通过让Delayed继承来实现，然后在子类中重写compareTo()。\n\n{% codeblock lang:java %}\n// 任务生产逻辑\npublic static void producer(DelayQueue<DelayTask> queue) {\n    new Thread(() -> {\n        for (int i = 0; i < 10; i++) {\n            String msg = \"aaaaa\" + i;\n            // 为了便于测试，这里每隔一段时间往队列中加任务\n            try {\n                TimeUnit.SECONDS.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            DelayTask task = new DelayTask(100000L, msg);\n            queue.offer(task);\n            logger.info(\"生产任务：{}\", task.toString());\n        }\n    }).start();\n}\n\n// 任务消费逻辑\npublic static void consumer(DelayQueue<DelayTask> queue) {\n    new Thread(() -> {\n        while (true) {\n            DelayTask task = null;\n            try {\n                // 调用take()取出任务\n                task = queue.take();\n            } catch (InterruptedException e) {\n                logger.info(\"消费任务异常：{}\", e.getLocalizedMessage());\n            }\n            if (null != task) {\n                logger.info(\"消费任务:{}\", task.toString());\n            } else {\n                logger.info(\"没有待消费的任务\");\n            }\n        }\n    }).start();\n}\n{% endcodeblock %}\n\n### 小结\n\n      DelayQueue可应用于一些执行时间较为灵活的场景，比如开课前30分钟发送通知，但是课程的时间并不\n    固定，就可以动态获取课程上课时间后定义一个延迟任务等待执行。\n      示例中为了方便采用的单线程，但实际开发中，应该用多个线程作为消费者去处理队列中的任务。特别\n    是当任务的逻辑较为复杂时，单线程处理会导致后续任务超时，至于线程数可以根据实际测试去设置。\n      在写示例的过程中，有想到一个问题，就是如果有较多的任务需要在同一个时间节点执行，这时一个\n    DelayQueue就无法处理。肯定会有大量的任务超时。我的想法是，如果不考虑其他方案，可能需要采用多\n    个DelayQueue，同一个队列中避免执行时间相同的任务。在实际开发中，我们也要注意是否会有大量任务\n    的执行时间点一样。\n","slug":"DelayQueue1","published":1,"updated":"2020-08-15T12:34:04.998Z","_id":"ckdvmudy40008nwb5hawecc1z","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"DelayQueue简介\"><a href=\"#DelayQueue简介\" class=\"headerlink\" title=\"DelayQueue简介\"></a>DelayQueue简介</h3><pre><code>DelayQueue(延迟队列)是java.util.concurrent包下的适用于一些非即时执行场景下的并发集合。\n数据以PriorityQueue的结构存储，借助ReentrantLock保证线程安全，使用Condition完成对线程\n的精确控制。</code></pre><a id=\"more\"></a>\n\n<p>类定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayQueue</span>&lt;<span class=\"title\">E</span> <span class=\"keyword\">extends</span> <span class=\"title\">Delayed</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueue</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">BlockingQueue</span>&lt;<span class=\"title\">E</span>&gt; </span></span><br></pre></td></tr></table></figure>\n\n<p>  从类定义可以看到，队列中的元素对象都需要实现Delayed接口，通过实现Delayed的compareTo()和getDelay()方法实现元素的排序和取出消费的判断。<br>  而DelayQueue本身是BlockingQueue的一个实现，未到执行时间的元素对象不会被取出，而是阻塞当前线程让其等待至任务的执行时间。</p>\n<h3 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可重入锁，用来保证集合操作的线程安全</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 队列数据用优先级队列存储</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;E&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当前线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Thread leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Condition用来控制线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>\n\n<p>  这里定义的线程leader，参考的多线程的Leader/Follower模式设计。<br>  其思想是当有多个消费者线程去获取队列的元素对象时，同一个时刻只有一个线程成为leader等待队首对象，当取得队首对象时就通知其他的线程取代他成为leader等待下一个队首。</p>\n<p>  Condition这里用来精确的控制线程，当等待的队首对象还未到执行时间时，会使用Condition的await()方法让当前线程等待。</p>\n<h3 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入队方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        q.offer(e);<span class=\"comment\">// 调用PriorityQueue的入队方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.peek() == e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 队首元素是新增的元素 唤醒等待线程来处理</span></span><br><span class=\"line\">            leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            available.signal();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹出队首元素   仍然是用ReenTrantLock保证线程安全</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        E first = q.peek();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span> || first.getDelay(NANOSECONDS) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> q.poll();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lockInterruptibly();<span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            E first = q.peek();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                available.await();<span class=\"comment\">// 无队首表明队列为空 则让线程等待</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> delay = first.getDelay(NANOSECONDS);<span class=\"comment\">// 获取队首任务的剩余执行时间</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> q.poll();<span class=\"comment\">// 队首任务可以执行 弹出</span></span><br><span class=\"line\">                first = <span class=\"keyword\">null</span>; <span class=\"comment\">// don't retain ref while waiting</span></span><br><span class=\"line\">                <span class=\"comment\">// 任务还需等待，判断leader</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (leader != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// leader不为空，则当前线程等待，由leader线程等待队首任务</span></span><br><span class=\"line\">                    available.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                \t<span class=\"comment\">// leader为空，当前线程成为新的leader</span></span><br><span class=\"line\">                    Thread thisThread = Thread.currentThread();</span><br><span class=\"line\">                    leader = thisThread;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 设置leader线程的等待时间，确保队首任务执行的时间点就能唤醒继续处理</span></span><br><span class=\"line\">                        available.awaitNanos(delay);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (leader == thisThread)</span><br><span class=\"line\">                            <span class=\"comment\">// 最后置空leader，避免线程处理任务的时候继续占用leader</span></span><br><span class=\"line\">                            leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leader == <span class=\"keyword\">null</span> &amp;&amp; q.peek() != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        \t<span class=\"comment\">// leader为空并且有待处理的任务，唤醒其他线程</span></span><br><span class=\"line\">            available.signal();</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  DelayQueue最重要的方法便是take()，消费者线程通过调用take()去依次取出队首任务进行处理。<br>  只要理解了Leader/Follower模式就不难理解take()的逻辑。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>  这里用一个单线程生产者/消费者的示例展示下DelayQueue的基本用法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DelayQueue队列元素类的定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Delayed</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 延迟时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Long delay;</span><br><span class=\"line\">    <span class=\"comment\">// 执行时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Long exprie;</span><br><span class=\"line\">    <span class=\"comment\">// 创建时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Long create;</span><br><span class=\"line\">    <span class=\"comment\">// 任务信息</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DelayTask</span><span class=\"params\">(Long delay, String msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.delay = delay;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.create = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.exprie = create + delay;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.msg = msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unit.convert(exprie - now, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Delayed o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay1 = getDelay(TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay2 = o.getDelay(TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Long.compare(delay1, delay2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        sb.append(<span class=\"string\">\"delay:\"</span>).append(getDelay(TimeUnit.SECONDS)).append(<span class=\"string\">\"msg:\"</span>).append(msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Delayed接口的定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Delayed</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Delayed</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the remaining delay associated with this object, in the</span></span><br><span class=\"line\"><span class=\"comment\">     * given time unit.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit the time unit</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the remaining delay; zero or negative values indicate</span></span><br><span class=\"line\"><span class=\"comment\">     * that the delay has already elapsed</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  DelayQueue中的元素类需要实现Delayed，实现getDelay()计算任务的剩余执行时间。<br>  PriorityQueue中的元素都需要继承Comparable，否则无法排序，这里是通过让Delayed继承来实现，然后在子类中重写compareTo()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 任务生产逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">producer</span><span class=\"params\">(DelayQueue&lt;DelayTask&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            String msg = <span class=\"string\">\"aaaaa\"</span> + i;</span><br><span class=\"line\">            <span class=\"comment\">// 为了便于测试，这里每隔一段时间往队列中加任务</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            DelayTask task = <span class=\"keyword\">new</span> DelayTask(<span class=\"number\">100000L</span>, msg);</span><br><span class=\"line\">            queue.offer(task);</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"生产任务：&#123;&#125;\"</span>, task.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 任务消费逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">consumer</span><span class=\"params\">(DelayQueue&lt;DelayTask&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            DelayTask task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用take()取出任务</span></span><br><span class=\"line\">                task = queue.take();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"消费任务异常：&#123;&#125;\"</span>, e.getLocalizedMessage());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != task) &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"消费任务:&#123;&#125;\"</span>, task.toString());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"没有待消费的任务\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  DelayQueue可应用于一些执行时间较为灵活的场景，比如开课前30分钟发送通知，但是课程的时间并不\n固定，就可以动态获取课程上课时间后定义一个延迟任务等待执行。\n  示例中为了方便采用的单线程，但实际开发中，应该用多个线程作为消费者去处理队列中的任务。特别\n是当任务的逻辑较为复杂时，单线程处理会导致后续任务超时，至于线程数可以根据实际测试去设置。\n  在写示例的过程中，有想到一个问题，就是如果有较多的任务需要在同一个时间节点执行，这时一个\nDelayQueue就无法处理。肯定会有大量的任务超时。我的想法是，如果不考虑其他方案，可能需要采用多\n个DelayQueue，同一个队列中避免执行时间相同的任务。在实际开发中，我们也要注意是否会有大量任务\n的执行时间点一样。</code></pre>","site":{"data":{}},"length":1088,"excerpt":"<h3 id=\"DelayQueue简介\"><a href=\"#DelayQueue简介\" class=\"headerlink\" title=\"DelayQueue简介\"></a>DelayQueue简介</h3><pre><code>DelayQueue(延迟队列)是java.util.concurrent包下的适用于一些非即时执行场景下的并发集合。\n数据以PriorityQueue的结构存储，借助ReentrantLock保证线程安全，使用Condition完成对线程\n的精确控制。</code></pre>","more":"<p>类定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayQueue</span>&lt;<span class=\"title\">E</span> <span class=\"keyword\">extends</span> <span class=\"title\">Delayed</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueue</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">BlockingQueue</span>&lt;<span class=\"title\">E</span>&gt; </span></span><br></pre></td></tr></table></figure>\n\n<p>  从类定义可以看到，队列中的元素对象都需要实现Delayed接口，通过实现Delayed的compareTo()和getDelay()方法实现元素的排序和取出消费的判断。<br>  而DelayQueue本身是BlockingQueue的一个实现，未到执行时间的元素对象不会被取出，而是阻塞当前线程让其等待至任务的执行时间。</p>\n<h3 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可重入锁，用来保证集合操作的线程安全</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">transient</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 队列数据用优先级队列存储</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PriorityQueue&lt;E&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;E&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当前线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Thread leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Condition用来控制线程</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>\n\n<p>  这里定义的线程leader，参考的多线程的Leader/Follower模式设计。<br>  其思想是当有多个消费者线程去获取队列的元素对象时，同一个时刻只有一个线程成为leader等待队首对象，当取得队首对象时就通知其他的线程取代他成为leader等待下一个队首。</p>\n<p>  Condition这里用来精确的控制线程，当等待的队首对象还未到执行时间时，会使用Condition的await()方法让当前线程等待。</p>\n<h3 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入队方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        q.offer(e);<span class=\"comment\">// 调用PriorityQueue的入队方法</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (q.peek() == e) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 队首元素是新增的元素 唤醒等待线程来处理</span></span><br><span class=\"line\">            leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            available.signal();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹出队首元素   仍然是用ReenTrantLock保证线程安全</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        E first = q.peek();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span> || first.getDelay(NANOSECONDS) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> q.poll();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock lock = <span class=\"keyword\">this</span>.lock;</span><br><span class=\"line\">    lock.lockInterruptibly();<span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            E first = q.peek();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                available.await();<span class=\"comment\">// 无队首表明队列为空 则让线程等待</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> delay = first.getDelay(NANOSECONDS);<span class=\"comment\">// 获取队首任务的剩余执行时间</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (delay &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> q.poll();<span class=\"comment\">// 队首任务可以执行 弹出</span></span><br><span class=\"line\">                first = <span class=\"keyword\">null</span>; <span class=\"comment\">// don't retain ref while waiting</span></span><br><span class=\"line\">                <span class=\"comment\">// 任务还需等待，判断leader</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (leader != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"comment\">// leader不为空，则当前线程等待，由leader线程等待队首任务</span></span><br><span class=\"line\">                    available.await();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                \t<span class=\"comment\">// leader为空，当前线程成为新的leader</span></span><br><span class=\"line\">                    Thread thisThread = Thread.currentThread();</span><br><span class=\"line\">                    leader = thisThread;</span><br><span class=\"line\">                    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                        <span class=\"comment\">// 设置leader线程的等待时间，确保队首任务执行的时间点就能唤醒继续处理</span></span><br><span class=\"line\">                        available.awaitNanos(delay);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (leader == thisThread)</span><br><span class=\"line\">                            <span class=\"comment\">// 最后置空leader，避免线程处理任务的时候继续占用leader</span></span><br><span class=\"line\">                            leader = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leader == <span class=\"keyword\">null</span> &amp;&amp; q.peek() != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        \t<span class=\"comment\">// leader为空并且有待处理的任务，唤醒其他线程</span></span><br><span class=\"line\">            available.signal();</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  DelayQueue最重要的方法便是take()，消费者线程通过调用take()去依次取出队首任务进行处理。<br>  只要理解了Leader/Follower模式就不难理解take()的逻辑。</p>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><p>  这里用一个单线程生产者/消费者的示例展示下DelayQueue的基本用法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// DelayQueue队列元素类的定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelayTask</span> <span class=\"keyword\">implements</span> <span class=\"title\">Delayed</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 延迟时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Long delay;</span><br><span class=\"line\">    <span class=\"comment\">// 执行时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Long exprie;</span><br><span class=\"line\">    <span class=\"comment\">// 创建时间</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Long create;</span><br><span class=\"line\">    <span class=\"comment\">// 任务信息</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DelayTask</span><span class=\"params\">(Long delay, String msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.delay = delay;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.create = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.exprie = create + delay;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.msg = msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> now = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> unit.convert(exprie - now, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Delayed o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay1 = getDelay(TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> delay2 = o.getDelay(TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Long.compare(delay1, delay2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        sb.append(<span class=\"string\">\"delay:\"</span>).append(getDelay(TimeUnit.SECONDS)).append(<span class=\"string\">\"msg:\"</span>).append(msg);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Delayed接口的定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Delayed</span> <span class=\"keyword\">extends</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Delayed</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the remaining delay associated with this object, in the</span></span><br><span class=\"line\"><span class=\"comment\">     * given time unit.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> unit the time unit</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the remaining delay; zero or negative values indicate</span></span><br><span class=\"line\"><span class=\"comment\">     * that the delay has already elapsed</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getDelay</span><span class=\"params\">(TimeUnit unit)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  DelayQueue中的元素类需要实现Delayed，实现getDelay()计算任务的剩余执行时间。<br>  PriorityQueue中的元素都需要继承Comparable，否则无法排序，这里是通过让Delayed继承来实现，然后在子类中重写compareTo()。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 任务生产逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">producer</span><span class=\"params\">(DelayQueue&lt;DelayTask&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            String msg = <span class=\"string\">\"aaaaa\"</span> + i;</span><br><span class=\"line\">            <span class=\"comment\">// 为了便于测试，这里每隔一段时间往队列中加任务</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            DelayTask task = <span class=\"keyword\">new</span> DelayTask(<span class=\"number\">100000L</span>, msg);</span><br><span class=\"line\">            queue.offer(task);</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"生产任务：&#123;&#125;\"</span>, task.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 任务消费逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">consumer</span><span class=\"params\">(DelayQueue&lt;DelayTask&gt; queue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            DelayTask task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 调用take()取出任务</span></span><br><span class=\"line\">                task = queue.take();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"消费任务异常：&#123;&#125;\"</span>, e.getLocalizedMessage());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != task) &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"消费任务:&#123;&#125;\"</span>, task.toString());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"没有待消费的任务\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  DelayQueue可应用于一些执行时间较为灵活的场景，比如开课前30分钟发送通知，但是课程的时间并不\n固定，就可以动态获取课程上课时间后定义一个延迟任务等待执行。\n  示例中为了方便采用的单线程，但实际开发中，应该用多个线程作为消费者去处理队列中的任务。特别\n是当任务的逻辑较为复杂时，单线程处理会导致后续任务超时，至于线程数可以根据实际测试去设置。\n  在写示例的过程中，有想到一个问题，就是如果有较多的任务需要在同一个时间节点执行，这时一个\nDelayQueue就无法处理。肯定会有大量的任务超时。我的想法是，如果不考虑其他方案，可能需要采用多\n个DelayQueue，同一个队列中避免执行时间相同的任务。在实际开发中，我们也要注意是否会有大量任务\n的执行时间点一样。</code></pre>"},{"title":"视频url的处理","date":"2020-05-09T03:09:23.000Z","_content":"\n### 视频url的处理\n\n1. 从url中读取流\n2. 将流转化为文件\n3. 使用MultimediaInfo中的方法获取视频文件的信息\n<!-- more -->\n\n{% codeblock lang:java %}\n<!-- 添加依赖 -->\n<dependency>\n    <groupId>it.sauronsoftware</groupId>\n    <artifactId>jave</artifactId>\n    <version>1.0.2</version>\n</dependency>\n{% endcodeblock %}\n\n{% codeblock lang:java %}\nimport it.sauronsoftware.jave.Encoder;\nimport it.sauronsoftware.jave.EncoderException;\nimport it.sauronsoftware.jave.MultimediaInfo;\n\n// 因为收到的是链接地址，所以需要先将链接转化为文件\n    /**\n     * 从链接地址读取流\n     *\n     * @param urlPath\n     * @return\n     */\n    public static InputStream getIsFromUrl(String urlPath) {\n        HttpURLConnection conn = null;\n        try {\n            String urlStr = URLDecoder.decode(urlPath, \"UTF-8\");\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(3000);\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            logger.error(\"[Method-getIsFromUrl]exception:{}\", ioe.getMessage());\n        }finally{\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * 将流读成文件\n     *\n     * @param ins\n     * @param file\n     * @throws IOException\n     */\n    public static void inputStreamToFile(InputStream ins, File file) {\n        OutputStream os = null;\n        try {\n            os = new FileOutputStream(file);\n            int bytesRead = 0;\n            int a = 8192;\n            byte[] buffer = new byte[a];\n            while ((bytesRead = ins.read(buffer, 0, a)) != -1) {\n                os.write(buffer, 0, bytesRead);\n            }\n        } catch (IOException ioe) {\n            logger.error(\"[Method-inputStreamToFile]exception:{}\", ioe.getMessage());\n        } finally {\n            try {\n                if (null != os) {\n                    os.close();\n                }\n            } catch (IOException ioe) {\n                logger.error(\"[Method-inputStreamToFile]close-exception:{}\", ioe.getMessage());\n            }\n        }\n    }\n\n    /**\n     * 获取网络文件，暂存为临时文件\n     *\n     * @param url\n     * @param tempPath 临时文件地址\n     * @return\n     * @throws UnknownHostException\n     * @throws IOException\n     */\n    public static File getFileFromUrl(String url, String tempPath) \n                                      throws UnknownHostException, IOException {\n        //创建临时文件\n        File file = new File(tempPath);\n        File tmpFile = File.createTempFile(\"temp\", \".tmp\", file);\n        // 程序结束后删除（缓存delete命令，jvm停止时执行）\n        tmpFile.deleteOnExit();\n        logger.info(\"[getFileFromUrl]create file from url:{},path:{}\", \n                        url, file.getAbsolutePath());\n        InputStream is = getIsFromUrl(url);\n        if (null != is) {\n            inputStreamToFile(is, tmpFile);\n        }\n        return tmpFile;\n    }\n\n    /**\n     * 获取视频时长 单位秒\n     */\n    public static Long getDuration(File file) throws EncoderException {\n        MultimediaInfo m = new Encoder().getInfo(file);\n        return m.getDuration() / 1000;\n    }\n{% endcodeblock %}\n\n上述代码就是获取一个视频地址视频时长的全部内容。逻辑比较简单，先把链接地址读取成文件流，\n然后用jave的方法获取其时长(单位是毫秒，因为业务需求将其计算转为秒)。\n","source":"_posts/2020/05/视频操作.md","raw":"---\ntitle: 视频url的处理\ndate: 2020-05-09 11:09:23\ntags: \n- 工具\ncategories:\n- Java\n- 工具\n---\n\n### 视频url的处理\n\n1. 从url中读取流\n2. 将流转化为文件\n3. 使用MultimediaInfo中的方法获取视频文件的信息\n<!-- more -->\n\n{% codeblock lang:java %}\n<!-- 添加依赖 -->\n<dependency>\n    <groupId>it.sauronsoftware</groupId>\n    <artifactId>jave</artifactId>\n    <version>1.0.2</version>\n</dependency>\n{% endcodeblock %}\n\n{% codeblock lang:java %}\nimport it.sauronsoftware.jave.Encoder;\nimport it.sauronsoftware.jave.EncoderException;\nimport it.sauronsoftware.jave.MultimediaInfo;\n\n// 因为收到的是链接地址，所以需要先将链接转化为文件\n    /**\n     * 从链接地址读取流\n     *\n     * @param urlPath\n     * @return\n     */\n    public static InputStream getIsFromUrl(String urlPath) {\n        HttpURLConnection conn = null;\n        try {\n            String urlStr = URLDecoder.decode(urlPath, \"UTF-8\");\n            URL url = new URL(urlStr);\n            conn = (HttpURLConnection) url.openConnection();\n            conn.setRequestMethod(\"GET\");\n            conn.setConnectTimeout(3000);\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            logger.error(\"[Method-getIsFromUrl]exception:{}\", ioe.getMessage());\n        }finally{\n            if (conn != null) {\n                conn.disconnect();\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * 将流读成文件\n     *\n     * @param ins\n     * @param file\n     * @throws IOException\n     */\n    public static void inputStreamToFile(InputStream ins, File file) {\n        OutputStream os = null;\n        try {\n            os = new FileOutputStream(file);\n            int bytesRead = 0;\n            int a = 8192;\n            byte[] buffer = new byte[a];\n            while ((bytesRead = ins.read(buffer, 0, a)) != -1) {\n                os.write(buffer, 0, bytesRead);\n            }\n        } catch (IOException ioe) {\n            logger.error(\"[Method-inputStreamToFile]exception:{}\", ioe.getMessage());\n        } finally {\n            try {\n                if (null != os) {\n                    os.close();\n                }\n            } catch (IOException ioe) {\n                logger.error(\"[Method-inputStreamToFile]close-exception:{}\", ioe.getMessage());\n            }\n        }\n    }\n\n    /**\n     * 获取网络文件，暂存为临时文件\n     *\n     * @param url\n     * @param tempPath 临时文件地址\n     * @return\n     * @throws UnknownHostException\n     * @throws IOException\n     */\n    public static File getFileFromUrl(String url, String tempPath) \n                                      throws UnknownHostException, IOException {\n        //创建临时文件\n        File file = new File(tempPath);\n        File tmpFile = File.createTempFile(\"temp\", \".tmp\", file);\n        // 程序结束后删除（缓存delete命令，jvm停止时执行）\n        tmpFile.deleteOnExit();\n        logger.info(\"[getFileFromUrl]create file from url:{},path:{}\", \n                        url, file.getAbsolutePath());\n        InputStream is = getIsFromUrl(url);\n        if (null != is) {\n            inputStreamToFile(is, tmpFile);\n        }\n        return tmpFile;\n    }\n\n    /**\n     * 获取视频时长 单位秒\n     */\n    public static Long getDuration(File file) throws EncoderException {\n        MultimediaInfo m = new Encoder().getInfo(file);\n        return m.getDuration() / 1000;\n    }\n{% endcodeblock %}\n\n上述代码就是获取一个视频地址视频时长的全部内容。逻辑比较简单，先把链接地址读取成文件流，\n然后用jave的方法获取其时长(单位是毫秒，因为业务需求将其计算转为秒)。\n","slug":"视频操作","published":1,"updated":"2020-08-15T12:34:04.997Z","_id":"ckdvmudy50009nwb57zvzgdyz","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"视频url的处理\"><a href=\"#视频url的处理\" class=\"headerlink\" title=\"视频url的处理\"></a>视频url的处理</h3><ol>\n<li>从url中读取流</li>\n<li>将流转化为文件</li>\n<li>使用MultimediaInfo中的方法获取视频文件的信息<a id=\"more\"></a>\n\n</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 添加依赖 --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;it.sauronsoftware&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jave&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0.2&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> it.sauronsoftware.jave.Encoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> it.sauronsoftware.jave.EncoderException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> it.sauronsoftware.jave.MultimediaInfo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 因为收到的是链接地址，所以需要先将链接转化为文件</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从链接地址读取流</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> urlPath</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> InputStream <span class=\"title\">getIsFromUrl</span><span class=\"params\">(String urlPath)</span> </span>&#123;</span><br><span class=\"line\">        HttpURLConnection conn = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String urlStr = URLDecoder.decode(urlPath, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">            URL url = <span class=\"keyword\">new</span> URL(urlStr);</span><br><span class=\"line\">            conn = (HttpURLConnection) url.openConnection();</span><br><span class=\"line\">            conn.setRequestMethod(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\">            conn.setConnectTimeout(<span class=\"number\">3000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> conn.getInputStream();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"[Method-getIsFromUrl]exception:&#123;&#125;\"</span>, ioe.getMessage());</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (conn != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                conn.disconnect();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将流读成文件</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ins</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> file</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">inputStreamToFile</span><span class=\"params\">(InputStream ins, File file)</span> </span>&#123;</span><br><span class=\"line\">        OutputStream os = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            os = <span class=\"keyword\">new</span> FileOutputStream(file);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> bytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = <span class=\"number\">8192</span>;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[a];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((bytesRead = ins.read(buffer, <span class=\"number\">0</span>, a)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                os.write(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"[Method-inputStreamToFile]exception:&#123;&#125;\"</span>, ioe.getMessage());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != os) &#123;</span><br><span class=\"line\">                    os.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"[Method-inputStreamToFile]close-exception:&#123;&#125;\"</span>, ioe.getMessage());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取网络文件，暂存为临时文件</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> url</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> tempPath 临时文件地址</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> UnknownHostException</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> File <span class=\"title\">getFileFromUrl</span><span class=\"params\">(String url, String tempPath)</span> </span></span><br><span class=\"line\"><span class=\"function\">                                      <span class=\"keyword\">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建临时文件</span></span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(tempPath);</span><br><span class=\"line\">        File tmpFile = File.createTempFile(<span class=\"string\">\"temp\"</span>, <span class=\"string\">\".tmp\"</span>, file);</span><br><span class=\"line\">        <span class=\"comment\">// 程序结束后删除（缓存delete命令，jvm停止时执行）</span></span><br><span class=\"line\">        tmpFile.deleteOnExit();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"[getFileFromUrl]create file from url:&#123;&#125;,path:&#123;&#125;\"</span>, </span><br><span class=\"line\">                        url, file.getAbsolutePath());</span><br><span class=\"line\">        InputStream is = getIsFromUrl(url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != is) &#123;</span><br><span class=\"line\">            inputStreamToFile(is, tmpFile);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmpFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取视频时长 单位秒</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Long <span class=\"title\">getDuration</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> EncoderException </span>&#123;</span><br><span class=\"line\">        MultimediaInfo m = <span class=\"keyword\">new</span> Encoder().getInfo(file);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m.getDuration() / <span class=\"number\">1000</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码就是获取一个视频地址视频时长的全部内容。逻辑比较简单，先把链接地址读取成文件流，<br>然后用jave的方法获取其时长(单位是毫秒，因为业务需求将其计算转为秒)。</p>\n","site":{"data":{}},"length":133,"excerpt":"<h3 id=\"视频url的处理\"><a href=\"#视频url的处理\" class=\"headerlink\" title=\"视频url的处理\"></a>视频url的处理</h3><ol>\n<li>从url中读取流</li>\n<li>将流转化为文件</li>\n<li>使用MultimediaInfo中的方法获取视频文件的信息","more":"</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 添加依赖 --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;it.sauronsoftware&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;jave&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.0.2&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> it.sauronsoftware.jave.Encoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> it.sauronsoftware.jave.EncoderException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> it.sauronsoftware.jave.MultimediaInfo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 因为收到的是链接地址，所以需要先将链接转化为文件</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 从链接地址读取流</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> urlPath</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> InputStream <span class=\"title\">getIsFromUrl</span><span class=\"params\">(String urlPath)</span> </span>&#123;</span><br><span class=\"line\">        HttpURLConnection conn = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            String urlStr = URLDecoder.decode(urlPath, <span class=\"string\">\"UTF-8\"</span>);</span><br><span class=\"line\">            URL url = <span class=\"keyword\">new</span> URL(urlStr);</span><br><span class=\"line\">            conn = (HttpURLConnection) url.openConnection();</span><br><span class=\"line\">            conn.setRequestMethod(<span class=\"string\">\"GET\"</span>);</span><br><span class=\"line\">            conn.setConnectTimeout(<span class=\"number\">3000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> conn.getInputStream();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"[Method-getIsFromUrl]exception:&#123;&#125;\"</span>, ioe.getMessage());</span><br><span class=\"line\">        &#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (conn != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                conn.disconnect();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将流读成文件</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> ins</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> file</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">inputStreamToFile</span><span class=\"params\">(InputStream ins, File file)</span> </span>&#123;</span><br><span class=\"line\">        OutputStream os = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            os = <span class=\"keyword\">new</span> FileOutputStream(file);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> bytesRead = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> a = <span class=\"number\">8192</span>;</span><br><span class=\"line\">            <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[a];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((bytesRead = ins.read(buffer, <span class=\"number\">0</span>, a)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                os.write(buffer, <span class=\"number\">0</span>, bytesRead);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"[Method-inputStreamToFile]exception:&#123;&#125;\"</span>, ioe.getMessage());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != os) &#123;</span><br><span class=\"line\">                    os.close();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">                logger.error(<span class=\"string\">\"[Method-inputStreamToFile]close-exception:&#123;&#125;\"</span>, ioe.getMessage());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取网络文件，暂存为临时文件</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> url</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> tempPath 临时文件地址</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> UnknownHostException</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> File <span class=\"title\">getFileFromUrl</span><span class=\"params\">(String url, String tempPath)</span> </span></span><br><span class=\"line\"><span class=\"function\">                                      <span class=\"keyword\">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建临时文件</span></span><br><span class=\"line\">        File file = <span class=\"keyword\">new</span> File(tempPath);</span><br><span class=\"line\">        File tmpFile = File.createTempFile(<span class=\"string\">\"temp\"</span>, <span class=\"string\">\".tmp\"</span>, file);</span><br><span class=\"line\">        <span class=\"comment\">// 程序结束后删除（缓存delete命令，jvm停止时执行）</span></span><br><span class=\"line\">        tmpFile.deleteOnExit();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"[getFileFromUrl]create file from url:&#123;&#125;,path:&#123;&#125;\"</span>, </span><br><span class=\"line\">                        url, file.getAbsolutePath());</span><br><span class=\"line\">        InputStream is = getIsFromUrl(url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != is) &#123;</span><br><span class=\"line\">            inputStreamToFile(is, tmpFile);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmpFile;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取视频时长 单位秒</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Long <span class=\"title\">getDuration</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> EncoderException </span>&#123;</span><br><span class=\"line\">        MultimediaInfo m = <span class=\"keyword\">new</span> Encoder().getInfo(file);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m.getDuration() / <span class=\"number\">1000</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码就是获取一个视频地址视频时长的全部内容。逻辑比较简单，先把链接地址读取成文件流，<br>然后用jave的方法获取其时长(单位是毫秒，因为业务需求将其计算转为秒)。</p>"},{"title":"进程和线程","date":"2020-06-25T10:29:41.000Z","_content":"\n### 前言\n\n  面试中有被问到进程和线程的问题，这个平时看得比较少，这里做一个简单的总结。\n<!-- more -->\n\n### 定义\n\n  进程：资源分配的基本单位，由进程控制块(Process Control Block, PCB)描述他的基本信息和运行状态\n  线程：独立调度的基本单位，一个进程可以有多个线程，且这些线程共享进程的资源和数据\n\n  两者区别：\n  1. 进程拥有资源，而线程只能访问所属进程的资源\n  2. 通信方式不同，线程间通信可以通过对进程数据的读写完成，进程的通信需要通过IPC(进程间通信技术)完成\n\n\n  进程的状态：\n  1. 就绪态，等待调度\n  2. 运行态\n  3. 阻塞态，等待资源分配\n\n\n  就绪态和运行态能相互转换，运行态->阻塞态->就绪态属于单向转换。\n\n  线程状态(Java中)：\n  1. 初始：NEW 尚未启动的线程处于这种状态\n  2. 运行：RUNNABLE 在Java虚拟机上执行的线程处于这种状态\n  3. 阻塞：BLOCKED 被阻止等待监视器锁的线程处于这种状态\n  4. 等待：WAITING 即无限期地等待另一个线程来执行某一特定操作的线程处于这种状态\n  5. 超时等待：TIMED_WAITING 正在等待另一个线程来达到一个指定的等待时间执行动作的线程处于这种状态\n  6. 终止：TERMINATED 已退出的线程处于这种状态\n\n\n  一个线程可以在给定时间点只能处于一种状态。 这些状态是虚拟机的状态并没有反映任何操作系统线程状态。\n\n### 进程调度算法\n\n#### 批处理系统\n\n  1. 先来先服务：非抢占式的调度算法，按照请求的顺序进行调度\n  2. 短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度\n  3. 最短剩余时间：短作业优先的抢占式版本，按剩余运行时间的顺序进行调度\n\n#### 交互式系统\n\n  1. 时间片轮转：每个进程分配一个时间片，用完了就会轮转到下一个进程\n  2. 优先级调度：为每一个进程定义一个优先级，按照优先级顺序调度，也可调整进程优先级\n  3. 多级反馈队列：类似于时间片轮转，但是设置多个不同时间长度的队列，按时间长短顺序优先，\n     进程没在高优先级(即时间短的)队列中执行完成会依次进入下一队列获取更长的时间片。这样做的目的是减少切换的次数。\n\n### 进程通信\n\n  1. 管道\n  2. FIFO\n  3. 消息队列\n  4. 信号量\n  5. 共享存储\n  6. 套接字","source":"_posts/2020/06/ProcessAndThread1.md","raw":"---\ntitle: 进程和线程\ndate: 2020-06-25 18:29:41\ntags:\n- 进程\ncategories:\n- 操作系统\n---\n\n### 前言\n\n  面试中有被问到进程和线程的问题，这个平时看得比较少，这里做一个简单的总结。\n<!-- more -->\n\n### 定义\n\n  进程：资源分配的基本单位，由进程控制块(Process Control Block, PCB)描述他的基本信息和运行状态\n  线程：独立调度的基本单位，一个进程可以有多个线程，且这些线程共享进程的资源和数据\n\n  两者区别：\n  1. 进程拥有资源，而线程只能访问所属进程的资源\n  2. 通信方式不同，线程间通信可以通过对进程数据的读写完成，进程的通信需要通过IPC(进程间通信技术)完成\n\n\n  进程的状态：\n  1. 就绪态，等待调度\n  2. 运行态\n  3. 阻塞态，等待资源分配\n\n\n  就绪态和运行态能相互转换，运行态->阻塞态->就绪态属于单向转换。\n\n  线程状态(Java中)：\n  1. 初始：NEW 尚未启动的线程处于这种状态\n  2. 运行：RUNNABLE 在Java虚拟机上执行的线程处于这种状态\n  3. 阻塞：BLOCKED 被阻止等待监视器锁的线程处于这种状态\n  4. 等待：WAITING 即无限期地等待另一个线程来执行某一特定操作的线程处于这种状态\n  5. 超时等待：TIMED_WAITING 正在等待另一个线程来达到一个指定的等待时间执行动作的线程处于这种状态\n  6. 终止：TERMINATED 已退出的线程处于这种状态\n\n\n  一个线程可以在给定时间点只能处于一种状态。 这些状态是虚拟机的状态并没有反映任何操作系统线程状态。\n\n### 进程调度算法\n\n#### 批处理系统\n\n  1. 先来先服务：非抢占式的调度算法，按照请求的顺序进行调度\n  2. 短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度\n  3. 最短剩余时间：短作业优先的抢占式版本，按剩余运行时间的顺序进行调度\n\n#### 交互式系统\n\n  1. 时间片轮转：每个进程分配一个时间片，用完了就会轮转到下一个进程\n  2. 优先级调度：为每一个进程定义一个优先级，按照优先级顺序调度，也可调整进程优先级\n  3. 多级反馈队列：类似于时间片轮转，但是设置多个不同时间长度的队列，按时间长短顺序优先，\n     进程没在高优先级(即时间短的)队列中执行完成会依次进入下一队列获取更长的时间片。这样做的目的是减少切换的次数。\n\n### 进程通信\n\n  1. 管道\n  2. FIFO\n  3. 消息队列\n  4. 信号量\n  5. 共享存储\n  6. 套接字","slug":"ProcessAndThread1","published":1,"updated":"2021-05-15T14:51:33.413Z","_id":"ckdvmudy6000dnwb59kgc27ah","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  面试中有被问到进程和线程的问题，这个平时看得比较少，这里做一个简单的总结。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>  进程：资源分配的基本单位，由进程控制块(Process Control Block, PCB)描述他的基本信息和运行状态<br>  线程：独立调度的基本单位，一个进程可以有多个线程，且这些线程共享进程的资源和数据</p>\n<p>  两者区别：</p>\n<ol>\n<li>进程拥有资源，而线程只能访问所属进程的资源</li>\n<li>通信方式不同，线程间通信可以通过对进程数据的读写完成，进程的通信需要通过IPC(进程间通信技术)完成</li>\n</ol>\n<p>  进程的状态：</p>\n<ol>\n<li>就绪态，等待调度</li>\n<li>运行态</li>\n<li>阻塞态，等待资源分配</li>\n</ol>\n<p>  就绪态和运行态能相互转换，运行态-&gt;阻塞态-&gt;就绪态属于单向转换。</p>\n<p>  线程状态(Java中)：</p>\n<ol>\n<li>初始：NEW 尚未启动的线程处于这种状态</li>\n<li>运行：RUNNABLE 在Java虚拟机上执行的线程处于这种状态</li>\n<li>阻塞：BLOCKED 被阻止等待监视器锁的线程处于这种状态</li>\n<li>等待：WAITING 即无限期地等待另一个线程来执行某一特定操作的线程处于这种状态</li>\n<li>超时等待：TIMED_WAITING 正在等待另一个线程来达到一个指定的等待时间执行动作的线程处于这种状态</li>\n<li>终止：TERMINATED 已退出的线程处于这种状态</li>\n</ol>\n<p>  一个线程可以在给定时间点只能处于一种状态。 这些状态是虚拟机的状态并没有反映任何操作系统线程状态。</p>\n<h3 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h3><h4 id=\"批处理系统\"><a href=\"#批处理系统\" class=\"headerlink\" title=\"批处理系统\"></a>批处理系统</h4><ol>\n<li>先来先服务：非抢占式的调度算法，按照请求的顺序进行调度</li>\n<li>短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li>\n<li>最短剩余时间：短作业优先的抢占式版本，按剩余运行时间的顺序进行调度</li>\n</ol>\n<h4 id=\"交互式系统\"><a href=\"#交互式系统\" class=\"headerlink\" title=\"交互式系统\"></a>交互式系统</h4><ol>\n<li>时间片轮转：每个进程分配一个时间片，用完了就会轮转到下一个进程</li>\n<li>优先级调度：为每一个进程定义一个优先级，按照优先级顺序调度，也可调整进程优先级</li>\n<li>多级反馈队列：类似于时间片轮转，但是设置多个不同时间长度的队列，按时间长短顺序优先，<br>进程没在高优先级(即时间短的)队列中执行完成会依次进入下一队列获取更长的时间片。这样做的目的是减少切换的次数。</li>\n</ol>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><ol>\n<li>管道</li>\n<li>FIFO</li>\n<li>消息队列</li>\n<li>信号量</li>\n<li>共享存储</li>\n<li>套接字</li>\n</ol>\n","site":{"data":{}},"length":834,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  面试中有被问到进程和线程的问题，这个平时看得比较少，这里做一个简单的总结。</p>","more":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>  进程：资源分配的基本单位，由进程控制块(Process Control Block, PCB)描述他的基本信息和运行状态<br>  线程：独立调度的基本单位，一个进程可以有多个线程，且这些线程共享进程的资源和数据</p>\n<p>  两者区别：</p>\n<ol>\n<li>进程拥有资源，而线程只能访问所属进程的资源</li>\n<li>通信方式不同，线程间通信可以通过对进程数据的读写完成，进程的通信需要通过IPC(进程间通信技术)完成</li>\n</ol>\n<p>  进程的状态：</p>\n<ol>\n<li>就绪态，等待调度</li>\n<li>运行态</li>\n<li>阻塞态，等待资源分配</li>\n</ol>\n<p>  就绪态和运行态能相互转换，运行态-&gt;阻塞态-&gt;就绪态属于单向转换。</p>\n<p>  线程状态(Java中)：</p>\n<ol>\n<li>初始：NEW 尚未启动的线程处于这种状态</li>\n<li>运行：RUNNABLE 在Java虚拟机上执行的线程处于这种状态</li>\n<li>阻塞：BLOCKED 被阻止等待监视器锁的线程处于这种状态</li>\n<li>等待：WAITING 即无限期地等待另一个线程来执行某一特定操作的线程处于这种状态</li>\n<li>超时等待：TIMED_WAITING 正在等待另一个线程来达到一个指定的等待时间执行动作的线程处于这种状态</li>\n<li>终止：TERMINATED 已退出的线程处于这种状态</li>\n</ol>\n<p>  一个线程可以在给定时间点只能处于一种状态。 这些状态是虚拟机的状态并没有反映任何操作系统线程状态。</p>\n<h3 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h3><h4 id=\"批处理系统\"><a href=\"#批处理系统\" class=\"headerlink\" title=\"批处理系统\"></a>批处理系统</h4><ol>\n<li>先来先服务：非抢占式的调度算法，按照请求的顺序进行调度</li>\n<li>短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度</li>\n<li>最短剩余时间：短作业优先的抢占式版本，按剩余运行时间的顺序进行调度</li>\n</ol>\n<h4 id=\"交互式系统\"><a href=\"#交互式系统\" class=\"headerlink\" title=\"交互式系统\"></a>交互式系统</h4><ol>\n<li>时间片轮转：每个进程分配一个时间片，用完了就会轮转到下一个进程</li>\n<li>优先级调度：为每一个进程定义一个优先级，按照优先级顺序调度，也可调整进程优先级</li>\n<li>多级反馈队列：类似于时间片轮转，但是设置多个不同时间长度的队列，按时间长短顺序优先，<br>进程没在高优先级(即时间短的)队列中执行完成会依次进入下一队列获取更长的时间片。这样做的目的是减少切换的次数。</li>\n</ol>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><ol>\n<li>管道</li>\n<li>FIFO</li>\n<li>消息队列</li>\n<li>信号量</li>\n<li>共享存储</li>\n<li>套接字</li>\n</ol>"},{"title":"HashMap(jdk1.8)","date":"2020-05-30T12:04:27.000Z","_content":"\n### HashMap简介\n\n      HashMap是java.util包下的实现Map接口的非线程安全集合，其基于数组+链表|红黑树的结构，以键值对的\n    形式存储数据\n    特点：\n    1. 基于key-value的数据结构可以通过key直接定位value值，查询较快，key值可为null\n    2. 使用hash值确定数组下标，所以遍历顺序不是输入顺序\n    3. 扩容操作涉及重新计算hash值，对性能影响较大，需尽量避免\n<!-- more -->\n类定义如下\n\n{% codeblock lang:java %}\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n{% endcodeblock %}\n\n### 源码部分解析\n\n#### 属性信息\n\n{% codeblock lang:java %}\n// ------------------设置的默认值-----------------------\n// 数组的默认容量  (需为2的n次方，涉及扩容时的计算)\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n\n// 数组的最大容量 2的30次方\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n// 默认的加载因子\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n// 树化的阈值\nstatic final int TREEIFY_THRESHOLD = 8;\n\n// 取消树化的阈值\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n// 树化时的数组容量最小值 \n// 当容量小于该值时应考虑增加数组容量而不是将链表变化为树\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n\n// -------------------基本属性---------------------------\n// 数组\ntransient Node<K,V>[] table;\n\n// 键值对集合\ntransient Set<Map.Entry<K,V>> entrySet;\n\n// 集合中键值对的数量\ntransient int size;\n\n// 结构变化的计数\ntransient int modCount;\n\n// 键值对数量的阈值  计算方式 capacity * loadFactor\nint threshold;\n\n// 加载因子\nfinal float loadFactor;\n{% endcodeblock %}\n\n#### 构造方法\n\n{% codeblock lang:java %}\n// 初始化数组容量和加载因子的构造方法\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    // 键值对数量的阈值 为数组容量的两倍  tableSizeFor(int cap) 返回cap的两倍\n    this.threshold = tableSizeFor(initialCapacity);\n}\n\n// 初始化数组容量 \npublic HashMap(int initialCapacity) {\n    // 使用默认的加载因子初始化\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\n// 使用默认值初始化一个空的hashmap\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n\n// 用指定的map集合初始化\npublic HashMap(Map<? extends K, ? extends V> m) {\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n    putMapEntries(m, false);\n}\n{% endcodeblock %}\n\n#### 数组下标的计算\n\n{% codeblock lang:java %}\n// 计算hash值\nstatic final int hash(Object key) {\n    int h;\n    // key为null就取0，否则用 h 异或 h 无符号右移16位\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n// 计算数组下标 n表示数组长度 & 按位与\n(n - 1) & hash\n{% endcodeblock %}\n\n关于以上计算的具体分析，可以参考美团技术团队的文章<Java 8系列之重新认识HashMap>\n\n#### 基本操作\n\n##### get方法\n\n{% codeblock lang:java %}\n// 对外暴露的方法\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\n// 内部实现逻辑\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    // 数组下标的计算 (n-1) & hash\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 定位数组位置后，先判断头节点是否匹配\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            // 判断如果是树结构，走树的遍历\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 链表的遍历\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n// ---------------------------内部类 TreeNode 的方法-----------------------------------\n// 获取符合条件的树节点\nfinal TreeNode<K,V> getTreeNode(int h, Object k) {\n    // 从根节点开始找\n    return ((parent != null) ? root() : this).find(h, k, null);\n}\n\n// 树节点遍历比对\nfinal TreeNode<K,V> find(int h, Object k, Class<?> kc) {\n    TreeNode<K,V> p = this;\n    do {\n        int ph, dir; K pk;\n        TreeNode<K,V> pl = p.left, pr = p.right, q;\n        // 查找节点hash值小于当前值，转向左子节点\n        if ((ph = p.hash) > h)\n            p = pl;\n        // 反之，转向右子节点\n        else if (ph < h)\n            p = pr;\n        // 直接匹配，返回当前节点\n        else if ((pk = p.key) == k || (k != null && k.equals(pk)))\n            return p;\n        // 排除本节点且无法定位下一步的情况，看左右子节点是否有为空的\n        else if (pl == null)\n            p = pr;\n        else if (pr == null)\n            p = pl;\n        // 左右节点都不为空的前提下，比较key值来确定下一步去左边还是右边\n        else if ((kc != null ||\n                  (kc = comparableClassFor(k)) != null) &&\n                 (dir = compareComparables(kc, k, pk)) != 0)\n            p = (dir < 0) ? pl : pr;\n        // 前面的判断都没得出结果\n        // 递归遍历右子树\n        else if ((q = pr.find(h, k, kc)) != null)\n            return q;\n        // 右子树没找到结果，就找左子树\n        else\n            p = pl;\n    } while (p != null);\n    return null;\n}\n{% endcodeblock %}\n\n##### put方法\n\n{% codeblock lang:java %}\n// 对外暴露的方法\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n// 具体实现逻辑\n// @param onlyIfAbsent  如果为true，不更改现有值\n// @param evict 如果为false table处于创建模式\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    if ((tab = table) == null || (n = tab.length) == 0)\n        // 初始化table\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        // 计算下标 (n-1) & hash, 若下标对应的值为null，则创建一个Node对象赋值\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        // 首节点 p 不为null\n        Node<K,V> e; K k;\n        // 比较hash值和key值\n        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        else if (p instanceof TreeNode)\n            // 如果是红黑树结构，走树的逻辑\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 链表的遍历赋值\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        // 判断链表长度，是否需要树化\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        // key存在的处理\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 扩容的判断\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n\n// 树化的逻辑\nfinal void treeifyBin(Node<K,V>[] tab, int hash) {\n    int n, index; Node<K,V> e;\n    // 如果数组为空或长度太小，不会选择树化，而是扩容\n    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n        resize();\n    else if ((e = tab[index = (n - 1) & hash]) != null) {\n        TreeNode<K,V> hd = null, tl = null;\n        do {\n            TreeNode<K,V> p = replacementTreeNode(e, null);// 替换节点对象\n            if (tl == null)\n                hd = p;\n            else {\n                p.prev = tl;\n                tl.next = p;\n            }\n            tl = p;\n        } while ((e = e.next) != null);\n        if ((tab[index] = hd) != null)\n            // 调用TreeNode的方法完成树化\n            hd.treeify(tab);\n    }\n}\n\n// 扩容方法\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    // 原数组不为空的前提\n    if (oldCap > 0) {\n        // 阈值判断\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 不超出阈值的前提下，扩容为2倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    if (newThr == 0) {\n        // 计算新的键值对阈值\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    // table扩容 重新计算数组下标\n    if (oldTab != null) {\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    // 树结构的处理\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n\n// -----------------------------内部类 TreeNode 的方法-----------------------------------------\n// 树结构的put方法\nfinal TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab, int h, K k, V v) {\n    Class<?> kc = null;\n    boolean searched = false; // 是否遍历过\n    TreeNode<K,V> root = (parent != null) ? root() : this;\n    for (TreeNode<K,V> p = root;;) {\n        int dir, ph; K pk;\n        // 查找key是否在树中存在\n        if ((ph = p.hash) > h)\n            dir = -1;\n        else if (ph < h)\n            dir = 1;\n        else if ((pk = p.key) == k || (k != null && k.equals(pk)))\n            return p;\n        else if ((kc == null && (kc = comparableClassFor(k)) == null) ||\n                 (dir = compareComparables(kc, k, pk)) == 0) {\n            if (!searched) {\n                TreeNode<K,V> q, ch;\n                searched = true; // 避免后续循环再走到此逻辑中\n                // 递归find方法，分别遍历左右子树\n                if (((ch = p.left) != null && (q = ch.find(h, k, kc)) != null) ||\n                    ((ch = p.right) != null && (q = ch.find(h, k, kc)) != null))\n                    return q;\n            }\n            dir = tieBreakOrder(k, pk);\n        }\n        TreeNode<K,V> xp = p;\n        // 新建树节点\n        if ((p = (dir <= 0) ? p.left : p.right) == null) {\n            Node<K,V> xpn = xp.next;\n            TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);\n            if (dir <= 0)\n                xp.left = x;\n            else\n                xp.right = x;\n            xp.next = x;\n            x.parent = x.prev = xp;\n            if (xpn != null)\n                ((TreeNode<K,V>)xpn).prev = x;\n            moveRootToFront(tab, balanceInsertion(root, x));\n            return null;\n        }\n    }\n}\n\n// 树化具体实现\nfinal void treeify(Node<K,V>[] tab) {\n    TreeNode<K,V> root = null;\n    for (TreeNode<K,V> x = this, next; x != null; x = next) {\n        next = (TreeNode<K,V>)x.next;\n        x.left = x.right = null;\n        // 确定根节点 红黑树根节点为黑色\n        if (root == null) {\n            x.parent = null;\n            x.red = false;\n            root = x;\n        }\n        // 左右子节点的判定，与get，put中的判断类似\n        else {\n            K k = x.key;\n            int h = x.hash;\n            Class<?> kc = null;\n            for (TreeNode<K,V> p = root;;) {\n                int dir, ph;\n                K pk = p.key;\n                if ((ph = p.hash) > h)\n                    dir = -1;\n                else if (ph < h)\n                    dir = 1;\n                else if ((kc == null &&\n                          (kc = comparableClassFor(k)) == null) ||\n                         (dir = compareComparables(kc, k, pk)) == 0)\n                    dir = tieBreakOrder(k, pk);\n                TreeNode<K,V> xp = p;\n                if ((p = (dir <= 0) ? p.left : p.right) == null) {\n                    x.parent = xp;\n                    if (dir <= 0)\n                        xp.left = x;\n                    else\n                        xp.right = x;\n                    // 平衡插入 暂时没完全看懂 这里就贴出来\n                    root = balanceInsertion(root, x);\n                    break;\n                }\n            }\n        }\n    }\n    // 保证树的头节点在table中\n    moveRootToFront(tab, root);\n}\n{% endcodeblock %}\n\n### 小结\n\n       HashMap相对ArrayList复杂许多，涉及红黑树的操作逻辑都很值得琢磨。因为篇幅问题，只从源码中摘出\n    我认为较常用的方法(get，put)和一些重要的逻辑。分析源码逻辑确实受益良多，一些想法中直接简单的逻辑\n    ，为了保证代码的健壮性，实现起来往往就会复杂许多。例如涉及红黑树的一些处理，做了很多判断，遍历，\n    递归之类的，一开始感觉有些重复了，思考良久之后才理解为什么。这里照旧小结一下：\n    1. HashMap中涉及了较多的位运算，异或，按位与之类的。因为实际工作中较少使用，导致对这些位运算都比\n    较陌生了，需要对位运算复习一下\n    2. 源码中许多方法都是使用了局部变量去处理，比如红黑树的判断，都是在方法中定义变量指向树的根节点\n    或左右子节点再去处理。我理解的原因第一是局部变量能在方法结束后被回收，第二应该是避免直接操作导致\n    原对象的错误更改。(虽然有时候这样的处理增加了代码阅读的难度···)\n    3. 红黑树的相关操作(TreeNode的一些方法)，虽然有些方法没完全看懂，但是可以作为树结构操作的一个参考\n","source":"_posts/2020/05/hashMap1.md","raw":"---\ntitle: HashMap(jdk1.8)\ndate: 2020-05-30 20:04:27\ntags:\n- Java容器\ncategories:\n- Java\n- Map\n---\n\n### HashMap简介\n\n      HashMap是java.util包下的实现Map接口的非线程安全集合，其基于数组+链表|红黑树的结构，以键值对的\n    形式存储数据\n    特点：\n    1. 基于key-value的数据结构可以通过key直接定位value值，查询较快，key值可为null\n    2. 使用hash值确定数组下标，所以遍历顺序不是输入顺序\n    3. 扩容操作涉及重新计算hash值，对性能影响较大，需尽量避免\n<!-- more -->\n类定义如下\n\n{% codeblock lang:java %}\npublic class HashMap<K,V> extends AbstractMap<K,V>\n    implements Map<K,V>, Cloneable, Serializable\n{% endcodeblock %}\n\n### 源码部分解析\n\n#### 属性信息\n\n{% codeblock lang:java %}\n// ------------------设置的默认值-----------------------\n// 数组的默认容量  (需为2的n次方，涉及扩容时的计算)\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4;\n\n// 数组的最大容量 2的30次方\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n// 默认的加载因子\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n// 树化的阈值\nstatic final int TREEIFY_THRESHOLD = 8;\n\n// 取消树化的阈值\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n// 树化时的数组容量最小值 \n// 当容量小于该值时应考虑增加数组容量而不是将链表变化为树\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n\n// -------------------基本属性---------------------------\n// 数组\ntransient Node<K,V>[] table;\n\n// 键值对集合\ntransient Set<Map.Entry<K,V>> entrySet;\n\n// 集合中键值对的数量\ntransient int size;\n\n// 结构变化的计数\ntransient int modCount;\n\n// 键值对数量的阈值  计算方式 capacity * loadFactor\nint threshold;\n\n// 加载因子\nfinal float loadFactor;\n{% endcodeblock %}\n\n#### 构造方法\n\n{% codeblock lang:java %}\n// 初始化数组容量和加载因子的构造方法\npublic HashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n    this.loadFactor = loadFactor;\n    // 键值对数量的阈值 为数组容量的两倍  tableSizeFor(int cap) 返回cap的两倍\n    this.threshold = tableSizeFor(initialCapacity);\n}\n\n// 初始化数组容量 \npublic HashMap(int initialCapacity) {\n    // 使用默认的加载因子初始化\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\n// 使用默认值初始化一个空的hashmap\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n\n// 用指定的map集合初始化\npublic HashMap(Map<? extends K, ? extends V> m) {\n    this.loadFactor = DEFAULT_LOAD_FACTOR;\n    putMapEntries(m, false);\n}\n{% endcodeblock %}\n\n#### 数组下标的计算\n\n{% codeblock lang:java %}\n// 计算hash值\nstatic final int hash(Object key) {\n    int h;\n    // key为null就取0，否则用 h 异或 h 无符号右移16位\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n\n// 计算数组下标 n表示数组长度 & 按位与\n(n - 1) & hash\n{% endcodeblock %}\n\n关于以上计算的具体分析，可以参考美团技术团队的文章<Java 8系列之重新认识HashMap>\n\n#### 基本操作\n\n##### get方法\n\n{% codeblock lang:java %}\n// 对外暴露的方法\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\n// 内部实现逻辑\nfinal Node<K,V> getNode(int hash, Object key) {\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    // 数组下标的计算 (n-1) & hash\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (first = tab[(n - 1) & hash]) != null) {\n        // 定位数组位置后，先判断头节点是否匹配\n        if (first.hash == hash && // always check first node\n            ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        if ((e = first.next) != null) {\n            // 判断如果是树结构，走树的遍历\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            // 链表的遍历\n            do {\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n// ---------------------------内部类 TreeNode 的方法-----------------------------------\n// 获取符合条件的树节点\nfinal TreeNode<K,V> getTreeNode(int h, Object k) {\n    // 从根节点开始找\n    return ((parent != null) ? root() : this).find(h, k, null);\n}\n\n// 树节点遍历比对\nfinal TreeNode<K,V> find(int h, Object k, Class<?> kc) {\n    TreeNode<K,V> p = this;\n    do {\n        int ph, dir; K pk;\n        TreeNode<K,V> pl = p.left, pr = p.right, q;\n        // 查找节点hash值小于当前值，转向左子节点\n        if ((ph = p.hash) > h)\n            p = pl;\n        // 反之，转向右子节点\n        else if (ph < h)\n            p = pr;\n        // 直接匹配，返回当前节点\n        else if ((pk = p.key) == k || (k != null && k.equals(pk)))\n            return p;\n        // 排除本节点且无法定位下一步的情况，看左右子节点是否有为空的\n        else if (pl == null)\n            p = pr;\n        else if (pr == null)\n            p = pl;\n        // 左右节点都不为空的前提下，比较key值来确定下一步去左边还是右边\n        else if ((kc != null ||\n                  (kc = comparableClassFor(k)) != null) &&\n                 (dir = compareComparables(kc, k, pk)) != 0)\n            p = (dir < 0) ? pl : pr;\n        // 前面的判断都没得出结果\n        // 递归遍历右子树\n        else if ((q = pr.find(h, k, kc)) != null)\n            return q;\n        // 右子树没找到结果，就找左子树\n        else\n            p = pl;\n    } while (p != null);\n    return null;\n}\n{% endcodeblock %}\n\n##### put方法\n\n{% codeblock lang:java %}\n// 对外暴露的方法\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\n// 具体实现逻辑\n// @param onlyIfAbsent  如果为true，不更改现有值\n// @param evict 如果为false table处于创建模式\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    if ((tab = table) == null || (n = tab.length) == 0)\n        // 初始化table\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        // 计算下标 (n-1) & hash, 若下标对应的值为null，则创建一个Node对象赋值\n        tab[i] = newNode(hash, key, value, null);\n    else {\n        // 首节点 p 不为null\n        Node<K,V> e; K k;\n        // 比较hash值和key值\n        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n            e = p;\n        else if (p instanceof TreeNode)\n            // 如果是红黑树结构，走树的逻辑\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            // 链表的遍历赋值\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    p.next = newNode(hash, key, value, null);\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        // 判断链表长度，是否需要树化\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        // key存在的处理\n        if (e != null) { // existing mapping for key\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                e.value = value;\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    // 扩容的判断\n    if (++size > threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n}\n\n// 树化的逻辑\nfinal void treeifyBin(Node<K,V>[] tab, int hash) {\n    int n, index; Node<K,V> e;\n    // 如果数组为空或长度太小，不会选择树化，而是扩容\n    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n        resize();\n    else if ((e = tab[index = (n - 1) & hash]) != null) {\n        TreeNode<K,V> hd = null, tl = null;\n        do {\n            TreeNode<K,V> p = replacementTreeNode(e, null);// 替换节点对象\n            if (tl == null)\n                hd = p;\n            else {\n                p.prev = tl;\n                tl.next = p;\n            }\n            tl = p;\n        } while ((e = e.next) != null);\n        if ((tab[index] = hd) != null)\n            // 调用TreeNode的方法完成树化\n            hd.treeify(tab);\n    }\n}\n\n// 扩容方法\nfinal Node<K,V>[] resize() {\n    Node<K,V>[] oldTab = table;\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    int oldThr = threshold;\n    int newCap, newThr = 0;\n    // 原数组不为空的前提\n    if (oldCap > 0) {\n        // 阈值判断\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        // 不超出阈值的前提下，扩容为2倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    if (newThr == 0) {\n        // 计算新的键值对阈值\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    table = newTab;\n    // table扩容 重新计算数组下标\n    if (oldTab != null) {\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    // 树结构的处理\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n\n// -----------------------------内部类 TreeNode 的方法-----------------------------------------\n// 树结构的put方法\nfinal TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab, int h, K k, V v) {\n    Class<?> kc = null;\n    boolean searched = false; // 是否遍历过\n    TreeNode<K,V> root = (parent != null) ? root() : this;\n    for (TreeNode<K,V> p = root;;) {\n        int dir, ph; K pk;\n        // 查找key是否在树中存在\n        if ((ph = p.hash) > h)\n            dir = -1;\n        else if (ph < h)\n            dir = 1;\n        else if ((pk = p.key) == k || (k != null && k.equals(pk)))\n            return p;\n        else if ((kc == null && (kc = comparableClassFor(k)) == null) ||\n                 (dir = compareComparables(kc, k, pk)) == 0) {\n            if (!searched) {\n                TreeNode<K,V> q, ch;\n                searched = true; // 避免后续循环再走到此逻辑中\n                // 递归find方法，分别遍历左右子树\n                if (((ch = p.left) != null && (q = ch.find(h, k, kc)) != null) ||\n                    ((ch = p.right) != null && (q = ch.find(h, k, kc)) != null))\n                    return q;\n            }\n            dir = tieBreakOrder(k, pk);\n        }\n        TreeNode<K,V> xp = p;\n        // 新建树节点\n        if ((p = (dir <= 0) ? p.left : p.right) == null) {\n            Node<K,V> xpn = xp.next;\n            TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);\n            if (dir <= 0)\n                xp.left = x;\n            else\n                xp.right = x;\n            xp.next = x;\n            x.parent = x.prev = xp;\n            if (xpn != null)\n                ((TreeNode<K,V>)xpn).prev = x;\n            moveRootToFront(tab, balanceInsertion(root, x));\n            return null;\n        }\n    }\n}\n\n// 树化具体实现\nfinal void treeify(Node<K,V>[] tab) {\n    TreeNode<K,V> root = null;\n    for (TreeNode<K,V> x = this, next; x != null; x = next) {\n        next = (TreeNode<K,V>)x.next;\n        x.left = x.right = null;\n        // 确定根节点 红黑树根节点为黑色\n        if (root == null) {\n            x.parent = null;\n            x.red = false;\n            root = x;\n        }\n        // 左右子节点的判定，与get，put中的判断类似\n        else {\n            K k = x.key;\n            int h = x.hash;\n            Class<?> kc = null;\n            for (TreeNode<K,V> p = root;;) {\n                int dir, ph;\n                K pk = p.key;\n                if ((ph = p.hash) > h)\n                    dir = -1;\n                else if (ph < h)\n                    dir = 1;\n                else if ((kc == null &&\n                          (kc = comparableClassFor(k)) == null) ||\n                         (dir = compareComparables(kc, k, pk)) == 0)\n                    dir = tieBreakOrder(k, pk);\n                TreeNode<K,V> xp = p;\n                if ((p = (dir <= 0) ? p.left : p.right) == null) {\n                    x.parent = xp;\n                    if (dir <= 0)\n                        xp.left = x;\n                    else\n                        xp.right = x;\n                    // 平衡插入 暂时没完全看懂 这里就贴出来\n                    root = balanceInsertion(root, x);\n                    break;\n                }\n            }\n        }\n    }\n    // 保证树的头节点在table中\n    moveRootToFront(tab, root);\n}\n{% endcodeblock %}\n\n### 小结\n\n       HashMap相对ArrayList复杂许多，涉及红黑树的操作逻辑都很值得琢磨。因为篇幅问题，只从源码中摘出\n    我认为较常用的方法(get，put)和一些重要的逻辑。分析源码逻辑确实受益良多，一些想法中直接简单的逻辑\n    ，为了保证代码的健壮性，实现起来往往就会复杂许多。例如涉及红黑树的一些处理，做了很多判断，遍历，\n    递归之类的，一开始感觉有些重复了，思考良久之后才理解为什么。这里照旧小结一下：\n    1. HashMap中涉及了较多的位运算，异或，按位与之类的。因为实际工作中较少使用，导致对这些位运算都比\n    较陌生了，需要对位运算复习一下\n    2. 源码中许多方法都是使用了局部变量去处理，比如红黑树的判断，都是在方法中定义变量指向树的根节点\n    或左右子节点再去处理。我理解的原因第一是局部变量能在方法结束后被回收，第二应该是避免直接操作导致\n    原对象的错误更改。(虽然有时候这样的处理增加了代码阅读的难度···)\n    3. 红黑树的相关操作(TreeNode的一些方法)，虽然有些方法没完全看懂，但是可以作为树结构操作的一个参考\n","slug":"hashMap1","published":1,"updated":"2020-08-15T12:34:04.996Z","_id":"ckdvmudy7000enwb5fz928sfs","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"HashMap简介\"><a href=\"#HashMap简介\" class=\"headerlink\" title=\"HashMap简介\"></a>HashMap简介</h3><pre><code>  HashMap是java.util包下的实现Map接口的非线程安全集合，其基于数组+链表|红黑树的结构，以键值对的\n形式存储数据\n特点：\n1. 基于key-value的数据结构可以通过key直接定位value值，查询较快，key值可为null\n2. 使用hash值确定数组下标，所以遍历顺序不是输入顺序\n3. 扩容操作涉及重新计算hash值，对性能影响较大，需尽量避免</code></pre><a id=\"more\"></a>\n<p>类定义如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"源码部分解析\"><a href=\"#源码部分解析\" class=\"headerlink\" title=\"源码部分解析\"></a>源码部分解析</h3><h4 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ------------------设置的默认值-----------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 数组的默认容量  (需为2的n次方，涉及扩容时的计算)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组的最大容量 2的30次方</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认的加载因子</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化的阈值</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消树化的阈值</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化时的数组容量最小值 </span></span><br><span class=\"line\"><span class=\"comment\">// 当容量小于该值时应考虑增加数组容量而不是将链表变化为树</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------------基本属性---------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 键值对集合</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 集合中键值对的数量</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构变化的计数</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 键值对数量的阈值  计算方式 capacity * loadFactor</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载因子</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化数组容量和加载因子的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"comment\">// 键值对数量的阈值 为数组容量的两倍  tableSizeFor(int cap) 返回cap的两倍</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化数组容量 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用默认的加载因子初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用默认值初始化一个空的hashmap</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all other fields defaulted</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用指定的map集合初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">    putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组下标的计算\"><a href=\"#数组下标的计算\" class=\"headerlink\" title=\"数组下标的计算\"></a>数组下标的计算</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算hash值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// key为null就取0，否则用 h 异或 h 无符号右移16位</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算数组下标 n表示数组长度 &amp; 按位与</span></span><br><span class=\"line\">(n - <span class=\"number\">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>\n\n<p>关于以上计算的具体分析，可以参考美团技术团队的文章&lt;Java 8系列之重新认识HashMap&gt;</p>\n<h4 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h4><h5 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对外暴露的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 内部实现逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"comment\">// 数组下标的计算 (n-1) &amp; hash</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定位数组位置后，先判断头节点是否匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断如果是树结构，走树的遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 链表的遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ---------------------------内部类 TreeNode 的方法-----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 获取符合条件的树节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">getTreeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从根节点开始找</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>).find(h, k, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树节点遍历比对</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; p = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ph, dir; K pk;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class=\"line\">        <span class=\"comment\">// 查找节点hash值小于当前值，转向左子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">            p = pl;</span><br><span class=\"line\">        <span class=\"comment\">// 反之，转向右子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">            p = pr;</span><br><span class=\"line\">        <span class=\"comment\">// 直接匹配，返回当前节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        <span class=\"comment\">// 排除本节点且无法定位下一步的情况，看左右子节点是否有为空的</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            p = pr;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pr == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            p = pl;</span><br><span class=\"line\">        <span class=\"comment\">// 左右节点都不为空的前提下，比较key值来确定下一步去左边还是右边</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc != <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">                  (kc = comparableClassFor(k)) != <span class=\"keyword\">null</span>) &amp;&amp;</span><br><span class=\"line\">                 (dir = compareComparables(kc, k, pk)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            p = (dir &lt; <span class=\"number\">0</span>) ? pl : pr;</span><br><span class=\"line\">        <span class=\"comment\">// 前面的判断都没得出结果</span></span><br><span class=\"line\">        <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((q = pr.find(h, k, kc)) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> q;</span><br><span class=\"line\">        <span class=\"comment\">// 右子树没找到结果，就找左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            p = pl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对外暴露的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体实现逻辑</span></span><br><span class=\"line\"><span class=\"comment\">// @param onlyIfAbsent  如果为true，不更改现有值</span></span><br><span class=\"line\"><span class=\"comment\">// @param evict 如果为false table处于创建模式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent, <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 初始化table</span></span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 计算下标 (n-1) &amp; hash, 若下标对应的值为null，则创建一个Node对象赋值</span></span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 首节点 p 不为null</span></span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 比较hash值和key值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 如果是红黑树结构，走树的逻辑</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 链表的遍历赋值</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        <span class=\"comment\">// 判断链表长度，是否需要树化</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// key存在的处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容的判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化的逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"comment\">// 如果数组为空或长度太小，不会选择树化，而是扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);<span class=\"comment\">// 替换节点对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hd = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p.prev = tl;</span><br><span class=\"line\">                tl.next = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tl = p;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 调用TreeNode的方法完成树化</span></span><br><span class=\"line\">            hd.treeify(tab);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩容方法</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 原数组不为空的前提</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 阈值判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不超出阈值的前提下，扩容为2倍</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算新的键值对阈值</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"comment\">// table扩容 重新计算数组下标</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    <span class=\"comment\">// 树结构的处理</span></span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------内部类 TreeNode 的方法-----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 树结构的put方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">putTreeVal</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> searched = <span class=\"keyword\">false</span>; <span class=\"comment\">// 是否遍历过</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; root = (parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dir, ph; K pk;</span><br><span class=\"line\">        <span class=\"comment\">// 查找key是否在树中存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">            dir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">            dir = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">                 (dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!searched) &#123;</span><br><span class=\"line\">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class=\"line\">                searched = <span class=\"keyword\">true</span>; <span class=\"comment\">// 避免后续循环再走到此逻辑中</span></span><br><span class=\"line\">                <span class=\"comment\">// 递归find方法，分别遍历左右子树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (((ch = p.left) != <span class=\"keyword\">null</span> &amp;&amp; (q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">                    ((ch = p.right) != <span class=\"keyword\">null</span> &amp;&amp; (q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> q;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dir = tieBreakOrder(k, pk);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class=\"line\">        <span class=\"comment\">// 新建树节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class=\"line\">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                xp.left = x;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                xp.right = x;</span><br><span class=\"line\">            xp.next = x;</span><br><span class=\"line\">            x.parent = x.prev = xp;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (xpn != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class=\"line\">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化具体实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeify</span><span class=\"params\">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; x = <span class=\"keyword\">this</span>, next; x != <span class=\"keyword\">null</span>; x = next) &#123;</span><br><span class=\"line\">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class=\"line\">        x.left = x.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 确定根节点 红黑树根节点为黑色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            x.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            x.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            root = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 左右子节点的判定，与get，put中的判断类似</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            K k = x.key;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = x.hash;</span><br><span class=\"line\">            Class&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dir, ph;</span><br><span class=\"line\">                K pk = p.key;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">                    dir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">                    dir = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                          (kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">                         (dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    dir = tieBreakOrder(k, pk);</span><br><span class=\"line\">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    x.parent = xp;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        xp.left = x;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        xp.right = x;</span><br><span class=\"line\">                    <span class=\"comment\">// 平衡插入 暂时没完全看懂 这里就贴出来</span></span><br><span class=\"line\">                    root = balanceInsertion(root, x);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 保证树的头节点在table中</span></span><br><span class=\"line\">    moveRootToFront(tab, root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>   HashMap相对ArrayList复杂许多，涉及红黑树的操作逻辑都很值得琢磨。因为篇幅问题，只从源码中摘出\n我认为较常用的方法(get，put)和一些重要的逻辑。分析源码逻辑确实受益良多，一些想法中直接简单的逻辑\n，为了保证代码的健壮性，实现起来往往就会复杂许多。例如涉及红黑树的一些处理，做了很多判断，遍历，\n递归之类的，一开始感觉有些重复了，思考良久之后才理解为什么。这里照旧小结一下：\n1. HashMap中涉及了较多的位运算，异或，按位与之类的。因为实际工作中较少使用，导致对这些位运算都比\n较陌生了，需要对位运算复习一下\n2. 源码中许多方法都是使用了局部变量去处理，比如红黑树的判断，都是在方法中定义变量指向树的根节点\n或左右子节点再去处理。我理解的原因第一是局部变量能在方法结束后被回收，第二应该是避免直接操作导致\n原对象的错误更改。(虽然有时候这样的处理增加了代码阅读的难度···)\n3. 红黑树的相关操作(TreeNode的一些方法)，虽然有些方法没完全看懂，但是可以作为树结构操作的一个参考</code></pre>","site":{"data":{}},"length":723,"excerpt":"<h3 id=\"HashMap简介\"><a href=\"#HashMap简介\" class=\"headerlink\" title=\"HashMap简介\"></a>HashMap简介</h3><pre><code>  HashMap是java.util包下的实现Map接口的非线程安全集合，其基于数组+链表|红黑树的结构，以键值对的\n形式存储数据\n特点：\n1. 基于key-value的数据结构可以通过key直接定位value值，查询较快，key值可为null\n2. 使用hash值确定数组下标，所以遍历顺序不是输入顺序\n3. 扩容操作涉及重新计算hash值，对性能影响较大，需尽量避免</code></pre>","more":"<p>类定义如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">Cloneable</span>, <span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"源码部分解析\"><a href=\"#源码部分解析\" class=\"headerlink\" title=\"源码部分解析\"></a>源码部分解析</h3><h4 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ------------------设置的默认值-----------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 数组的默认容量  (需为2的n次方，涉及扩容时的计算)</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组的最大容量 2的30次方</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认的加载因子</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化的阈值</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TREEIFY_THRESHOLD = <span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消树化的阈值</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> UNTREEIFY_THRESHOLD = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化时的数组容量最小值 </span></span><br><span class=\"line\"><span class=\"comment\">// 当容量小于该值时应考虑增加数组容量而不是将链表变化为树</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MIN_TREEIFY_CAPACITY = <span class=\"number\">64</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -------------------基本属性---------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 键值对集合</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 集合中键值对的数量</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构变化的计数</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 键值对数量的阈值  计算方式 capacity * loadFactor</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载因子</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化数组容量和加载因子的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal initial capacity: \"</span> +</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal load factor: \"</span> +</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    <span class=\"comment\">// 键值对数量的阈值 为数组容量的两倍  tableSizeFor(int cap) 返回cap的两倍</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化数组容量 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用默认的加载因子初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用默认值初始化一个空的hashmap</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class=\"comment\">// all other fields defaulted</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用指定的map集合初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class=\"line\">    putMapEntries(m, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组下标的计算\"><a href=\"#数组下标的计算\" class=\"headerlink\" title=\"数组下标的计算\"></a>数组下标的计算</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算hash值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"comment\">// key为null就取0，否则用 h 异或 h 无符号右移16位</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算数组下标 n表示数组长度 &amp; 按位与</span></span><br><span class=\"line\">(n - <span class=\"number\">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>\n\n<p>关于以上计算的具体分析，可以参考美团技术团队的文章&lt;Java 8系列之重新认识HashMap&gt;</p>\n<h4 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h4><h5 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对外暴露的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (e = getNode(hash(key), key)) == <span class=\"keyword\">null</span> ? <span class=\"keyword\">null</span> : e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 内部实现逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Node&lt;K,V&gt; <span class=\"title\">getNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class=\"keyword\">int</span> n; K k;</span><br><span class=\"line\">    <span class=\"comment\">// 数组下标的计算 (n-1) &amp; hash</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) != <span class=\"keyword\">null</span> &amp;&amp; (n = tab.length) &gt; <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">        (first = tab[(n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定位数组位置后，先判断头节点是否匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hash == hash &amp;&amp; <span class=\"comment\">// always check first node</span></span><br><span class=\"line\">            ((k = first.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((e = first.next) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断如果是树结构，走树的遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (first <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class=\"line\">            <span class=\"comment\">// 链表的遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ---------------------------内部类 TreeNode 的方法-----------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 获取符合条件的树节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">getTreeNode</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 从根节点开始找</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>).find(h, k, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树节点遍历比对</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; p = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ph, dir; K pk;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class=\"line\">        <span class=\"comment\">// 查找节点hash值小于当前值，转向左子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">            p = pl;</span><br><span class=\"line\">        <span class=\"comment\">// 反之，转向右子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">            p = pr;</span><br><span class=\"line\">        <span class=\"comment\">// 直接匹配，返回当前节点</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        <span class=\"comment\">// 排除本节点且无法定位下一步的情况，看左右子节点是否有为空的</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            p = pr;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pr == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            p = pl;</span><br><span class=\"line\">        <span class=\"comment\">// 左右节点都不为空的前提下，比较key值来确定下一步去左边还是右边</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc != <span class=\"keyword\">null</span> ||</span><br><span class=\"line\">                  (kc = comparableClassFor(k)) != <span class=\"keyword\">null</span>) &amp;&amp;</span><br><span class=\"line\">                 (dir = compareComparables(kc, k, pk)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            p = (dir &lt; <span class=\"number\">0</span>) ? pl : pr;</span><br><span class=\"line\">        <span class=\"comment\">// 前面的判断都没得出结果</span></span><br><span class=\"line\">        <span class=\"comment\">// 递归遍历右子树</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((q = pr.find(h, k, kc)) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> q;</span><br><span class=\"line\">        <span class=\"comment\">// 右子树没找到结果，就找左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            p = pl;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (p != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"put方法\"><a href=\"#put方法\" class=\"headerlink\" title=\"put方法\"></a>put方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对外暴露的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体实现逻辑</span></span><br><span class=\"line\"><span class=\"comment\">// @param onlyIfAbsent  如果为true，不更改现有值</span></span><br><span class=\"line\"><span class=\"comment\">// @param evict 如果为false table处于创建模式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbsent, <span class=\"keyword\">boolean</span> evict)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> n, i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 初始化table</span></span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 计算下标 (n-1) &amp; hash, 若下标对应的值为null，则创建一个Node对象赋值</span></span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 首节点 p 不为null</span></span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 比较hash值和key值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            <span class=\"comment\">// 如果是红黑树结构，走树的逻辑</span></span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"keyword\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 链表的遍历赋值</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> binCount = <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        <span class=\"comment\">// 判断链表长度，是否需要树化</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// key存在的处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// existing mapping for key</span></span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 扩容的判断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化的逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"comment\">// 如果数组为空或长度太小，不会选择树化，而是扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; hd = <span class=\"keyword\">null</span>, tl = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class=\"keyword\">null</span>);<span class=\"comment\">// 替换节点对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tl == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                hd = p;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p.prev = tl;</span><br><span class=\"line\">                tl.next = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tl = p;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> ((e = e.next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((tab[index] = hd) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 调用TreeNode的方法完成树化</span></span><br><span class=\"line\">            hd.treeify(tab);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩容方法</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCap = (oldTab == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : oldTab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldThr = threshold;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCap, newThr = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 原数组不为空的前提</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldCap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 阈值判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">            threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldTab;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 不超出阈值的前提下，扩容为2倍</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">            newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double threshold</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;               <span class=\"comment\">// zero initial threshold signifies using defaults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算新的键值对阈值</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFactor;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                  (<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = newThr;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(&#123;<span class=\"string\">\"rawtypes\"</span>,<span class=\"string\">\"unchecked\"</span>&#125;)</span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newCap];</span><br><span class=\"line\">    table = newTab;</span><br><span class=\"line\">    <span class=\"comment\">// table扩容 重新计算数组下标</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldTab != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; e;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((e = oldTab[j]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                oldTab[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    newTab[e.hash &amp; (newCap - <span class=\"number\">1</span>)] = e;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">                    <span class=\"comment\">// 树结构的处理</span></span><br><span class=\"line\">                    ((TreeNode&lt;K,V&gt;)e).split(<span class=\"keyword\">this</span>, newTab, j, oldCap);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// preserve order</span></span><br><span class=\"line\">                    Node&lt;K,V&gt; loHead = <span class=\"keyword\">null</span>, loTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; hiHead = <span class=\"keyword\">null</span>, hiTail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    Node&lt;K,V&gt; next;</span><br><span class=\"line\">                    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                        next = e.next;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> ((e.hash &amp; oldCap) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (loTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                loHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                loTail.next = e;</span><br><span class=\"line\">                            loTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hiTail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hiHead = e;</span><br><span class=\"line\">                            <span class=\"keyword\">else</span></span><br><span class=\"line\">                                hiTail.next = e;</span><br><span class=\"line\">                            hiTail = e;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">while</span> ((e = next) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (loTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        loTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j] = loHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (hiTail != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                        hiTail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                        newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newTab;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------内部类 TreeNode 的方法-----------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">// 树结构的put方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> TreeNode&lt;K,V&gt; <span class=\"title\">putTreeVal</span><span class=\"params\">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class=\"line\">    Class&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> searched = <span class=\"keyword\">false</span>; <span class=\"comment\">// 是否遍历过</span></span><br><span class=\"line\">    TreeNode&lt;K,V&gt; root = (parent != <span class=\"keyword\">null</span>) ? root() : <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dir, ph; K pk;</span><br><span class=\"line\">        <span class=\"comment\">// 查找key是否在树中存在</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">            dir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">            dir = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((pk = p.key) == k || (k != <span class=\"keyword\">null</span> &amp;&amp; k.equals(pk)))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp; (kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">                 (dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!searched) &#123;</span><br><span class=\"line\">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class=\"line\">                searched = <span class=\"keyword\">true</span>; <span class=\"comment\">// 避免后续循环再走到此逻辑中</span></span><br><span class=\"line\">                <span class=\"comment\">// 递归find方法，分别遍历左右子树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (((ch = p.left) != <span class=\"keyword\">null</span> &amp;&amp; (q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">                    ((ch = p.right) != <span class=\"keyword\">null</span> &amp;&amp; (q = ch.find(h, k, kc)) != <span class=\"keyword\">null</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> q;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dir = tieBreakOrder(k, pk);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class=\"line\">        <span class=\"comment\">// 新建树节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class=\"line\">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                xp.left = x;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                xp.right = x;</span><br><span class=\"line\">            xp.next = x;</span><br><span class=\"line\">            x.parent = x.prev = xp;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (xpn != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class=\"line\">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 树化具体实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeify</span><span class=\"params\">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class=\"line\">    TreeNode&lt;K,V&gt; root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; x = <span class=\"keyword\">this</span>, next; x != <span class=\"keyword\">null</span>; x = next) &#123;</span><br><span class=\"line\">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class=\"line\">        x.left = x.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 确定根节点 红黑树根节点为黑色</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            x.parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            x.red = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            root = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 左右子节点的判定，与get，put中的判断类似</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            K k = x.key;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = x.hash;</span><br><span class=\"line\">            Class&lt;?&gt; kc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> dir, ph;</span><br><span class=\"line\">                K pk = p.key;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((ph = p.hash) &gt; h)</span><br><span class=\"line\">                    dir = -<span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ph &lt; h)</span><br><span class=\"line\">                    dir = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((kc == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                          (kc = comparableClassFor(k)) == <span class=\"keyword\">null</span>) ||</span><br><span class=\"line\">                         (dir = compareComparables(kc, k, pk)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    dir = tieBreakOrder(k, pk);</span><br><span class=\"line\">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((p = (dir &lt;= <span class=\"number\">0</span>) ? p.left : p.right) == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    x.parent = xp;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (dir &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                        xp.left = x;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                        xp.right = x;</span><br><span class=\"line\">                    <span class=\"comment\">// 平衡插入 暂时没完全看懂 这里就贴出来</span></span><br><span class=\"line\">                    root = balanceInsertion(root, x);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 保证树的头节点在table中</span></span><br><span class=\"line\">    moveRootToFront(tab, root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>   HashMap相对ArrayList复杂许多，涉及红黑树的操作逻辑都很值得琢磨。因为篇幅问题，只从源码中摘出\n我认为较常用的方法(get，put)和一些重要的逻辑。分析源码逻辑确实受益良多，一些想法中直接简单的逻辑\n，为了保证代码的健壮性，实现起来往往就会复杂许多。例如涉及红黑树的一些处理，做了很多判断，遍历，\n递归之类的，一开始感觉有些重复了，思考良久之后才理解为什么。这里照旧小结一下：\n1. HashMap中涉及了较多的位运算，异或，按位与之类的。因为实际工作中较少使用，导致对这些位运算都比\n较陌生了，需要对位运算复习一下\n2. 源码中许多方法都是使用了局部变量去处理，比如红黑树的判断，都是在方法中定义变量指向树的根节点\n或左右子节点再去处理。我理解的原因第一是局部变量能在方法结束后被回收，第二应该是避免直接操作导致\n原对象的错误更改。(虽然有时候这样的处理增加了代码阅读的难度···)\n3. 红黑树的相关操作(TreeNode的一些方法)，虽然有些方法没完全看懂，但是可以作为树结构操作的一个参考</code></pre>"},{"title":"PriorityQueue(jdk1.8)","date":"2020-06-29T07:18:40.000Z","_content":"\n### PriorityQueue简介\n\n       PriorityQueue是java.util包下实现Queue接口的非线程安全的优先级队列\n       也是由数组实现，类似ArrayList通过复制数组达到扩容的操作\n       其特点是可以按照自定义的元素比较器的规则输出队列元素，默认是按小到大的输出顺序\n       该队列不允许插入null或不可比较的对象(没有实现Comparable接口的对象)\n<!-- more -->\n类定义如下：\n{% codeblock lang:java %}\npublic class PriorityQueue<E> extends AbstractQueue<E>\n    implements java.io.Serializable\n{% endcodeblock %}\n\n### 属性信息\n\n{% codeblock lang:java %}\n// 默认数组长度\nprivate static final int DEFAULT_INITIAL_CAPACITY = 11;\n\n// 存储元素的数组\ntransient Object[] queue;\n\n// 数组长度\nprivate int size = 0;\n\n// 元素比较器\nprivate final Comparator<? super E> comparator;\n\n{% endcodeblock %}\n\n\n### 构造方法\n  \n{% codeblock lang:java %}\n// 无参构造方法\npublic PriorityQueue() {\n    this(DEFAULT_INITIAL_CAPACITY, null);\n}\n\n// 指定长度的构造方法\npublic PriorityQueue(int initialCapacity) {\n    this(initialCapacity, null);\n}\n\n// 指定元素比较器的构造方法\npublic PriorityQueue(Comparator<? super E> comparator) {\n    this(DEFAULT_INITIAL_CAPACITY, comparator);\n}\n\n// 指定元素比较器和数组长度的构造方法\npublic PriorityQueue(int initialCapacity,\n                     Comparator<? super E> comparator) {\n    // Note: This restriction of at least one is not actually needed,\n    // but continues for 1.5 compatibility\n    if (initialCapacity < 1)\n        throw new IllegalArgumentException();\n    this.queue = new Object[initialCapacity];\n    this.comparator = comparator;\n}\n\n// 指定集合的构造\npublic PriorityQueue(Collection<? extends E> c) {\n// 判断集合入参的类型，初始化元素比较器\n    if (c instanceof SortedSet<?>) {\n        SortedSet<? extends E> ss = (SortedSet<? extends E>) c;\n        this.comparator = (Comparator<? super E>) ss.comparator();\n        initElementsFromCollection(ss);\n    }\n    else if (c instanceof PriorityQueue<?>) {\n        PriorityQueue<? extends E> pq = (PriorityQueue<? extends E>) c;\n        this.comparator = (Comparator<? super E>) pq.comparator();\n        initFromPriorityQueue(pq);\n    }\n    else {\n        this.comparator = null;\n        initFromCollection(c);\n    }\n}\n{% endcodeblock %}\n\n### 核心方法\n\n{% codeblock lang:java %}\n// 元素排序算法，在初始化队列元素时，调用该方法保证队列的顺序符合规则\nprivate void heapify() {\n    for (int i = (size >>> 1) - 1; i >= 0; i--)\n        siftDown(i, (E) queue[i]);\n}\n\n// 扩容方法\nprivate void grow(int minCapacity) {\n    int oldCapacity = queue.length;\n    // 数组小于64则按old+1的两倍扩容，反之，old的1.5倍扩容\n    int newCapacity = oldCapacity + ((oldCapacity < 64) ?\n                                     (oldCapacity + 2) :\n                                     (oldCapacity >> 1));\n    // 数组长度控制，不超过Integer.MAX_VALUE\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    queue = Arrays.copyOf(queue, newCapacity);\n}\n\n// 元素下沉\nprivate void siftDown(int k, E x) {\n    if (comparator != null)\n        siftDownUsingComparator(k, x);\n    else\n        siftDownComparable(k, x);\n}\n\n// 实现逻辑\nprivate void siftDownUsingComparator(int k, E x) {\n    int half = size >>> 1;\n    while (k < half) {\n        // 计算子节点下标\n        int child = (k << 1) + 1;\n        Object c = queue[child];\n        int right = child + 1;\n        // 取子节点较小的一个\n        if (right < size &&\n            comparator.compare((E) c, (E) queue[right]) > 0)\n            c = queue[child = right];\n        // 与子节点比较直到小于等于子节点\n        if (comparator.compare(x, (E) c) <= 0)\n            break;\n        queue[k] = c;\n        k = child;\n    }\n    queue[k] = x;\n}\n\n// 元素上浮\nprivate void siftUp(int k, E x) {\n    if (comparator != null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n}\n\n// 实现逻辑\nprivate void siftUpUsingComparator(int k, E x) {\n    while (k > 0) {\n        int parent = (k - 1) >>> 1;// 计算父节点下标\n        Object e = queue[parent];\n        // 每次和父节点比较，直到大于等于父节点\n        if (comparator.compare(x, (E) e) >= 0)\n            break;\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = x;\n}\n{% endcodeblock%}\n\n### 基本操作\n\n{% codeblock lang:java %}\n// 新增元素\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i >= queue.length)\n        grow(i + 1);\n    size = i + 1;\n    if (i == 0)\n        queue[0] = e;\n    else\n        siftUp(i, e);// 对新增元素做上浮操作\n    return true;\n}\n\n// 弹出队首元素\npublic E poll() {\n    if (size == 0)\n        return null;\n    int s = --size;\n    modCount++;\n    E result = (E) queue[0];// 弹出队首元素\n    E x = (E) queue[s];\n    queue[s] = null;// 队尾置空\n    // 此时队首元素还没变\n    if (s != 0)\n        siftDown(0, x);// 对队尾元素做下沉操作\n    return result;\n}\n\n// 删除\nprivate E removeAt(int i) {\n    // assert i >= 0 && i < size;\n    modCount++;\n    int s = --size;\n    if (s == i) // removed last element\n        queue[i] = null;\n    else {\n        E moved = (E) queue[s];\n        queue[s] = null;\n        siftDown(i, moved);// 对队尾元素做下沉操作 \n        if (queue[i] == moved) {// 判断moved元素没有改变\n            siftUp(i, moved);// 进行一次上浮操作\n            if (queue[i] != moved)\n                return moved;\n        }\n    }\n    return null;\n}\n{% endcodeblock%}\n\n  通过siftDown()和siftUp()方法可以看出，优先队列是借助数组实现了一个二叉堆。\n> 二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。\n> 二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。\n> 二叉堆一般用数组来表示。如果根节点在数组中下标为0，下标n的元素子节点下标为2n+1和2n+2。\n\n\n{% codeblock lang:java %}\nPriorityQueue<Integer> queue = Queues.newPriorityQueue();\nqueue.add(5);\nqueue.add(3);\nqueue.add(10);\nqueue.add(6);\nqueue.add(2);\nqueue.add(2);\nqueue.add(1);\nqueue.add(6);\nfor(Integer i:queue){\n    System.out.print(i);\n    System.out.print(\",\");\n}\nSystem.out.println();\nwhile(queue.size()>0){\n    System.out.print(queue.poll());\n    System.out.print(\",\");\n}\n// output:\n// 1,3,2,6,5,10,2,6,\n// 1,2,2,3,5,6,6,10,\n{% endcodeblock %}\n\n  上述的代码示例可以看到PriorityQueue每次弹出时都会重新整理元素顺序。\n\n### 小结\n\n      优先级队列的结构其实比较简单，是一个用数组实现的二叉堆来保证元素的弹出顺序。","source":"_posts/2020/06/PriorityQueue1.md","raw":"---\ntitle: PriorityQueue(jdk1.8)\ndate: 2020-06-29 15:18:40\ntags:\n- Java容器\ncategories:\n- Java\n- Collection\n- Queue\n---\n\n### PriorityQueue简介\n\n       PriorityQueue是java.util包下实现Queue接口的非线程安全的优先级队列\n       也是由数组实现，类似ArrayList通过复制数组达到扩容的操作\n       其特点是可以按照自定义的元素比较器的规则输出队列元素，默认是按小到大的输出顺序\n       该队列不允许插入null或不可比较的对象(没有实现Comparable接口的对象)\n<!-- more -->\n类定义如下：\n{% codeblock lang:java %}\npublic class PriorityQueue<E> extends AbstractQueue<E>\n    implements java.io.Serializable\n{% endcodeblock %}\n\n### 属性信息\n\n{% codeblock lang:java %}\n// 默认数组长度\nprivate static final int DEFAULT_INITIAL_CAPACITY = 11;\n\n// 存储元素的数组\ntransient Object[] queue;\n\n// 数组长度\nprivate int size = 0;\n\n// 元素比较器\nprivate final Comparator<? super E> comparator;\n\n{% endcodeblock %}\n\n\n### 构造方法\n  \n{% codeblock lang:java %}\n// 无参构造方法\npublic PriorityQueue() {\n    this(DEFAULT_INITIAL_CAPACITY, null);\n}\n\n// 指定长度的构造方法\npublic PriorityQueue(int initialCapacity) {\n    this(initialCapacity, null);\n}\n\n// 指定元素比较器的构造方法\npublic PriorityQueue(Comparator<? super E> comparator) {\n    this(DEFAULT_INITIAL_CAPACITY, comparator);\n}\n\n// 指定元素比较器和数组长度的构造方法\npublic PriorityQueue(int initialCapacity,\n                     Comparator<? super E> comparator) {\n    // Note: This restriction of at least one is not actually needed,\n    // but continues for 1.5 compatibility\n    if (initialCapacity < 1)\n        throw new IllegalArgumentException();\n    this.queue = new Object[initialCapacity];\n    this.comparator = comparator;\n}\n\n// 指定集合的构造\npublic PriorityQueue(Collection<? extends E> c) {\n// 判断集合入参的类型，初始化元素比较器\n    if (c instanceof SortedSet<?>) {\n        SortedSet<? extends E> ss = (SortedSet<? extends E>) c;\n        this.comparator = (Comparator<? super E>) ss.comparator();\n        initElementsFromCollection(ss);\n    }\n    else if (c instanceof PriorityQueue<?>) {\n        PriorityQueue<? extends E> pq = (PriorityQueue<? extends E>) c;\n        this.comparator = (Comparator<? super E>) pq.comparator();\n        initFromPriorityQueue(pq);\n    }\n    else {\n        this.comparator = null;\n        initFromCollection(c);\n    }\n}\n{% endcodeblock %}\n\n### 核心方法\n\n{% codeblock lang:java %}\n// 元素排序算法，在初始化队列元素时，调用该方法保证队列的顺序符合规则\nprivate void heapify() {\n    for (int i = (size >>> 1) - 1; i >= 0; i--)\n        siftDown(i, (E) queue[i]);\n}\n\n// 扩容方法\nprivate void grow(int minCapacity) {\n    int oldCapacity = queue.length;\n    // 数组小于64则按old+1的两倍扩容，反之，old的1.5倍扩容\n    int newCapacity = oldCapacity + ((oldCapacity < 64) ?\n                                     (oldCapacity + 2) :\n                                     (oldCapacity >> 1));\n    // 数组长度控制，不超过Integer.MAX_VALUE\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    queue = Arrays.copyOf(queue, newCapacity);\n}\n\n// 元素下沉\nprivate void siftDown(int k, E x) {\n    if (comparator != null)\n        siftDownUsingComparator(k, x);\n    else\n        siftDownComparable(k, x);\n}\n\n// 实现逻辑\nprivate void siftDownUsingComparator(int k, E x) {\n    int half = size >>> 1;\n    while (k < half) {\n        // 计算子节点下标\n        int child = (k << 1) + 1;\n        Object c = queue[child];\n        int right = child + 1;\n        // 取子节点较小的一个\n        if (right < size &&\n            comparator.compare((E) c, (E) queue[right]) > 0)\n            c = queue[child = right];\n        // 与子节点比较直到小于等于子节点\n        if (comparator.compare(x, (E) c) <= 0)\n            break;\n        queue[k] = c;\n        k = child;\n    }\n    queue[k] = x;\n}\n\n// 元素上浮\nprivate void siftUp(int k, E x) {\n    if (comparator != null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n}\n\n// 实现逻辑\nprivate void siftUpUsingComparator(int k, E x) {\n    while (k > 0) {\n        int parent = (k - 1) >>> 1;// 计算父节点下标\n        Object e = queue[parent];\n        // 每次和父节点比较，直到大于等于父节点\n        if (comparator.compare(x, (E) e) >= 0)\n            break;\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = x;\n}\n{% endcodeblock%}\n\n### 基本操作\n\n{% codeblock lang:java %}\n// 新增元素\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i >= queue.length)\n        grow(i + 1);\n    size = i + 1;\n    if (i == 0)\n        queue[0] = e;\n    else\n        siftUp(i, e);// 对新增元素做上浮操作\n    return true;\n}\n\n// 弹出队首元素\npublic E poll() {\n    if (size == 0)\n        return null;\n    int s = --size;\n    modCount++;\n    E result = (E) queue[0];// 弹出队首元素\n    E x = (E) queue[s];\n    queue[s] = null;// 队尾置空\n    // 此时队首元素还没变\n    if (s != 0)\n        siftDown(0, x);// 对队尾元素做下沉操作\n    return result;\n}\n\n// 删除\nprivate E removeAt(int i) {\n    // assert i >= 0 && i < size;\n    modCount++;\n    int s = --size;\n    if (s == i) // removed last element\n        queue[i] = null;\n    else {\n        E moved = (E) queue[s];\n        queue[s] = null;\n        siftDown(i, moved);// 对队尾元素做下沉操作 \n        if (queue[i] == moved) {// 判断moved元素没有改变\n            siftUp(i, moved);// 进行一次上浮操作\n            if (queue[i] != moved)\n                return moved;\n        }\n    }\n    return null;\n}\n{% endcodeblock%}\n\n  通过siftDown()和siftUp()方法可以看出，优先队列是借助数组实现了一个二叉堆。\n> 二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。\n> 二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。\n> 二叉堆一般用数组来表示。如果根节点在数组中下标为0，下标n的元素子节点下标为2n+1和2n+2。\n\n\n{% codeblock lang:java %}\nPriorityQueue<Integer> queue = Queues.newPriorityQueue();\nqueue.add(5);\nqueue.add(3);\nqueue.add(10);\nqueue.add(6);\nqueue.add(2);\nqueue.add(2);\nqueue.add(1);\nqueue.add(6);\nfor(Integer i:queue){\n    System.out.print(i);\n    System.out.print(\",\");\n}\nSystem.out.println();\nwhile(queue.size()>0){\n    System.out.print(queue.poll());\n    System.out.print(\",\");\n}\n// output:\n// 1,3,2,6,5,10,2,6,\n// 1,2,2,3,5,6,6,10,\n{% endcodeblock %}\n\n  上述的代码示例可以看到PriorityQueue每次弹出时都会重新整理元素顺序。\n\n### 小结\n\n      优先级队列的结构其实比较简单，是一个用数组实现的二叉堆来保证元素的弹出顺序。","slug":"PriorityQueue1","published":1,"updated":"2020-08-15T12:34:04.998Z","_id":"ckdvmudy8000inwb5cldae7rj","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"PriorityQueue简介\"><a href=\"#PriorityQueue简介\" class=\"headerlink\" title=\"PriorityQueue简介\"></a>PriorityQueue简介</h3><pre><code>PriorityQueue是java.util包下实现Queue接口的非线程安全的优先级队列\n也是由数组实现，类似ArrayList通过复制数组达到扩容的操作\n其特点是可以按照自定义的元素比较器的规则输出队列元素，默认是按小到大的输出顺序\n该队列不允许插入null或不可比较的对象(没有实现Comparable接口的对象)</code></pre><a id=\"more\"></a>\n<p>类定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityQueue</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueue</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认数组长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">11</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储元素的数组</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素比较器</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无参构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定长度的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定元素比较器的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定元素比较器和数组长度的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Note: This restriction of at least one is not actually needed,</span></span><br><span class=\"line\">    <span class=\"comment\">// but continues for 1.5 compatibility</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.comparator = comparator;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定集合的构造</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 判断集合入参的类型，初始化元素比较器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c <span class=\"keyword\">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class=\"line\">        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.comparator = (Comparator&lt;? <span class=\"keyword\">super</span> E&gt;) ss.comparator();</span><br><span class=\"line\">        initElementsFromCollection(ss);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c <span class=\"keyword\">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class=\"line\">        PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.comparator = (Comparator&lt;? <span class=\"keyword\">super</span> E&gt;) pq.comparator();</span><br><span class=\"line\">        initFromPriorityQueue(pq);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.comparator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        initFromCollection(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 元素排序算法，在初始化队列元素时，调用该方法保证队列的顺序符合规则</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">heapify</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (size &gt;&gt;&gt; <span class=\"number\">1</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        siftDown(i, (E) queue[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩容方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = queue.length;</span><br><span class=\"line\">    <span class=\"comment\">// 数组小于64则按old+1的两倍扩容，反之，old的1.5倍扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class=\"number\">64</span>) ?</span><br><span class=\"line\">                                     (oldCapacity + <span class=\"number\">2</span>) :</span><br><span class=\"line\">                                     (oldCapacity &gt;&gt; <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 数组长度控制，不超过Integer.MAX_VALUE</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素下沉</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDown</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        siftDownUsingComparator(k, x);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftDownComparable(k, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDownUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> half = size &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; half) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算子节点下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> child = (k &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object c = queue[child];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = child + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 取子节点较小的一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; size &amp;&amp;</span><br><span class=\"line\">            comparator.compare((E) c, (E) queue[right]) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            c = queue[child = right];</span><br><span class=\"line\">        <span class=\"comment\">// 与子节点比较直到小于等于子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) c) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = c;</span><br><span class=\"line\">        k = child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素上浮</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUp</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        siftUpUsingComparator(k, x);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftUpComparable(k, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUpUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;<span class=\"comment\">// 计算父节点下标</span></span><br><span class=\"line\">        Object e = queue[parent];</span><br><span class=\"line\">        <span class=\"comment\">// 每次和父节点比较，直到大于等于父节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) e) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = e;</span><br><span class=\"line\">        k = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新增元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= queue.length)</span><br><span class=\"line\">        grow(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    size = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>)</span><br><span class=\"line\">        queue[<span class=\"number\">0</span>] = e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftUp(i, e);<span class=\"comment\">// 对新增元素做上浮操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹出队首元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = --size;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E result = (E) queue[<span class=\"number\">0</span>];<span class=\"comment\">// 弹出队首元素</span></span><br><span class=\"line\">    E x = (E) queue[s];</span><br><span class=\"line\">    queue[s] = <span class=\"keyword\">null</span>;<span class=\"comment\">// 队尾置空</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时队首元素还没变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"number\">0</span>)</span><br><span class=\"line\">        siftDown(<span class=\"number\">0</span>, x);<span class=\"comment\">// 对队尾元素做下沉操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">removeAt</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = --size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == i) <span class=\"comment\">// removed last element</span></span><br><span class=\"line\">        queue[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        E moved = (E) queue[s];</span><br><span class=\"line\">        queue[s] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        siftDown(i, moved);<span class=\"comment\">// 对队尾元素做下沉操作 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue[i] == moved) &#123;<span class=\"comment\">// 判断moved元素没有改变</span></span><br><span class=\"line\">            siftUp(i, moved);<span class=\"comment\">// 进行一次上浮操作</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (queue[i] != moved)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> moved;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  通过siftDown()和siftUp()方法可以看出，优先队列是借助数组实现了一个二叉堆。</p>\n<blockquote>\n<p>二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。<br>二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。<br>二叉堆一般用数组来表示。如果根节点在数组中下标为0，下标n的元素子节点下标为2n+1和2n+2。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PriorityQueue&lt;Integer&gt; queue = Queues.newPriorityQueue();</span><br><span class=\"line\">queue.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">10</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">6</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer i:queue)&#123;</span><br><span class=\"line\">    System.out.print(i);</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(queue.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    System.out.print(queue.poll());</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 1,3,2,6,5,10,2,6,</span></span><br><span class=\"line\"><span class=\"comment\">// 1,2,2,3,5,6,6,10,</span></span><br></pre></td></tr></table></figure>\n\n<p>  上述的代码示例可以看到PriorityQueue每次弹出时都会重新整理元素顺序。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>优先级队列的结构其实比较简单，是一个用数组实现的二叉堆来保证元素的弹出顺序。</code></pre>","site":{"data":{}},"length":443,"excerpt":"<h3 id=\"PriorityQueue简介\"><a href=\"#PriorityQueue简介\" class=\"headerlink\" title=\"PriorityQueue简介\"></a>PriorityQueue简介</h3><pre><code>PriorityQueue是java.util包下实现Queue接口的非线程安全的优先级队列\n也是由数组实现，类似ArrayList通过复制数组达到扩容的操作\n其特点是可以按照自定义的元素比较器的规则输出队列元素，默认是按小到大的输出顺序\n该队列不允许插入null或不可比较的对象(没有实现Comparable接口的对象)</code></pre>","more":"<p>类定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriorityQueue</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueue</span>&lt;<span class=\"title\">E</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认数组长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">11</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 存储元素的数组</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] queue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数组长度</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素比较器</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无参构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定长度的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(initialCapacity, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定元素比较器的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定元素比较器和数组长度的构造方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     Comparator&lt;? <span class=\"keyword\">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Note: This restriction of at least one is not actually needed,</span></span><br><span class=\"line\">    <span class=\"comment\">// but continues for 1.5 compatibility</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue = <span class=\"keyword\">new</span> Object[initialCapacity];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.comparator = comparator;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定集合的构造</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriorityQueue</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 判断集合入参的类型，初始化元素比较器</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c <span class=\"keyword\">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class=\"line\">        SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.comparator = (Comparator&lt;? <span class=\"keyword\">super</span> E&gt;) ss.comparator();</span><br><span class=\"line\">        initElementsFromCollection(ss);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c <span class=\"keyword\">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class=\"line\">        PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.comparator = (Comparator&lt;? <span class=\"keyword\">super</span> E&gt;) pq.comparator();</span><br><span class=\"line\">        initFromPriorityQueue(pq);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.comparator = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        initFromCollection(c);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 元素排序算法，在初始化队列元素时，调用该方法保证队列的顺序符合规则</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">heapify</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (size &gt;&gt;&gt; <span class=\"number\">1</span>) - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        siftDown(i, (E) queue[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩容方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldCapacity = queue.length;</span><br><span class=\"line\">    <span class=\"comment\">// 数组小于64则按old+1的两倍扩容，反之，old的1.5倍扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class=\"number\">64</span>) ?</span><br><span class=\"line\">                                     (oldCapacity + <span class=\"number\">2</span>) :</span><br><span class=\"line\">                                     (oldCapacity &gt;&gt; <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 数组长度控制，不超过Integer.MAX_VALUE</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素下沉</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDown</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        siftDownUsingComparator(k, x);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftDownComparable(k, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftDownUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> half = size &gt;&gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &lt; half) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 计算子节点下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> child = (k &lt;&lt; <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        Object c = queue[child];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = child + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 取子节点较小的一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; size &amp;&amp;</span><br><span class=\"line\">            comparator.compare((E) c, (E) queue[right]) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            c = queue[child = right];</span><br><span class=\"line\">        <span class=\"comment\">// 与子节点比较直到小于等于子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) c) &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = c;</span><br><span class=\"line\">        k = child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 元素上浮</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUp</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (comparator != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        siftUpUsingComparator(k, x);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftUpComparable(k, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">siftUpUsingComparator</span><span class=\"params\">(<span class=\"keyword\">int</span> k, E x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> parent = (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;<span class=\"comment\">// 计算父节点下标</span></span><br><span class=\"line\">        Object e = queue[parent];</span><br><span class=\"line\">        <span class=\"comment\">// 每次和父节点比较，直到大于等于父节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) e) &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = e;</span><br><span class=\"line\">        k = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新增元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &gt;= queue.length)</span><br><span class=\"line\">        grow(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    size = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>)</span><br><span class=\"line\">        queue[<span class=\"number\">0</span>] = e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        siftUp(i, e);<span class=\"comment\">// 对新增元素做上浮操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 弹出队首元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = --size;</span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    E result = (E) queue[<span class=\"number\">0</span>];<span class=\"comment\">// 弹出队首元素</span></span><br><span class=\"line\">    E x = (E) queue[s];</span><br><span class=\"line\">    queue[s] = <span class=\"keyword\">null</span>;<span class=\"comment\">// 队尾置空</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时队首元素还没变</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s != <span class=\"number\">0</span>)</span><br><span class=\"line\">        siftDown(<span class=\"number\">0</span>, x);<span class=\"comment\">// 对队尾元素做下沉操作</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> E <span class=\"title\">removeAt</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = --size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == i) <span class=\"comment\">// removed last element</span></span><br><span class=\"line\">        queue[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        E moved = (E) queue[s];</span><br><span class=\"line\">        queue[s] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        siftDown(i, moved);<span class=\"comment\">// 对队尾元素做下沉操作 </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue[i] == moved) &#123;<span class=\"comment\">// 判断moved元素没有改变</span></span><br><span class=\"line\">            siftUp(i, moved);<span class=\"comment\">// 进行一次上浮操作</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (queue[i] != moved)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> moved;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  通过siftDown()和siftUp()方法可以看出，优先队列是借助数组实现了一个二叉堆。</p>\n<blockquote>\n<p>二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。<br>二叉堆有两种：最大堆和最小堆。最大堆：父结点的键值总是大于或等于任何一个子节点的键值；最小堆：父结点的键值总是小于或等于任何一个子节点的键值。<br>二叉堆一般用数组来表示。如果根节点在数组中下标为0，下标n的元素子节点下标为2n+1和2n+2。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PriorityQueue&lt;Integer&gt; queue = Queues.newPriorityQueue();</span><br><span class=\"line\">queue.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">3</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">10</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">6</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">2</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">queue.add(<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer i:queue)&#123;</span><br><span class=\"line\">    System.out.print(i);</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(queue.size()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    System.out.print(queue.poll());</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// 1,3,2,6,5,10,2,6,</span></span><br><span class=\"line\"><span class=\"comment\">// 1,2,2,3,5,6,6,10,</span></span><br></pre></td></tr></table></figure>\n\n<p>  上述的代码示例可以看到PriorityQueue每次弹出时都会重新整理元素顺序。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>优先级队列的结构其实比较简单，是一个用数组实现的二叉堆来保证元素的弹出顺序。</code></pre>"},{"title":"RocketMq-设计","date":"2020-06-24T01:54:19.000Z","_content":"\n### 前言\n  \n  上一章基本了解了RocketMQ的架构部分，知道了四个结构的功能和作用，这一章继续看下RocketMQ的一些设计细节。\n<!-- more -->\n\n### 通信机制\n\n  在上一章中，我们可以看到NameServer，BrokerServer，Producer，Consumer之间都存在通信\n  的过程。例如Broker需要注册，发送心跳包给NameServer;生产者，消费者也需要通过NameServer获取Broker的路由信息等。\n  而RocketMQ中专门有一个rocketmq-remoting负责实现这些通信功能。\n\n> rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需\n> 要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。\n\n#### RemotingCommand\n  \n> RemotingCommand在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作。\n\n  根据RemotingCommand的定义看看通信的数据结构\n  {% codeblock lang:java %}\n  // 请求操作吗|应答响应码\n  private int code;\n  // 实现语言，这里默认是Java\n  private LanguageCode language = LanguageCode.JAVA;\n  // 程序版本\n  private int version = 0;\n  // 相当于requestId\n  private int opaque = requestId.getAndIncrement();\n  // 区分是普通RPC还是onewayRPC得标志\n  private int flag = 0;\n  // 传输自定义文本信息\n  private String remark;\n  // 请求自定义扩展信息\n  private HashMap<String, String> extFields;\n  {% endcodeblock %}\n\n  除了定义了数据结构，还提供了相应的方法，如：编码解码及创建请求响应的数据结构，这里就不一一看了。\n\n### 消息过滤\n  \n  消息过滤主要有两种方式：\n  1. Tag过滤方式：消费者指定消费消息时，除了topic还可以配置多个tag。其过程分为两步，首先\n     在store层从ConsumeQueue根据消息的tag的hash值做过滤；然后，消费者拉取到消息时还会对tag做一遍比对，防止hash冲突导致拉取错误的数据。\n\n  2. SQL92：大致过程与第一种一样，不同的是在store层过滤数据执行的sql并用BloomFilter避免了每次都去执行\n\n>  SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）\n\n### 消息查询\n\n  消息查询有两种方式：\n  1. 按照MessageId查询，MessageId的长度总共有16字节，其中包含了消息存储主机地址（IP地址和端口）\n> Client端从MessageId中解析出Broker的地址（IP地址和端口）和Commit Log的偏移地址\n> 后封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程用其中的 commitLog offset 和 size 去 commitLog 中找到真正的记录并解析成一个完整的消息返回。\n\n  2. 按照MessageKey查询，基于IndexFile实现\n\n### 小结\n  \n      本章主要是基于GitHub文档中设计一节的内容的记录。大概了解了RocketMQ通信的结构及实现，不过关于\n    通信的一些设计是基于netty实现，源码看得不是很 理解，就不在这里记录了。\n      关于负载均衡及分布式事务消息的设计，内容有点复杂，可能需要单独一章记录，就不在本章赘述了。","source":"_posts/2020/06/RocketMq2.md","raw":"---\ntitle: RocketMq-设计\ndate: 2020-06-24 09:54:19\ntags:\n- RocketMQ\ncategories:\n- MQ\n- RocketMQ\n---\n\n### 前言\n  \n  上一章基本了解了RocketMQ的架构部分，知道了四个结构的功能和作用，这一章继续看下RocketMQ的一些设计细节。\n<!-- more -->\n\n### 通信机制\n\n  在上一章中，我们可以看到NameServer，BrokerServer，Producer，Consumer之间都存在通信\n  的过程。例如Broker需要注册，发送心跳包给NameServer;生产者，消费者也需要通过NameServer获取Broker的路由信息等。\n  而RocketMQ中专门有一个rocketmq-remoting负责实现这些通信功能。\n\n> rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需\n> 要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。\n\n#### RemotingCommand\n  \n> RemotingCommand在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作。\n\n  根据RemotingCommand的定义看看通信的数据结构\n  {% codeblock lang:java %}\n  // 请求操作吗|应答响应码\n  private int code;\n  // 实现语言，这里默认是Java\n  private LanguageCode language = LanguageCode.JAVA;\n  // 程序版本\n  private int version = 0;\n  // 相当于requestId\n  private int opaque = requestId.getAndIncrement();\n  // 区分是普通RPC还是onewayRPC得标志\n  private int flag = 0;\n  // 传输自定义文本信息\n  private String remark;\n  // 请求自定义扩展信息\n  private HashMap<String, String> extFields;\n  {% endcodeblock %}\n\n  除了定义了数据结构，还提供了相应的方法，如：编码解码及创建请求响应的数据结构，这里就不一一看了。\n\n### 消息过滤\n  \n  消息过滤主要有两种方式：\n  1. Tag过滤方式：消费者指定消费消息时，除了topic还可以配置多个tag。其过程分为两步，首先\n     在store层从ConsumeQueue根据消息的tag的hash值做过滤；然后，消费者拉取到消息时还会对tag做一遍比对，防止hash冲突导致拉取错误的数据。\n\n  2. SQL92：大致过程与第一种一样，不同的是在store层过滤数据执行的sql并用BloomFilter避免了每次都去执行\n\n>  SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）\n\n### 消息查询\n\n  消息查询有两种方式：\n  1. 按照MessageId查询，MessageId的长度总共有16字节，其中包含了消息存储主机地址（IP地址和端口）\n> Client端从MessageId中解析出Broker的地址（IP地址和端口）和Commit Log的偏移地址\n> 后封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程用其中的 commitLog offset 和 size 去 commitLog 中找到真正的记录并解析成一个完整的消息返回。\n\n  2. 按照MessageKey查询，基于IndexFile实现\n\n### 小结\n  \n      本章主要是基于GitHub文档中设计一节的内容的记录。大概了解了RocketMQ通信的结构及实现，不过关于\n    通信的一些设计是基于netty实现，源码看得不是很 理解，就不在这里记录了。\n      关于负载均衡及分布式事务消息的设计，内容有点复杂，可能需要单独一章记录，就不在本章赘述了。","slug":"RocketMq2","published":1,"updated":"2020-08-15T12:34:04.999Z","_id":"ckdvmudy9000knwb59oqlbv79","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  上一章基本了解了RocketMQ的架构部分，知道了四个结构的功能和作用，这一章继续看下RocketMQ的一些设计细节。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"通信机制\"><a href=\"#通信机制\" class=\"headerlink\" title=\"通信机制\"></a>通信机制</h3><p>  在上一章中，我们可以看到NameServer，BrokerServer，Producer，Consumer之间都存在通信<br>  的过程。例如Broker需要注册，发送心跳包给NameServer;生产者，消费者也需要通过NameServer获取Broker的路由信息等。<br>  而RocketMQ中专门有一个rocketmq-remoting负责实现这些通信功能。</p>\n<blockquote>\n<p>rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需<br>要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。</p>\n</blockquote>\n<h4 id=\"RemotingCommand\"><a href=\"#RemotingCommand\" class=\"headerlink\" title=\"RemotingCommand\"></a>RemotingCommand</h4><blockquote>\n<p>RemotingCommand在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作。</p>\n</blockquote>\n<p>  根据RemotingCommand的定义看看通信的数据结构<br>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求操作吗|应答响应码</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> code;</span><br><span class=\"line\"><span class=\"comment\">// 实现语言，这里默认是Java</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> LanguageCode language = LanguageCode.JAVA;</span><br><span class=\"line\"><span class=\"comment\">// 程序版本</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> version = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于requestId</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> opaque = requestId.getAndIncrement();</span><br><span class=\"line\"><span class=\"comment\">// 区分是普通RPC还是onewayRPC得标志</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 传输自定义文本信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> String remark;</span><br><span class=\"line\"><span class=\"comment\">// 请求自定义扩展信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> HashMap&lt;String, String&gt; extFields;</span><br></pre></td></tr></table></figure></p>\n<p>  除了定义了数据结构，还提供了相应的方法，如：编码解码及创建请求响应的数据结构，这里就不一一看了。</p>\n<h3 id=\"消息过滤\"><a href=\"#消息过滤\" class=\"headerlink\" title=\"消息过滤\"></a>消息过滤</h3><p>  消息过滤主要有两种方式：</p>\n<ol>\n<li><p>Tag过滤方式：消费者指定消费消息时，除了topic还可以配置多个tag。其过程分为两步，首先<br>在store层从ConsumeQueue根据消息的tag的hash值做过滤；然后，消费者拉取到消息时还会对tag做一遍比对，防止hash冲突导致拉取错误的数据。</p>\n</li>\n<li><p>SQL92：大致过程与第一种一样，不同的是在store层过滤数据执行的sql并用BloomFilter避免了每次都去执行</p>\n</li>\n</ol>\n<blockquote>\n<p> SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）</p>\n</blockquote>\n<h3 id=\"消息查询\"><a href=\"#消息查询\" class=\"headerlink\" title=\"消息查询\"></a>消息查询</h3><p>  消息查询有两种方式：</p>\n<ol>\n<li><p>按照MessageId查询，MessageId的长度总共有16字节，其中包含了消息存储主机地址（IP地址和端口）</p>\n<blockquote>\n<p>Client端从MessageId中解析出Broker的地址（IP地址和端口）和Commit Log的偏移地址<br>后封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程用其中的 commitLog offset 和 size 去 commitLog 中找到真正的记录并解析成一个完整的消息返回。</p>\n</blockquote>\n</li>\n<li><p>按照MessageKey查询，基于IndexFile实现</p>\n</li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  本章主要是基于GitHub文档中设计一节的内容的记录。大概了解了RocketMQ通信的结构及实现，不过关于\n通信的一些设计是基于netty实现，源码看得不是很 理解，就不在这里记录了。\n  关于负载均衡及分布式事务消息的设计，内容有点复杂，可能需要单独一章记录，就不在本章赘述了。</code></pre>","site":{"data":{}},"length":1268,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  上一章基本了解了RocketMQ的架构部分，知道了四个结构的功能和作用，这一章继续看下RocketMQ的一些设计细节。</p>","more":"<h3 id=\"通信机制\"><a href=\"#通信机制\" class=\"headerlink\" title=\"通信机制\"></a>通信机制</h3><p>  在上一章中，我们可以看到NameServer，BrokerServer，Producer，Consumer之间都存在通信<br>  的过程。例如Broker需要注册，发送心跳包给NameServer;生产者，消费者也需要通过NameServer获取Broker的路由信息等。<br>  而RocketMQ中专门有一个rocketmq-remoting负责实现这些通信功能。</p>\n<blockquote>\n<p>rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需<br>要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。</p>\n</blockquote>\n<h4 id=\"RemotingCommand\"><a href=\"#RemotingCommand\" class=\"headerlink\" title=\"RemotingCommand\"></a>RemotingCommand</h4><blockquote>\n<p>RemotingCommand在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作。</p>\n</blockquote>\n<p>  根据RemotingCommand的定义看看通信的数据结构<br>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 请求操作吗|应答响应码</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> code;</span><br><span class=\"line\"><span class=\"comment\">// 实现语言，这里默认是Java</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> LanguageCode language = LanguageCode.JAVA;</span><br><span class=\"line\"><span class=\"comment\">// 程序版本</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> version = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于requestId</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> opaque = requestId.getAndIncrement();</span><br><span class=\"line\"><span class=\"comment\">// 区分是普通RPC还是onewayRPC得标志</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// 传输自定义文本信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> String remark;</span><br><span class=\"line\"><span class=\"comment\">// 请求自定义扩展信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> HashMap&lt;String, String&gt; extFields;</span><br></pre></td></tr></table></figure></p>\n<p>  除了定义了数据结构，还提供了相应的方法，如：编码解码及创建请求响应的数据结构，这里就不一一看了。</p>\n<h3 id=\"消息过滤\"><a href=\"#消息过滤\" class=\"headerlink\" title=\"消息过滤\"></a>消息过滤</h3><p>  消息过滤主要有两种方式：</p>\n<ol>\n<li><p>Tag过滤方式：消费者指定消费消息时，除了topic还可以配置多个tag。其过程分为两步，首先<br>在store层从ConsumeQueue根据消息的tag的hash值做过滤；然后，消费者拉取到消息时还会对tag做一遍比对，防止hash冲突导致拉取错误的数据。</p>\n</li>\n<li><p>SQL92：大致过程与第一种一样，不同的是在store层过滤数据执行的sql并用BloomFilter避免了每次都去执行</p>\n</li>\n</ol>\n<blockquote>\n<p> SQL92，是数据库的一个ANSI/ISO标准。它定义了一种语言（SQL）以及数据库的行为（事务、隔离级别等）</p>\n</blockquote>\n<h3 id=\"消息查询\"><a href=\"#消息查询\" class=\"headerlink\" title=\"消息查询\"></a>消息查询</h3><p>  消息查询有两种方式：</p>\n<ol>\n<li><p>按照MessageId查询，MessageId的长度总共有16字节，其中包含了消息存储主机地址（IP地址和端口）</p>\n<blockquote>\n<p>Client端从MessageId中解析出Broker的地址（IP地址和端口）和Commit Log的偏移地址<br>后封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程用其中的 commitLog offset 和 size 去 commitLog 中找到真正的记录并解析成一个完整的消息返回。</p>\n</blockquote>\n</li>\n<li><p>按照MessageKey查询，基于IndexFile实现</p>\n</li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  本章主要是基于GitHub文档中设计一节的内容的记录。大概了解了RocketMQ通信的结构及实现，不过关于\n通信的一些设计是基于netty实现，源码看得不是很 理解，就不在这里记录了。\n  关于负载均衡及分布式事务消息的设计，内容有点复杂，可能需要单独一章记录，就不在本章赘述了。</code></pre>"},{"title":"ThinkingInJava-2","date":"2020-06-07T02:10:07.000Z","_content":"\n### 前言\n  \n  《Thinking in Java(第四版)》的第三，四章主要介绍了Java中基本的操作符及控制执行流程的相关关键字。\n<!-- more -->\n\n### 操作符\n  \n  本书的第三章-操作符，主要介绍了Java中使用到的各种操作符。\n  \n    1. 算术运算符：+, -, *, /, %\n    2. 关系操作符：>, <, ==, >=, <=\n    3. 逻辑操作符：&&, ||, !\n    4. 直接常量的类型指定：l L, f F, d D, 0x[n](16进制), 0[n](8进制) \n    5. 按位操作符：&, |, ~\n    6. 移位操作符：>>, <<, >>>\n    7. 条件操作符：? :\n\n  操作符比较好理解，需要注意的几点：\n\n    1. 操作符的顺序，如果不能确定建议使用()控制。这样也能提高代码的可读性\n    2. 逻辑操作符有短路的特性\n    3. 按位操作符，移位操作符都是针对二进制的操作，其中对char,byte,short类型的\n       数据进行移位操作时会先转为int类型，结果也是int\n\n  关于按位操作符和移位操作符的具体信息可以参考[\\<Java-位运算符>](https://rel-fly.com/2020/06/02/bitwiseOperator/)\n\n#### 直接常量\n  \n  某些时候，编译器可能无法确定一些直接常量的类型，就需要用到一些字符辅助。\n  例如：Java中会将指数当作double处理，那么对于*float f = 1e-10;*，如果不使用_f_ 作为后缀即*1e-10f*。就会报错，告诉我们需要将double转为float。\n\n### 控制执行流程\n  \n  本书的第四章，主要介绍判断，循环，跳转等流程控制的相关关键字。\n\n#### foreach\n  \n  加强型for循环，作为普通for循环的替代，因为不必创建int变量对访问项计数，提高了代码的可读性。\n  但也正是因为不用计数，所以在需要计数操作的场景下无法使用。\n  不过书中有提到这么一个办法：\n\n    1. 新建一个方法创建int数组 range(int i)\n    2. foreach直接调用这个方法 for(int i : range(10)){}\n\n  虽然这样可以让foreach适用更多场景，借此提高代码可读性。但是有些为了使用而使用的感觉。毕竟相对使用for，使用foreach需要先新建一个int数组，这个代价是否值得需要思量。\n\n\n#### 标签\n  \n  一般我们使用break，continue都是用于跳出循环，break中断并跳出当前循环，continue中断并跳出当次循环。\n  不过书中提到了标签，这个用的很少，所以记录一下：\n  {% codeblock lang:java %}\n  // 标签是跟有冒号的标识符，如 a:，他作用的唯一地方是在一个迭代语句之前，作为break，continue的一个锚\n  a:\n  for (int x = 0; x < 5; x++) {\n      b:\n      for (int y = 0; y < 4; y++) {\n          c:\n          for (int z = 0; z < 3; z++) {\n              System.out.println(\"start:\" + x + \",\" + y);\n              if (z == 0) {\n                  System.out.println(\"if:\" + z);\n                  continue a;\n                  // break a;\n              }\n          }\n      }\n  }\n  {% endcodeblock %}\n\n  如上述示例代码，三层嵌套的for循环，每一个都加了一个标签。当break/continue后面跟上标签时，在中断循环后，他们会跳到标签所在的位置再继续后续操作。\n  例如这里的*continue a*，不加标签的话会跳出当次循环继续z的自增循环，加了标签后，效果变为中断当次循环，跳到标签所在也就是最外层循环然后继续。\n\n      标签一般用于多层嵌套循环中控制break，continue的跳出位置。但是实际开发中是不建议使用多层嵌套循环\n    的，而且使用不善的话容易降低代码的可阅读性，需要谨慎使用。\n\n### 小结\n\n      操作符与流程控制的关键字都是比较基础的知识点。所以只记录实际开发中较少使用或者没接触过的知识点。\n\n> 下一章 [\\<ThinkingInJava-3>](https://rel-fly.com/2020/06/07/ThinkingInJava3/)","source":"_posts/2020/06/ThinkingInJava2.md","raw":"---\ntitle: ThinkingInJava-2\ndate: 2020-06-07 10:10:07\ntags:\n- ThinkingInJava\ncategories:\n- 读书笔记\n- ThinkingInJava\n---\n\n### 前言\n  \n  《Thinking in Java(第四版)》的第三，四章主要介绍了Java中基本的操作符及控制执行流程的相关关键字。\n<!-- more -->\n\n### 操作符\n  \n  本书的第三章-操作符，主要介绍了Java中使用到的各种操作符。\n  \n    1. 算术运算符：+, -, *, /, %\n    2. 关系操作符：>, <, ==, >=, <=\n    3. 逻辑操作符：&&, ||, !\n    4. 直接常量的类型指定：l L, f F, d D, 0x[n](16进制), 0[n](8进制) \n    5. 按位操作符：&, |, ~\n    6. 移位操作符：>>, <<, >>>\n    7. 条件操作符：? :\n\n  操作符比较好理解，需要注意的几点：\n\n    1. 操作符的顺序，如果不能确定建议使用()控制。这样也能提高代码的可读性\n    2. 逻辑操作符有短路的特性\n    3. 按位操作符，移位操作符都是针对二进制的操作，其中对char,byte,short类型的\n       数据进行移位操作时会先转为int类型，结果也是int\n\n  关于按位操作符和移位操作符的具体信息可以参考[\\<Java-位运算符>](https://rel-fly.com/2020/06/02/bitwiseOperator/)\n\n#### 直接常量\n  \n  某些时候，编译器可能无法确定一些直接常量的类型，就需要用到一些字符辅助。\n  例如：Java中会将指数当作double处理，那么对于*float f = 1e-10;*，如果不使用_f_ 作为后缀即*1e-10f*。就会报错，告诉我们需要将double转为float。\n\n### 控制执行流程\n  \n  本书的第四章，主要介绍判断，循环，跳转等流程控制的相关关键字。\n\n#### foreach\n  \n  加强型for循环，作为普通for循环的替代，因为不必创建int变量对访问项计数，提高了代码的可读性。\n  但也正是因为不用计数，所以在需要计数操作的场景下无法使用。\n  不过书中有提到这么一个办法：\n\n    1. 新建一个方法创建int数组 range(int i)\n    2. foreach直接调用这个方法 for(int i : range(10)){}\n\n  虽然这样可以让foreach适用更多场景，借此提高代码可读性。但是有些为了使用而使用的感觉。毕竟相对使用for，使用foreach需要先新建一个int数组，这个代价是否值得需要思量。\n\n\n#### 标签\n  \n  一般我们使用break，continue都是用于跳出循环，break中断并跳出当前循环，continue中断并跳出当次循环。\n  不过书中提到了标签，这个用的很少，所以记录一下：\n  {% codeblock lang:java %}\n  // 标签是跟有冒号的标识符，如 a:，他作用的唯一地方是在一个迭代语句之前，作为break，continue的一个锚\n  a:\n  for (int x = 0; x < 5; x++) {\n      b:\n      for (int y = 0; y < 4; y++) {\n          c:\n          for (int z = 0; z < 3; z++) {\n              System.out.println(\"start:\" + x + \",\" + y);\n              if (z == 0) {\n                  System.out.println(\"if:\" + z);\n                  continue a;\n                  // break a;\n              }\n          }\n      }\n  }\n  {% endcodeblock %}\n\n  如上述示例代码，三层嵌套的for循环，每一个都加了一个标签。当break/continue后面跟上标签时，在中断循环后，他们会跳到标签所在的位置再继续后续操作。\n  例如这里的*continue a*，不加标签的话会跳出当次循环继续z的自增循环，加了标签后，效果变为中断当次循环，跳到标签所在也就是最外层循环然后继续。\n\n      标签一般用于多层嵌套循环中控制break，continue的跳出位置。但是实际开发中是不建议使用多层嵌套循环\n    的，而且使用不善的话容易降低代码的可阅读性，需要谨慎使用。\n\n### 小结\n\n      操作符与流程控制的关键字都是比较基础的知识点。所以只记录实际开发中较少使用或者没接触过的知识点。\n\n> 下一章 [\\<ThinkingInJava-3>](https://rel-fly.com/2020/06/07/ThinkingInJava3/)","slug":"ThinkingInJava2","published":1,"updated":"2020-08-15T12:34:05.000Z","_id":"ckdvmudyb000onwb5brwd3tao","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  《Thinking in Java(第四版)》的第三，四章主要介绍了Java中基本的操作符及控制执行流程的相关关键字。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h3><p>  本书的第三章-操作符，主要介绍了Java中使用到的各种操作符。</p>\n<pre><code>1. 算术运算符：+, -, *, /, %\n2. 关系操作符：&gt;, &lt;, ==, &gt;=, &lt;=\n3. 逻辑操作符：&amp;&amp;, ||, !\n4. 直接常量的类型指定：l L, f F, d D, 0x[n](16进制), 0[n](8进制) \n5. 按位操作符：&amp;, |, ~\n6. 移位操作符：&gt;&gt;, &lt;&lt;, &gt;&gt;&gt;\n7. 条件操作符：? :</code></pre><p>  操作符比较好理解，需要注意的几点：</p>\n<pre><code>1. 操作符的顺序，如果不能确定建议使用()控制。这样也能提高代码的可读性\n2. 逻辑操作符有短路的特性\n3. 按位操作符，移位操作符都是针对二进制的操作，其中对char,byte,short类型的\n   数据进行移位操作时会先转为int类型，结果也是int</code></pre><p>  关于按位操作符和移位操作符的具体信息可以参考<a href=\"https://rel-fly.com/2020/06/02/bitwiseOperator/\">&lt;Java-位运算符&gt;</a></p>\n<h4 id=\"直接常量\"><a href=\"#直接常量\" class=\"headerlink\" title=\"直接常量\"></a>直接常量</h4><p>  某些时候，编译器可能无法确定一些直接常量的类型，就需要用到一些字符辅助。<br>  例如：Java中会将指数当作double处理，那么对于<em>float f = 1e-10;</em>，如果不使用<em>f</em> 作为后缀即<em>1e-10f</em>。就会报错，告诉我们需要将double转为float。</p>\n<h3 id=\"控制执行流程\"><a href=\"#控制执行流程\" class=\"headerlink\" title=\"控制执行流程\"></a>控制执行流程</h3><p>  本书的第四章，主要介绍判断，循环，跳转等流程控制的相关关键字。</p>\n<h4 id=\"foreach\"><a href=\"#foreach\" class=\"headerlink\" title=\"foreach\"></a>foreach</h4><p>  加强型for循环，作为普通for循环的替代，因为不必创建int变量对访问项计数，提高了代码的可读性。<br>  但也正是因为不用计数，所以在需要计数操作的场景下无法使用。<br>  不过书中有提到这么一个办法：</p>\n<pre><code>1. 新建一个方法创建int数组 range(int i)\n2. foreach直接调用这个方法 for(int i : range(10)){}</code></pre><p>  虽然这样可以让foreach适用更多场景，借此提高代码可读性。但是有些为了使用而使用的感觉。毕竟相对使用for，使用foreach需要先新建一个int数组，这个代价是否值得需要思量。</p>\n<h4 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h4><p>  一般我们使用break，continue都是用于跳出循环，break中断并跳出当前循环，continue中断并跳出当次循环。<br>  不过书中提到了标签，这个用的很少，所以记录一下：<br>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 标签是跟有冒号的标识符，如 a:，他作用的唯一地方是在一个迭代语句之前，作为break，continue的一个锚</span></span><br><span class=\"line\">a:</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; <span class=\"number\">5</span>; x++) &#123;</span><br><span class=\"line\">    b:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> y = <span class=\"number\">0</span>; y &lt; <span class=\"number\">4</span>; y++) &#123;</span><br><span class=\"line\">        c:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">3</span>; z++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"start:\"</span> + x + <span class=\"string\">\",\"</span> + y);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (z == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"if:\"</span> + z);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> a;</span><br><span class=\"line\">                <span class=\"comment\">// break a;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  如上述示例代码，三层嵌套的for循环，每一个都加了一个标签。当break/continue后面跟上标签时，在中断循环后，他们会跳到标签所在的位置再继续后续操作。<br>  例如这里的<em>continue a</em>，不加标签的话会跳出当次循环继续z的自增循环，加了标签后，效果变为中断当次循环，跳到标签所在也就是最外层循环然后继续。</p>\n<pre><code>  标签一般用于多层嵌套循环中控制break，continue的跳出位置。但是实际开发中是不建议使用多层嵌套循环\n的，而且使用不善的话容易降低代码的可阅读性，需要谨慎使用。</code></pre><h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>操作符与流程控制的关键字都是比较基础的知识点。所以只记录实际开发中较少使用或者没接触过的知识点。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/07/ThinkingInJava3/\">&lt;ThinkingInJava-3&gt;</a></p>\n</blockquote>\n","site":{"data":{}},"length":1218,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  《Thinking in Java(第四版)》的第三，四章主要介绍了Java中基本的操作符及控制执行流程的相关关键字。</p>","more":"<h3 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h3><p>  本书的第三章-操作符，主要介绍了Java中使用到的各种操作符。</p>\n<pre><code>1. 算术运算符：+, -, *, /, %\n2. 关系操作符：&gt;, &lt;, ==, &gt;=, &lt;=\n3. 逻辑操作符：&amp;&amp;, ||, !\n4. 直接常量的类型指定：l L, f F, d D, 0x[n](16进制), 0[n](8进制) \n5. 按位操作符：&amp;, |, ~\n6. 移位操作符：&gt;&gt;, &lt;&lt;, &gt;&gt;&gt;\n7. 条件操作符：? :</code></pre><p>  操作符比较好理解，需要注意的几点：</p>\n<pre><code>1. 操作符的顺序，如果不能确定建议使用()控制。这样也能提高代码的可读性\n2. 逻辑操作符有短路的特性\n3. 按位操作符，移位操作符都是针对二进制的操作，其中对char,byte,short类型的\n   数据进行移位操作时会先转为int类型，结果也是int</code></pre><p>  关于按位操作符和移位操作符的具体信息可以参考<a href=\"https://rel-fly.com/2020/06/02/bitwiseOperator/\">&lt;Java-位运算符&gt;</a></p>\n<h4 id=\"直接常量\"><a href=\"#直接常量\" class=\"headerlink\" title=\"直接常量\"></a>直接常量</h4><p>  某些时候，编译器可能无法确定一些直接常量的类型，就需要用到一些字符辅助。<br>  例如：Java中会将指数当作double处理，那么对于<em>float f = 1e-10;</em>，如果不使用<em>f</em> 作为后缀即<em>1e-10f</em>。就会报错，告诉我们需要将double转为float。</p>\n<h3 id=\"控制执行流程\"><a href=\"#控制执行流程\" class=\"headerlink\" title=\"控制执行流程\"></a>控制执行流程</h3><p>  本书的第四章，主要介绍判断，循环，跳转等流程控制的相关关键字。</p>\n<h4 id=\"foreach\"><a href=\"#foreach\" class=\"headerlink\" title=\"foreach\"></a>foreach</h4><p>  加强型for循环，作为普通for循环的替代，因为不必创建int变量对访问项计数，提高了代码的可读性。<br>  但也正是因为不用计数，所以在需要计数操作的场景下无法使用。<br>  不过书中有提到这么一个办法：</p>\n<pre><code>1. 新建一个方法创建int数组 range(int i)\n2. foreach直接调用这个方法 for(int i : range(10)){}</code></pre><p>  虽然这样可以让foreach适用更多场景，借此提高代码可读性。但是有些为了使用而使用的感觉。毕竟相对使用for，使用foreach需要先新建一个int数组，这个代价是否值得需要思量。</p>\n<h4 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h4><p>  一般我们使用break，continue都是用于跳出循环，break中断并跳出当前循环，continue中断并跳出当次循环。<br>  不过书中提到了标签，这个用的很少，所以记录一下：<br>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 标签是跟有冒号的标识符，如 a:，他作用的唯一地方是在一个迭代语句之前，作为break，continue的一个锚</span></span><br><span class=\"line\">a:</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> x = <span class=\"number\">0</span>; x &lt; <span class=\"number\">5</span>; x++) &#123;</span><br><span class=\"line\">    b:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> y = <span class=\"number\">0</span>; y &lt; <span class=\"number\">4</span>; y++) &#123;</span><br><span class=\"line\">        c:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> z = <span class=\"number\">0</span>; z &lt; <span class=\"number\">3</span>; z++) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"start:\"</span> + x + <span class=\"string\">\",\"</span> + y);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (z == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"if:\"</span> + z);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> a;</span><br><span class=\"line\">                <span class=\"comment\">// break a;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>  如上述示例代码，三层嵌套的for循环，每一个都加了一个标签。当break/continue后面跟上标签时，在中断循环后，他们会跳到标签所在的位置再继续后续操作。<br>  例如这里的<em>continue a</em>，不加标签的话会跳出当次循环继续z的自增循环，加了标签后，效果变为中断当次循环，跳到标签所在也就是最外层循环然后继续。</p>\n<pre><code>  标签一般用于多层嵌套循环中控制break，continue的跳出位置。但是实际开发中是不建议使用多层嵌套循环\n的，而且使用不善的话容易降低代码的可阅读性，需要谨慎使用。</code></pre><h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>操作符与流程控制的关键字都是比较基础的知识点。所以只记录实际开发中较少使用或者没接触过的知识点。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/07/ThinkingInJava3/\">&lt;ThinkingInJava-3&gt;</a></p>\n</blockquote>"},{"title":"RocketMq-架构","date":"2020-06-23T04:41:37.000Z","_content":"\n### 前言\n\n  虽然用过RocketMQ，但是对他的架构及底层原理都不甚了解，所以阅读github的文档增加一些了解，这里做一个记录。\n<!-- more -->\n\n### 架构\n\n  RocketMQ的架构设计主要是四部分\n  1. NameServer：路由注册中心，主要功能是管理Broker和路由信息\n  2. BrokerServer：负责消息的存储，投递，查询及高可用保证，是RocketMQ中最复杂的部分\n     为实现以上功能，他包含以下子模块：\n     * Remoting Module：整个Broker的实体，负责处理来自clients端的请求\n     * Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息\n     * Store Service：提供API接口处理消息存储到物理硬盘和查询功能\n     * HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能\n     * Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询\n  3. Producer：消息的发布者\n  4. Consumer：消息的消费者\n  \n#### NameServer对Broker的管理\n  \n  NameServer接受Broker集群的注册信息并保留作为路由信息的数据，并通过心跳检测检查Broker的存活情况。\n  心跳包由BrokerServer发出，NameServer负责接收及更新信息，如上报时间等。\n  {% codeblock lang:java %}\n  this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n\n      @Override\n      public void run() {\n          try {\n              BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister());\n          } catch (Throwable e) {\n              log.error(\"registerBrokerAll Exception\", e);\n          }\n      }\n  }, 1000 * 10, \n  Math.max(10000, Math.min(brokerConfig.getRegisterNameServerPeriod(), 60000)), \n  TimeUnit.MILLISECONDS);\n\n  // command：执行线程\n  // initialDelay：初始化延时\n  // period：两次开始执行最小间隔时间\n  // unit：计时单位\n  public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,\n\t\t\t\t                                long period, TimeUnit unit);\n  {% endcodeblock %}\n\n  使用ScheduledExecutorService新建一个定时任务，间隔时间范围在10s~60s之间。\n\n  然后NameServer会接收这个心跳包并保存，源码暂时没太理解，这里就不贴代码了。\n  除了接受心跳包，NameServer还会启动一个定时任务检测BrokerServer的状态：\n  {% codeblock lang:java %}\n  // 每10秒检测一次，对应心跳包发送的最小时间间隔\n  this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n\n      @Override\n      public void run() {\n          NamesrvController.this.routeInfoManager.scanNotActiveBroker();\n      }\n  }, 5, 10, TimeUnit.SECONDS);\n\n  // 检测的具体逻辑\n  // private final static long BROKER_CHANNEL_EXPIRED_TIME = 1000 * 60 * 2;\n  public void scanNotActiveBroker() {\n      Iterator<Entry<String, BrokerLiveInfo>> it = this.brokerLiveTable.entrySet().iterator();\n      while (it.hasNext()) {\n          Entry<String, BrokerLiveInfo> next = it.next();\n          // 超过2分钟没有收到心跳则删除\n          long last = next.getValue().getLastUpdateTimestamp();\n          if ((last + BROKER_CHANNEL_EXPIRED_TIME) < System.currentTimeMillis()) {\n              RemotingUtil.closeChannel(next.getValue().getChannel());\n              it.remove();\n              log.warn(\"The broker channel expired, {} {}ms\", \n              next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);\n              this.onChannelDestroy(next.getKey(), next.getValue().getChannel());\n          }\n      }\n  }\n  {% endcodeblock %}\n\n#### Broker的消息存储\n  \n  消息存储主要和以下三个文件有关：\n  1. CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的\n>    单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，\n>    比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；\n>    当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。\n\n  2. ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，可以理解为toic的索引文件，能够提高基于topic对消息的查询效率\n>    ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。\n>    consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，\n>    具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。\n>    同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。\n  3. IndexFile：提供了一种可以通过key或时间区间来查询消息的方法\n>    Index文件的存储位置是：$HOME \\store\\index${fileName}，\n>    文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。\n\n  CommitLog是数据实际的存储和数据持久化的方式，保证了消息不会丢失。而ConsumeQueue和IndexFile则是基于CommitLog的数据建立的索引来优化消息消费和查询的效率。\n  针对三种文件，org.apache.rocketmq.store包下也有对应的同名类进行配置管理，就不在本章详细解析了。\n\n### 部署架构\n\n* NameServer：几乎无状态节点，可集群部署，节点之间无任何信息同步\n* BrokerServer：多主从结构，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer\n* Producer：完全无状态，可集群部署；与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳\n* Consumer：与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳\n\n### 小结\n  \n      本章内容是阅读RocketMQ文档后总结的一些概念和知识点。简单的看了一下NameServer和Broker的部分\n    源码。源码内容较复杂，只能一个个模块拆开慢慢看了。\n      经过本章的总结，算是对RocketMQ有了基础的认识，之后再详细的了解吧。\n\n> 下一章 [\\<RocketMQ-设计>](https://rel-fly.com/2020/06/24/RocketMq2/)","source":"_posts/2020/06/RocketMq1.md","raw":"---\ntitle: RocketMq-架构\ndate: 2020-06-23 12:41:37\ntags:\n- RocketMQ\ncategories:\n- MQ\n- RocketMQ\n---\n\n### 前言\n\n  虽然用过RocketMQ，但是对他的架构及底层原理都不甚了解，所以阅读github的文档增加一些了解，这里做一个记录。\n<!-- more -->\n\n### 架构\n\n  RocketMQ的架构设计主要是四部分\n  1. NameServer：路由注册中心，主要功能是管理Broker和路由信息\n  2. BrokerServer：负责消息的存储，投递，查询及高可用保证，是RocketMQ中最复杂的部分\n     为实现以上功能，他包含以下子模块：\n     * Remoting Module：整个Broker的实体，负责处理来自clients端的请求\n     * Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息\n     * Store Service：提供API接口处理消息存储到物理硬盘和查询功能\n     * HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能\n     * Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询\n  3. Producer：消息的发布者\n  4. Consumer：消息的消费者\n  \n#### NameServer对Broker的管理\n  \n  NameServer接受Broker集群的注册信息并保留作为路由信息的数据，并通过心跳检测检查Broker的存活情况。\n  心跳包由BrokerServer发出，NameServer负责接收及更新信息，如上报时间等。\n  {% codeblock lang:java %}\n  this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n\n      @Override\n      public void run() {\n          try {\n              BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister());\n          } catch (Throwable e) {\n              log.error(\"registerBrokerAll Exception\", e);\n          }\n      }\n  }, 1000 * 10, \n  Math.max(10000, Math.min(brokerConfig.getRegisterNameServerPeriod(), 60000)), \n  TimeUnit.MILLISECONDS);\n\n  // command：执行线程\n  // initialDelay：初始化延时\n  // period：两次开始执行最小间隔时间\n  // unit：计时单位\n  public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,\n\t\t\t\t                                long period, TimeUnit unit);\n  {% endcodeblock %}\n\n  使用ScheduledExecutorService新建一个定时任务，间隔时间范围在10s~60s之间。\n\n  然后NameServer会接收这个心跳包并保存，源码暂时没太理解，这里就不贴代码了。\n  除了接受心跳包，NameServer还会启动一个定时任务检测BrokerServer的状态：\n  {% codeblock lang:java %}\n  // 每10秒检测一次，对应心跳包发送的最小时间间隔\n  this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {\n\n      @Override\n      public void run() {\n          NamesrvController.this.routeInfoManager.scanNotActiveBroker();\n      }\n  }, 5, 10, TimeUnit.SECONDS);\n\n  // 检测的具体逻辑\n  // private final static long BROKER_CHANNEL_EXPIRED_TIME = 1000 * 60 * 2;\n  public void scanNotActiveBroker() {\n      Iterator<Entry<String, BrokerLiveInfo>> it = this.brokerLiveTable.entrySet().iterator();\n      while (it.hasNext()) {\n          Entry<String, BrokerLiveInfo> next = it.next();\n          // 超过2分钟没有收到心跳则删除\n          long last = next.getValue().getLastUpdateTimestamp();\n          if ((last + BROKER_CHANNEL_EXPIRED_TIME) < System.currentTimeMillis()) {\n              RemotingUtil.closeChannel(next.getValue().getChannel());\n              it.remove();\n              log.warn(\"The broker channel expired, {} {}ms\", \n              next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);\n              this.onChannelDestroy(next.getKey(), next.getValue().getChannel());\n          }\n      }\n  }\n  {% endcodeblock %}\n\n#### Broker的消息存储\n  \n  消息存储主要和以下三个文件有关：\n  1. CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的\n>    单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，\n>    比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；\n>    当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。\n\n  2. ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，可以理解为toic的索引文件，能够提高基于topic对消息的查询效率\n>    ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。\n>    consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，\n>    具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。\n>    同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。\n  3. IndexFile：提供了一种可以通过key或时间区间来查询消息的方法\n>    Index文件的存储位置是：$HOME \\store\\index${fileName}，\n>    文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。\n\n  CommitLog是数据实际的存储和数据持久化的方式，保证了消息不会丢失。而ConsumeQueue和IndexFile则是基于CommitLog的数据建立的索引来优化消息消费和查询的效率。\n  针对三种文件，org.apache.rocketmq.store包下也有对应的同名类进行配置管理，就不在本章详细解析了。\n\n### 部署架构\n\n* NameServer：几乎无状态节点，可集群部署，节点之间无任何信息同步\n* BrokerServer：多主从结构，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer\n* Producer：完全无状态，可集群部署；与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳\n* Consumer：与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳\n\n### 小结\n  \n      本章内容是阅读RocketMQ文档后总结的一些概念和知识点。简单的看了一下NameServer和Broker的部分\n    源码。源码内容较复杂，只能一个个模块拆开慢慢看了。\n      经过本章的总结，算是对RocketMQ有了基础的认识，之后再详细的了解吧。\n\n> 下一章 [\\<RocketMQ-设计>](https://rel-fly.com/2020/06/24/RocketMq2/)","slug":"RocketMq1","published":1,"updated":"2020-08-15T12:34:04.999Z","_id":"ckdvmudyc000qnwb57rfv4bwk","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  虽然用过RocketMQ，但是对他的架构及底层原理都不甚了解，所以阅读github的文档增加一些了解，这里做一个记录。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p>  RocketMQ的架构设计主要是四部分</p>\n<ol>\n<li>NameServer：路由注册中心，主要功能是管理Broker和路由信息</li>\n<li>BrokerServer：负责消息的存储，投递，查询及高可用保证，是RocketMQ中最复杂的部分<br>为实现以上功能，他包含以下子模块：<ul>\n<li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求</li>\n<li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</li>\n<li>Store Service：提供API接口处理消息存储到物理硬盘和查询功能</li>\n<li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能</li>\n<li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询</li>\n</ul>\n</li>\n<li>Producer：消息的发布者</li>\n<li>Consumer：消息的消费者</li>\n</ol>\n<h4 id=\"NameServer对Broker的管理\"><a href=\"#NameServer对Broker的管理\" class=\"headerlink\" title=\"NameServer对Broker的管理\"></a>NameServer对Broker的管理</h4><p>  NameServer接受Broker集群的注册信息并保留作为路由信息的数据，并通过心跳检测检查Broker的存活情况。<br>  心跳包由BrokerServer发出，NameServer负责接收及更新信息，如上报时间等。<br>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            BrokerController.<span class=\"keyword\">this</span>.registerBrokerAll(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, brokerConfig.isForceRegister());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"registerBrokerAll Exception\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> * <span class=\"number\">10</span>, </span><br><span class=\"line\">Math.max(<span class=\"number\">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class=\"number\">60000</span>)), </span><br><span class=\"line\">TimeUnit.MILLISECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// command：执行线程</span></span><br><span class=\"line\"><span class=\"comment\">// initialDelay：初始化延时</span></span><br><span class=\"line\"><span class=\"comment\">// period：两次开始执行最小间隔时间</span></span><br><span class=\"line\"><span class=\"comment\">// unit：计时单位</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">\t\t                                <span class=\"keyword\">long</span> period, TimeUnit unit);</span><br></pre></td></tr></table></figure></p>\n<p>  使用ScheduledExecutorService新建一个定时任务，间隔时间范围在10s~60s之间。</p>\n<p>  然后NameServer会接收这个心跳包并保存，源码暂时没太理解，这里就不贴代码了。<br>  除了接受心跳包，NameServer还会启动一个定时任务检测BrokerServer的状态：<br>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每10秒检测一次，对应心跳包发送的最小时间间隔</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        NamesrvController.<span class=\"keyword\">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">5</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检测的具体逻辑</span></span><br><span class=\"line\"><span class=\"comment\">// private final static long BROKER_CHANNEL_EXPIRED_TIME = 1000 * 60 * 2;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scanNotActiveBroker</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class=\"keyword\">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class=\"line\">        <span class=\"comment\">// 超过2分钟没有收到心跳则删除</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> last = next.getValue().getLastUpdateTimestamp();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class=\"line\">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class=\"line\">            it.remove();</span><br><span class=\"line\">            log.warn(<span class=\"string\">\"The broker channel expired, &#123;&#125; &#123;&#125;ms\"</span>, </span><br><span class=\"line\">            next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Broker的消息存储\"><a href=\"#Broker的消息存储\" class=\"headerlink\" title=\"Broker的消息存储\"></a>Broker的消息存储</h4><p>  消息存储主要和以下三个文件有关：</p>\n<ol>\n<li><p>CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的</p>\n<blockquote>\n<p>   单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，<br>   比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；<br>   当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。</p>\n</blockquote>\n</li>\n<li><p>ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，可以理解为toic的索引文件，能够提高基于topic对消息的查询效率</p>\n<blockquote>\n<p>   ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。<br>   consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，<br>   具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。<br>   同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。</p>\n</blockquote>\n</li>\n<li><p>IndexFile：提供了一种可以通过key或时间区间来查询消息的方法</p>\n<blockquote>\n<p>   Index文件的存储位置是：$HOME \\store\\index${fileName}，<br>   文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p>\n</blockquote>\n<p>CommitLog是数据实际的存储和数据持久化的方式，保证了消息不会丢失。而ConsumeQueue和IndexFile则是基于CommitLog的数据建立的索引来优化消息消费和查询的效率。<br>针对三种文件，org.apache.rocketmq.store包下也有对应的同名类进行配置管理，就不在本章详细解析了。</p>\n</li>\n</ol>\n<h3 id=\"部署架构\"><a href=\"#部署架构\" class=\"headerlink\" title=\"部署架构\"></a>部署架构</h3><ul>\n<li>NameServer：几乎无状态节点，可集群部署，节点之间无任何信息同步</li>\n<li>BrokerServer：多主从结构，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer</li>\n<li>Producer：完全无状态，可集群部署；与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳</li>\n<li>Consumer：与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  本章内容是阅读RocketMQ文档后总结的一些概念和知识点。简单的看了一下NameServer和Broker的部分\n源码。源码内容较复杂，只能一个个模块拆开慢慢看了。\n  经过本章的总结，算是对RocketMQ有了基础的认识，之后再详细的了解吧。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/24/RocketMq2/\">&lt;RocketMQ-设计&gt;</a></p>\n</blockquote>\n","site":{"data":{}},"length":2387,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  虽然用过RocketMQ，但是对他的架构及底层原理都不甚了解，所以阅读github的文档增加一些了解，这里做一个记录。</p>","more":"<h3 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h3><p>  RocketMQ的架构设计主要是四部分</p>\n<ol>\n<li>NameServer：路由注册中心，主要功能是管理Broker和路由信息</li>\n<li>BrokerServer：负责消息的存储，投递，查询及高可用保证，是RocketMQ中最复杂的部分<br>为实现以上功能，他包含以下子模块：<ul>\n<li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求</li>\n<li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息</li>\n<li>Store Service：提供API接口处理消息存储到物理硬盘和查询功能</li>\n<li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能</li>\n<li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询</li>\n</ul>\n</li>\n<li>Producer：消息的发布者</li>\n<li>Consumer：消息的消费者</li>\n</ol>\n<h4 id=\"NameServer对Broker的管理\"><a href=\"#NameServer对Broker的管理\" class=\"headerlink\" title=\"NameServer对Broker的管理\"></a>NameServer对Broker的管理</h4><p>  NameServer接受Broker集群的注册信息并保留作为路由信息的数据，并通过心跳检测检查Broker的存活情况。<br>  心跳包由BrokerServer发出，NameServer负责接收及更新信息，如上报时间等。<br>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            BrokerController.<span class=\"keyword\">this</span>.registerBrokerAll(<span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, brokerConfig.isForceRegister());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"registerBrokerAll Exception\"</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> * <span class=\"number\">10</span>, </span><br><span class=\"line\">Math.max(<span class=\"number\">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class=\"number\">60000</span>)), </span><br><span class=\"line\">TimeUnit.MILLISECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// command：执行线程</span></span><br><span class=\"line\"><span class=\"comment\">// initialDelay：初始化延时</span></span><br><span class=\"line\"><span class=\"comment\">// period：两次开始执行最小间隔时间</span></span><br><span class=\"line\"><span class=\"comment\">// unit：计时单位</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class=\"keyword\">long</span> initialDelay,</span><br><span class=\"line\">\t\t                                <span class=\"keyword\">long</span> period, TimeUnit unit);</span><br></pre></td></tr></table></figure></p>\n<p>  使用ScheduledExecutorService新建一个定时任务，间隔时间范围在10s~60s之间。</p>\n<p>  然后NameServer会接收这个心跳包并保存，源码暂时没太理解，这里就不贴代码了。<br>  除了接受心跳包，NameServer还会启动一个定时任务检测BrokerServer的状态：<br>  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每10秒检测一次，对应心跳包发送的最小时间间隔</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        NamesrvController.<span class=\"keyword\">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;, <span class=\"number\">5</span>, <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 检测的具体逻辑</span></span><br><span class=\"line\"><span class=\"comment\">// private final static long BROKER_CHANNEL_EXPIRED_TIME = 1000 * 60 * 2;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">scanNotActiveBroker</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Entry&lt;String, BrokerLiveInfo&gt;&gt; it = <span class=\"keyword\">this</span>.brokerLiveTable.entrySet().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        Entry&lt;String, BrokerLiveInfo&gt; next = it.next();</span><br><span class=\"line\">        <span class=\"comment\">// 超过2分钟没有收到心跳则删除</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> last = next.getValue().getLastUpdateTimestamp();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((last + BROKER_CHANNEL_EXPIRED_TIME) &lt; System.currentTimeMillis()) &#123;</span><br><span class=\"line\">            RemotingUtil.closeChannel(next.getValue().getChannel());</span><br><span class=\"line\">            it.remove();</span><br><span class=\"line\">            log.warn(<span class=\"string\">\"The broker channel expired, &#123;&#125; &#123;&#125;ms\"</span>, </span><br><span class=\"line\">            next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.onChannelDestroy(next.getKey(), next.getValue().getChannel());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Broker的消息存储\"><a href=\"#Broker的消息存储\" class=\"headerlink\" title=\"Broker的消息存储\"></a>Broker的消息存储</h4><p>  消息存储主要和以下三个文件有关：</p>\n<ol>\n<li><p>CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的</p>\n<blockquote>\n<p>   单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，<br>   比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；<br>   当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件。</p>\n</blockquote>\n</li>\n<li><p>ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，可以理解为toic的索引文件，能够提高基于topic对消息的查询效率</p>\n<blockquote>\n<p>   ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。<br>   consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，<br>   具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。<br>   同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。</p>\n</blockquote>\n</li>\n<li><p>IndexFile：提供了一种可以通过key或时间区间来查询消息的方法</p>\n<blockquote>\n<p>   Index文件的存储位置是：$HOME \\store\\index${fileName}，<br>   文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p>\n</blockquote>\n<p>CommitLog是数据实际的存储和数据持久化的方式，保证了消息不会丢失。而ConsumeQueue和IndexFile则是基于CommitLog的数据建立的索引来优化消息消费和查询的效率。<br>针对三种文件，org.apache.rocketmq.store包下也有对应的同名类进行配置管理，就不在本章详细解析了。</p>\n</li>\n</ol>\n<h3 id=\"部署架构\"><a href=\"#部署架构\" class=\"headerlink\" title=\"部署架构\"></a>部署架构</h3><ul>\n<li>NameServer：几乎无状态节点，可集群部署，节点之间无任何信息同步</li>\n<li>BrokerServer：多主从结构，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer</li>\n<li>Producer：完全无状态，可集群部署；与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳</li>\n<li>Consumer：与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳</li>\n</ul>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  本章内容是阅读RocketMQ文档后总结的一些概念和知识点。简单的看了一下NameServer和Broker的部分\n源码。源码内容较复杂，只能一个个模块拆开慢慢看了。\n  经过本章的总结，算是对RocketMQ有了基础的认识，之后再详细的了解吧。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/24/RocketMq2/\">&lt;RocketMQ-设计&gt;</a></p>\n</blockquote>"},{"title":"ThinkingInJava-1","date":"2020-06-06T02:06:41.000Z","_content":"\n### 前言\n\n  准备开始阅读《Thinking in Java(第四版)》，这是Java的经典书籍，看了下目录，基本涵盖了Java编程的所有知识点。\n  本章先从第一，二章开始记录。\n<!-- more -->\n\n### 对象导论\n  \n  作为本书的第一章，对象导论围绕面向对象，简述了其思想，设计以及相关的概念。\n\n#### 对象\n\n  Java是面向对象的编程语言，那么对象，究竟如何理解与定义？\n\n  先看看面向对象语言的鼻祖-smalltakl的五个特性：\n\n     1. 万物皆对象\n     2. 程序是对象的集合，他们通过发送消息(可以理解为方法的调用)来告知彼此要做什么\n     3. 每个对象都有自己的由其他对象所构成的存储(可以理解成类的聚合和组合关系)\n     4. 每个对象都拥有类型即每个对象都是某个类(class)的一个实例\n     5. 某一特定类型的所有对象都可以接手同样的消息(继承)\n\n  关于对象，还有这么一个简单的描述：\n\n>  *对象具有状态，行为和标识   ---Booch*\n\n     1. 状态：对象拥有的内部数据(属性)\n     2. 行为：对象的方法\n     3. 标识：区分对象的唯一的地址(书中解释到这一点有些过于受限，当对象被存储在不同的机器和地址空间或者\n     \t       硬盘上时，标识就应该是内存地址之外的其他东西)\n\n  对象，是遵照一定规则对实际问题的抽象或者说描述。比如：老鹰，新建一个老鹰的类型，它的属性有性别，年龄等，它的行为有飞行，捕食等。\n  而将属性具体化后，就得到一个对象。通过执行对象的行为来完成对实际问题的描述，例如调用他的飞行方法描述飞翔的过程。\n\n#### 面向对象\n\n  面向对象的思想其实很好理解，他即是将现实事物转为程序语言去处理。抽象出现实事务的属性和行为作为一个类型，然后创建对应的对象完成对现实问题的描述(可以理解为业务逻辑的完成)。\n\n>  *这是一种更灵活更强有力的语言抽象*\n  \n  这句话应该很好的概括了面向对象的优势。\n\n  那么谈到面向对象，肯定逃不开抽象，继承，封装，多态：\n\n    1. 抽象，对事务公共属性，行为的归纳提取，创建一个类型。\n    2. 继承，基于现有抽象的新的抽象。即在保留相同属性，行为的基础上建立一个新的类型。而新类型的行为可\n       以有自己单独的实现方式，而且保留父类的属性行为基础上，还可以增加新的属性和行为\n       例如：鸟类的飞行行为，继承鸟类的老鹰和麻雀都拥有同样的飞行行为，但两者可飞行的高度不同。而对老\n       鹰可以增加对其他动物的捕食行为\n       继承一方面提高了代码的复用性，另一方面也是建立了类与类间的关系，体现了对实际事务的描述\n    3. 封装，目的是隐藏一些没必要被开发者知晓的信息，减少操作带来的bug。是为了程序安全性的一种措施。通\n       常借助代码的访问控制达成(public,private,protected)\n    4. 多态，基于继承的关系，在编译期可以将一个对象当作他的父类对待，直到运行期才确定他的类型。这种特\n       性可以提高代码的扩展性，例如：一个方法的入参可以用父类定义，而传参时选择不同的子类以完成不同的\n       逻辑处理\n\n### 一切都是对象\n\n  本书第二章从对象的创建谈起，逐步讲述了怎样构建一个简单的Java程序，包括编码规范，注释，javadoc标签等。因为是比较基础的内容，所以就摘一些我比较感兴趣的记录一下。\n\n#### 引用\n  \n  Java中对对象的控制是用引用完成的，例如\n\n> ClassA a = new ClassA();\n\n  这里初始化一个类型ClassA的对象a，a只是对象的一个引用，是一个地址值，指向堆中实际数据存储的地方。\n  这也是在参数传递的时候时常容易忽略的问题。\n  参数如果是对象，传递的是对象的引用值，那么方法内的操作就会反馈到同一对象的所有引用上。\n  参数如果是基本类型，基本类型存储的是数据本身，这时传递的就是数据的值，所以不影响方法外的基本类型的值。\n  这里举个简单的例子：\n\n{% codeblock lang:java %}\n  ClassB b = new ClassB(1);\n  int c = 1;\n  updateB(b,c);\n  \n  // b的value属性会改变，而c的值不变\n\n  public void updateB(ClassB param1, int param2){\n    param1.value = 2;\n    param2 = 2\n  }\n\n{% endcodeblock %}\n\n#### static\n  \n  static关键字是常用的关键字之一。他开辟独属于类的存储空间，不依赖于对象的创建，是所有对象公有的。\n  当类第一次加载时，static修饰的方法，属性，代码块就会随之加载，且只会加载这一次。\n  因此我们可以将一些类的初始化操作(设置默认值等)，常量，公用方法用static修饰处理，因为只会加载一次，所以一方面提升效率，另一方面保证数据不可变。\n  \n\n### 小结\n  \n      书的第一章，第二章比较基础，介绍了面向对象的思想，Java的基础概念。算是温故了一些知识点，不过对\n    面向对象及对象的一些概念的阐述感觉让自己的认知更加清晰了。\n\n> 下一章 [\\<ThinkingInJava-2>](https://rel-fly.com/2020/06/07/ThinkingInJava2/)\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/2020/06/ThinkingInJava1.md","raw":"---\ntitle: ThinkingInJava-1\ndate: 2020-06-06 10:06:41\ntags:\n- ThinkingInJava\ncategories:\n- 读书笔记\n- ThinkingInJava\n---\n\n### 前言\n\n  准备开始阅读《Thinking in Java(第四版)》，这是Java的经典书籍，看了下目录，基本涵盖了Java编程的所有知识点。\n  本章先从第一，二章开始记录。\n<!-- more -->\n\n### 对象导论\n  \n  作为本书的第一章，对象导论围绕面向对象，简述了其思想，设计以及相关的概念。\n\n#### 对象\n\n  Java是面向对象的编程语言，那么对象，究竟如何理解与定义？\n\n  先看看面向对象语言的鼻祖-smalltakl的五个特性：\n\n     1. 万物皆对象\n     2. 程序是对象的集合，他们通过发送消息(可以理解为方法的调用)来告知彼此要做什么\n     3. 每个对象都有自己的由其他对象所构成的存储(可以理解成类的聚合和组合关系)\n     4. 每个对象都拥有类型即每个对象都是某个类(class)的一个实例\n     5. 某一特定类型的所有对象都可以接手同样的消息(继承)\n\n  关于对象，还有这么一个简单的描述：\n\n>  *对象具有状态，行为和标识   ---Booch*\n\n     1. 状态：对象拥有的内部数据(属性)\n     2. 行为：对象的方法\n     3. 标识：区分对象的唯一的地址(书中解释到这一点有些过于受限，当对象被存储在不同的机器和地址空间或者\n     \t       硬盘上时，标识就应该是内存地址之外的其他东西)\n\n  对象，是遵照一定规则对实际问题的抽象或者说描述。比如：老鹰，新建一个老鹰的类型，它的属性有性别，年龄等，它的行为有飞行，捕食等。\n  而将属性具体化后，就得到一个对象。通过执行对象的行为来完成对实际问题的描述，例如调用他的飞行方法描述飞翔的过程。\n\n#### 面向对象\n\n  面向对象的思想其实很好理解，他即是将现实事物转为程序语言去处理。抽象出现实事务的属性和行为作为一个类型，然后创建对应的对象完成对现实问题的描述(可以理解为业务逻辑的完成)。\n\n>  *这是一种更灵活更强有力的语言抽象*\n  \n  这句话应该很好的概括了面向对象的优势。\n\n  那么谈到面向对象，肯定逃不开抽象，继承，封装，多态：\n\n    1. 抽象，对事务公共属性，行为的归纳提取，创建一个类型。\n    2. 继承，基于现有抽象的新的抽象。即在保留相同属性，行为的基础上建立一个新的类型。而新类型的行为可\n       以有自己单独的实现方式，而且保留父类的属性行为基础上，还可以增加新的属性和行为\n       例如：鸟类的飞行行为，继承鸟类的老鹰和麻雀都拥有同样的飞行行为，但两者可飞行的高度不同。而对老\n       鹰可以增加对其他动物的捕食行为\n       继承一方面提高了代码的复用性，另一方面也是建立了类与类间的关系，体现了对实际事务的描述\n    3. 封装，目的是隐藏一些没必要被开发者知晓的信息，减少操作带来的bug。是为了程序安全性的一种措施。通\n       常借助代码的访问控制达成(public,private,protected)\n    4. 多态，基于继承的关系，在编译期可以将一个对象当作他的父类对待，直到运行期才确定他的类型。这种特\n       性可以提高代码的扩展性，例如：一个方法的入参可以用父类定义，而传参时选择不同的子类以完成不同的\n       逻辑处理\n\n### 一切都是对象\n\n  本书第二章从对象的创建谈起，逐步讲述了怎样构建一个简单的Java程序，包括编码规范，注释，javadoc标签等。因为是比较基础的内容，所以就摘一些我比较感兴趣的记录一下。\n\n#### 引用\n  \n  Java中对对象的控制是用引用完成的，例如\n\n> ClassA a = new ClassA();\n\n  这里初始化一个类型ClassA的对象a，a只是对象的一个引用，是一个地址值，指向堆中实际数据存储的地方。\n  这也是在参数传递的时候时常容易忽略的问题。\n  参数如果是对象，传递的是对象的引用值，那么方法内的操作就会反馈到同一对象的所有引用上。\n  参数如果是基本类型，基本类型存储的是数据本身，这时传递的就是数据的值，所以不影响方法外的基本类型的值。\n  这里举个简单的例子：\n\n{% codeblock lang:java %}\n  ClassB b = new ClassB(1);\n  int c = 1;\n  updateB(b,c);\n  \n  // b的value属性会改变，而c的值不变\n\n  public void updateB(ClassB param1, int param2){\n    param1.value = 2;\n    param2 = 2\n  }\n\n{% endcodeblock %}\n\n#### static\n  \n  static关键字是常用的关键字之一。他开辟独属于类的存储空间，不依赖于对象的创建，是所有对象公有的。\n  当类第一次加载时，static修饰的方法，属性，代码块就会随之加载，且只会加载这一次。\n  因此我们可以将一些类的初始化操作(设置默认值等)，常量，公用方法用static修饰处理，因为只会加载一次，所以一方面提升效率，另一方面保证数据不可变。\n  \n\n### 小结\n  \n      书的第一章，第二章比较基础，介绍了面向对象的思想，Java的基础概念。算是温故了一些知识点，不过对\n    面向对象及对象的一些概念的阐述感觉让自己的认知更加清晰了。\n\n> 下一章 [\\<ThinkingInJava-2>](https://rel-fly.com/2020/06/07/ThinkingInJava2/)\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"ThinkingInJava1","published":1,"updated":"2020-08-15T12:34:04.999Z","_id":"ckdvmudyd000vnwb51nqh13na","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  准备开始阅读《Thinking in Java(第四版)》，这是Java的经典书籍，看了下目录，基本涵盖了Java编程的所有知识点。<br>  本章先从第一，二章开始记录。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"对象导论\"><a href=\"#对象导论\" class=\"headerlink\" title=\"对象导论\"></a>对象导论</h3><p>  作为本书的第一章，对象导论围绕面向对象，简述了其思想，设计以及相关的概念。</p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>  Java是面向对象的编程语言，那么对象，究竟如何理解与定义？</p>\n<p>  先看看面向对象语言的鼻祖-smalltakl的五个特性：</p>\n<pre><code>1. 万物皆对象\n2. 程序是对象的集合，他们通过发送消息(可以理解为方法的调用)来告知彼此要做什么\n3. 每个对象都有自己的由其他对象所构成的存储(可以理解成类的聚合和组合关系)\n4. 每个对象都拥有类型即每个对象都是某个类(class)的一个实例\n5. 某一特定类型的所有对象都可以接手同样的消息(继承)</code></pre><p>  关于对象，还有这么一个简单的描述：</p>\n<blockquote>\n<p> <em>对象具有状态，行为和标识   —Booch</em></p>\n</blockquote>\n<pre><code>1. 状态：对象拥有的内部数据(属性)\n2. 行为：对象的方法\n3. 标识：区分对象的唯一的地址(书中解释到这一点有些过于受限，当对象被存储在不同的机器和地址空间或者\n           硬盘上时，标识就应该是内存地址之外的其他东西)</code></pre><p>  对象，是遵照一定规则对实际问题的抽象或者说描述。比如：老鹰，新建一个老鹰的类型，它的属性有性别，年龄等，它的行为有飞行，捕食等。<br>  而将属性具体化后，就得到一个对象。通过执行对象的行为来完成对实际问题的描述，例如调用他的飞行方法描述飞翔的过程。</p>\n<h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>  面向对象的思想其实很好理解，他即是将现实事物转为程序语言去处理。抽象出现实事务的属性和行为作为一个类型，然后创建对应的对象完成对现实问题的描述(可以理解为业务逻辑的完成)。</p>\n<blockquote>\n<p> <em>这是一种更灵活更强有力的语言抽象</em></p>\n</blockquote>\n<p>  这句话应该很好的概括了面向对象的优势。</p>\n<p>  那么谈到面向对象，肯定逃不开抽象，继承，封装，多态：</p>\n<pre><code>1. 抽象，对事务公共属性，行为的归纳提取，创建一个类型。\n2. 继承，基于现有抽象的新的抽象。即在保留相同属性，行为的基础上建立一个新的类型。而新类型的行为可\n   以有自己单独的实现方式，而且保留父类的属性行为基础上，还可以增加新的属性和行为\n   例如：鸟类的飞行行为，继承鸟类的老鹰和麻雀都拥有同样的飞行行为，但两者可飞行的高度不同。而对老\n   鹰可以增加对其他动物的捕食行为\n   继承一方面提高了代码的复用性，另一方面也是建立了类与类间的关系，体现了对实际事务的描述\n3. 封装，目的是隐藏一些没必要被开发者知晓的信息，减少操作带来的bug。是为了程序安全性的一种措施。通\n   常借助代码的访问控制达成(public,private,protected)\n4. 多态，基于继承的关系，在编译期可以将一个对象当作他的父类对待，直到运行期才确定他的类型。这种特\n   性可以提高代码的扩展性，例如：一个方法的入参可以用父类定义，而传参时选择不同的子类以完成不同的\n   逻辑处理</code></pre><h3 id=\"一切都是对象\"><a href=\"#一切都是对象\" class=\"headerlink\" title=\"一切都是对象\"></a>一切都是对象</h3><p>  本书第二章从对象的创建谈起，逐步讲述了怎样构建一个简单的Java程序，包括编码规范，注释，javadoc标签等。因为是比较基础的内容，所以就摘一些我比较感兴趣的记录一下。</p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>  Java中对对象的控制是用引用完成的，例如</p>\n<blockquote>\n<p>ClassA a = new ClassA();</p>\n</blockquote>\n<p>  这里初始化一个类型ClassA的对象a，a只是对象的一个引用，是一个地址值，指向堆中实际数据存储的地方。<br>  这也是在参数传递的时候时常容易忽略的问题。<br>  参数如果是对象，传递的是对象的引用值，那么方法内的操作就会反馈到同一对象的所有引用上。<br>  参数如果是基本类型，基本类型存储的是数据本身，这时传递的就是数据的值，所以不影响方法外的基本类型的值。<br>  这里举个简单的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassB b = <span class=\"keyword\">new</span> ClassB(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\">updateB(b,c);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b的value属性会改变，而c的值不变</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateB</span><span class=\"params\">(ClassB param1, <span class=\"keyword\">int</span> param2)</span></span>&#123;</span><br><span class=\"line\">  param1.value = <span class=\"number\">2</span>;</span><br><span class=\"line\">  param2 = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h4><p>  static关键字是常用的关键字之一。他开辟独属于类的存储空间，不依赖于对象的创建，是所有对象公有的。<br>  当类第一次加载时，static修饰的方法，属性，代码块就会随之加载，且只会加载这一次。<br>  因此我们可以将一些类的初始化操作(设置默认值等)，常量，公用方法用static修饰处理，因为只会加载一次，所以一方面提升效率，另一方面保证数据不可变。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  书的第一章，第二章比较基础，介绍了面向对象的思想，Java的基础概念。算是温故了一些知识点，不过对\n面向对象及对象的一些概念的阐述感觉让自己的认知更加清晰了。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/07/ThinkingInJava2/\">&lt;ThinkingInJava-2&gt;</a></p>\n</blockquote>\n","site":{"data":{}},"length":1736,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  准备开始阅读《Thinking in Java(第四版)》，这是Java的经典书籍，看了下目录，基本涵盖了Java编程的所有知识点。<br>  本章先从第一，二章开始记录。</p>","more":"<h3 id=\"对象导论\"><a href=\"#对象导论\" class=\"headerlink\" title=\"对象导论\"></a>对象导论</h3><p>  作为本书的第一章，对象导论围绕面向对象，简述了其思想，设计以及相关的概念。</p>\n<h4 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h4><p>  Java是面向对象的编程语言，那么对象，究竟如何理解与定义？</p>\n<p>  先看看面向对象语言的鼻祖-smalltakl的五个特性：</p>\n<pre><code>1. 万物皆对象\n2. 程序是对象的集合，他们通过发送消息(可以理解为方法的调用)来告知彼此要做什么\n3. 每个对象都有自己的由其他对象所构成的存储(可以理解成类的聚合和组合关系)\n4. 每个对象都拥有类型即每个对象都是某个类(class)的一个实例\n5. 某一特定类型的所有对象都可以接手同样的消息(继承)</code></pre><p>  关于对象，还有这么一个简单的描述：</p>\n<blockquote>\n<p> <em>对象具有状态，行为和标识   —Booch</em></p>\n</blockquote>\n<pre><code>1. 状态：对象拥有的内部数据(属性)\n2. 行为：对象的方法\n3. 标识：区分对象的唯一的地址(书中解释到这一点有些过于受限，当对象被存储在不同的机器和地址空间或者\n           硬盘上时，标识就应该是内存地址之外的其他东西)</code></pre><p>  对象，是遵照一定规则对实际问题的抽象或者说描述。比如：老鹰，新建一个老鹰的类型，它的属性有性别，年龄等，它的行为有飞行，捕食等。<br>  而将属性具体化后，就得到一个对象。通过执行对象的行为来完成对实际问题的描述，例如调用他的飞行方法描述飞翔的过程。</p>\n<h4 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h4><p>  面向对象的思想其实很好理解，他即是将现实事物转为程序语言去处理。抽象出现实事务的属性和行为作为一个类型，然后创建对应的对象完成对现实问题的描述(可以理解为业务逻辑的完成)。</p>\n<blockquote>\n<p> <em>这是一种更灵活更强有力的语言抽象</em></p>\n</blockquote>\n<p>  这句话应该很好的概括了面向对象的优势。</p>\n<p>  那么谈到面向对象，肯定逃不开抽象，继承，封装，多态：</p>\n<pre><code>1. 抽象，对事务公共属性，行为的归纳提取，创建一个类型。\n2. 继承，基于现有抽象的新的抽象。即在保留相同属性，行为的基础上建立一个新的类型。而新类型的行为可\n   以有自己单独的实现方式，而且保留父类的属性行为基础上，还可以增加新的属性和行为\n   例如：鸟类的飞行行为，继承鸟类的老鹰和麻雀都拥有同样的飞行行为，但两者可飞行的高度不同。而对老\n   鹰可以增加对其他动物的捕食行为\n   继承一方面提高了代码的复用性，另一方面也是建立了类与类间的关系，体现了对实际事务的描述\n3. 封装，目的是隐藏一些没必要被开发者知晓的信息，减少操作带来的bug。是为了程序安全性的一种措施。通\n   常借助代码的访问控制达成(public,private,protected)\n4. 多态，基于继承的关系，在编译期可以将一个对象当作他的父类对待，直到运行期才确定他的类型。这种特\n   性可以提高代码的扩展性，例如：一个方法的入参可以用父类定义，而传参时选择不同的子类以完成不同的\n   逻辑处理</code></pre><h3 id=\"一切都是对象\"><a href=\"#一切都是对象\" class=\"headerlink\" title=\"一切都是对象\"></a>一切都是对象</h3><p>  本书第二章从对象的创建谈起，逐步讲述了怎样构建一个简单的Java程序，包括编码规范，注释，javadoc标签等。因为是比较基础的内容，所以就摘一些我比较感兴趣的记录一下。</p>\n<h4 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h4><p>  Java中对对象的控制是用引用完成的，例如</p>\n<blockquote>\n<p>ClassA a = new ClassA();</p>\n</blockquote>\n<p>  这里初始化一个类型ClassA的对象a，a只是对象的一个引用，是一个地址值，指向堆中实际数据存储的地方。<br>  这也是在参数传递的时候时常容易忽略的问题。<br>  参数如果是对象，传递的是对象的引用值，那么方法内的操作就会反馈到同一对象的所有引用上。<br>  参数如果是基本类型，基本类型存储的是数据本身，这时传递的就是数据的值，所以不影响方法外的基本类型的值。<br>  这里举个简单的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassB b = <span class=\"keyword\">new</span> ClassB(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">int</span> c = <span class=\"number\">1</span>;</span><br><span class=\"line\">updateB(b,c);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b的value属性会改变，而c的值不变</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateB</span><span class=\"params\">(ClassB param1, <span class=\"keyword\">int</span> param2)</span></span>&#123;</span><br><span class=\"line\">  param1.value = <span class=\"number\">2</span>;</span><br><span class=\"line\">  param2 = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h4><p>  static关键字是常用的关键字之一。他开辟独属于类的存储空间，不依赖于对象的创建，是所有对象公有的。<br>  当类第一次加载时，static修饰的方法，属性，代码块就会随之加载，且只会加载这一次。<br>  因此我们可以将一些类的初始化操作(设置默认值等)，常量，公用方法用static修饰处理，因为只会加载一次，所以一方面提升效率，另一方面保证数据不可变。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  书的第一章，第二章比较基础，介绍了面向对象的思想，Java的基础概念。算是温故了一些知识点，不过对\n面向对象及对象的一些概念的阐述感觉让自己的认知更加清晰了。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/07/ThinkingInJava2/\">&lt;ThinkingInJava-2&gt;</a></p>\n</blockquote>"},{"title":"ThinkingInJava-3","date":"2020-06-07T07:37:47.000Z","_content":"\n### 前言\n  \n  来到本书第五，六章，在介绍完Java操作符及一些关键字后，开始介绍一些机制。如：类的初始化，垃圾回收清理，访问权限等。这些都是有助于我们更好了解代码执行过程的知识点。\n<!-- more -->\n\n### 初始化与清理\n  \n  本书的第五章，主要介绍了构造器，方法的重载，类初始化的顺序及对象的回收等。关于对象的回收想放到Java虚拟机的总结中，所以这里没有记录。主要就方法重载和类初始化顺序记录一下。\n\n#### 涉及基本类型的重载\n  \n  方法的重载是多个方法名一样，参数列表不一样的方法。参数列表不一样包括类型和顺序，例如\n\n{% codeblock lang:java %}\nvoid method(int a, String b) {\n // ·····\n}\nint method(String a, int b) {\n // ·····\n}\n{% endcodeblock %}\n\n  而如果涉及基本类型的重载，例如：\n\n{% codeblock lang:java %}\n  method(5);// method1\n  method(5f);// method1\n  method(5d);// method2\n  method('1');// method1\n  // method1\n  public void method(float f) {\n      System.out.println(\"float\");\n  }\n  // method2\n  public void method(double d) {\n      System.out.println(\"double\");\n  }\n{% endcodeblock %}\n  \n      当入参为基本类型时，没指定具体类型的情况下，常量数值会被当作int处理。而如果这时没有对应int类型入\n    参的方法，就会提升数据类型(例如这里的method(5)就提升为float类型)。而char类型则是当没有对应类型的\n    方法时，被当作int处理。\n\n#### 初始化的顺序\n  \n  第二章中有提到static关键字。而在一个类中，如果有静态代码块等，其初始化顺序是怎样的呢？\n\n{% codeblock lang:java %}\npublic class ClassParent {\n    private static int a;\n\n    static {\n        a = 1;\n        System.out.println(\"静态代码块\");\n    }\n\n    {\n        System.out.println(\"代码块\");\n    }\n\n    public static void method() {\n        System.out.println(\"静态方法\");\n    }\n\n    ClassParent() {\n        System.out.println(\"构造方法\");\n    }\n}\n\npublic class ClassChild extends ClassParent{\n    private static int b;\n\n    static{\n        b = 1;\n        System.out.println(\"child-静态代码块\");\n    }\n\n    {\n        System.out.println(\"child-代码块\");\n    }\n \n    public static void function() {\n        System.out.println(\"child-静态方法\");\n    }\n\n    ClassChild() {\n        System.out.println(\"child-构造方法\");\n    }\n}\n{% endcodeblock %}\n\n   如上两个类，当创建类的实例或者直接调用类的静态方法，他的初始化顺序如下：\n\n{% codeblock lang:java %}\nClassChild cc = new ClassChild();\n// 输出为：\n//静态代码块\n//child-静态代码块\n//代码块\n//构造方法\n//child-代码块\n//child-构造方法\n\nClassChild.function();\n// 输出为：\n//静态代码块\n//child-静态代码块\n//child-静态方法\n{% endcodeblock %}\n\n      可以看出，静态代码块总是优先加载，在有父类的情况下，也是按照父类->子类的顺序先把静态代码块加载\n    完。然后才是加载各自的代码块和构造方法。而直接调用静态方法，也会先初始化父类及子类的静态代码块。但\n    因为没有涉及类的实例化，所以不会有代码块和构造方法的初始化。\n\n### 访问权限控制\n  \n  本书第六章，主要介绍Java访问权限的相关知识。\n\n#### 访问权限的类型\n  \n    1. public：接口访问权限，对public修饰的变量，方法的访问没有限制\n    2. 默认访问：包访问权限，不加任何修饰词的话，默认是同一个包下才有访问权限\n    3. protected：继承访问权限，首先会提供包访问权限，其次，如果子类继承了某个类，那么可以不在同\n                  一个包下也能访问父类中用protected修饰的资源\n    4. private：类访问权限，只能在本类中被访问\n\n{% img  /image/ThinkingInJava/ThinkingInJava3-1.png  '\"访问权限\"' %}\n\n### 小结\n\n      这两章主要介绍了Java类相关的知识点。类的初始化，构造方法的一些注意点。基础类型参数的重载方法\n    是以前没注意到的，所以记录了下。类的初始化顺序，也是相对重要的知识点，静态代码块的优先级是最高\n    的，所以也常用作一个默认值设置等初始化操作。\n\n> 下一章 [\\<ThinkingInJava-4>](https://rel-fly.com/2020/06/09/ThinkingInJava4/)","source":"_posts/2020/06/ThinkingInJava3.md","raw":"---\ntitle: ThinkingInJava-3\ndate: 2020-06-07 15:37:47\ntags:\n- ThinkingInJava\ncategories:\n- 读书笔记\n- ThinkingInJava\n---\n\n### 前言\n  \n  来到本书第五，六章，在介绍完Java操作符及一些关键字后，开始介绍一些机制。如：类的初始化，垃圾回收清理，访问权限等。这些都是有助于我们更好了解代码执行过程的知识点。\n<!-- more -->\n\n### 初始化与清理\n  \n  本书的第五章，主要介绍了构造器，方法的重载，类初始化的顺序及对象的回收等。关于对象的回收想放到Java虚拟机的总结中，所以这里没有记录。主要就方法重载和类初始化顺序记录一下。\n\n#### 涉及基本类型的重载\n  \n  方法的重载是多个方法名一样，参数列表不一样的方法。参数列表不一样包括类型和顺序，例如\n\n{% codeblock lang:java %}\nvoid method(int a, String b) {\n // ·····\n}\nint method(String a, int b) {\n // ·····\n}\n{% endcodeblock %}\n\n  而如果涉及基本类型的重载，例如：\n\n{% codeblock lang:java %}\n  method(5);// method1\n  method(5f);// method1\n  method(5d);// method2\n  method('1');// method1\n  // method1\n  public void method(float f) {\n      System.out.println(\"float\");\n  }\n  // method2\n  public void method(double d) {\n      System.out.println(\"double\");\n  }\n{% endcodeblock %}\n  \n      当入参为基本类型时，没指定具体类型的情况下，常量数值会被当作int处理。而如果这时没有对应int类型入\n    参的方法，就会提升数据类型(例如这里的method(5)就提升为float类型)。而char类型则是当没有对应类型的\n    方法时，被当作int处理。\n\n#### 初始化的顺序\n  \n  第二章中有提到static关键字。而在一个类中，如果有静态代码块等，其初始化顺序是怎样的呢？\n\n{% codeblock lang:java %}\npublic class ClassParent {\n    private static int a;\n\n    static {\n        a = 1;\n        System.out.println(\"静态代码块\");\n    }\n\n    {\n        System.out.println(\"代码块\");\n    }\n\n    public static void method() {\n        System.out.println(\"静态方法\");\n    }\n\n    ClassParent() {\n        System.out.println(\"构造方法\");\n    }\n}\n\npublic class ClassChild extends ClassParent{\n    private static int b;\n\n    static{\n        b = 1;\n        System.out.println(\"child-静态代码块\");\n    }\n\n    {\n        System.out.println(\"child-代码块\");\n    }\n \n    public static void function() {\n        System.out.println(\"child-静态方法\");\n    }\n\n    ClassChild() {\n        System.out.println(\"child-构造方法\");\n    }\n}\n{% endcodeblock %}\n\n   如上两个类，当创建类的实例或者直接调用类的静态方法，他的初始化顺序如下：\n\n{% codeblock lang:java %}\nClassChild cc = new ClassChild();\n// 输出为：\n//静态代码块\n//child-静态代码块\n//代码块\n//构造方法\n//child-代码块\n//child-构造方法\n\nClassChild.function();\n// 输出为：\n//静态代码块\n//child-静态代码块\n//child-静态方法\n{% endcodeblock %}\n\n      可以看出，静态代码块总是优先加载，在有父类的情况下，也是按照父类->子类的顺序先把静态代码块加载\n    完。然后才是加载各自的代码块和构造方法。而直接调用静态方法，也会先初始化父类及子类的静态代码块。但\n    因为没有涉及类的实例化，所以不会有代码块和构造方法的初始化。\n\n### 访问权限控制\n  \n  本书第六章，主要介绍Java访问权限的相关知识。\n\n#### 访问权限的类型\n  \n    1. public：接口访问权限，对public修饰的变量，方法的访问没有限制\n    2. 默认访问：包访问权限，不加任何修饰词的话，默认是同一个包下才有访问权限\n    3. protected：继承访问权限，首先会提供包访问权限，其次，如果子类继承了某个类，那么可以不在同\n                  一个包下也能访问父类中用protected修饰的资源\n    4. private：类访问权限，只能在本类中被访问\n\n{% img  /image/ThinkingInJava/ThinkingInJava3-1.png  '\"访问权限\"' %}\n\n### 小结\n\n      这两章主要介绍了Java类相关的知识点。类的初始化，构造方法的一些注意点。基础类型参数的重载方法\n    是以前没注意到的，所以记录了下。类的初始化顺序，也是相对重要的知识点，静态代码块的优先级是最高\n    的，所以也常用作一个默认值设置等初始化操作。\n\n> 下一章 [\\<ThinkingInJava-4>](https://rel-fly.com/2020/06/09/ThinkingInJava4/)","slug":"ThinkingInJava3","published":1,"updated":"2020-08-15T12:34:05.000Z","_id":"ckdvmudye000xnwb5h3un47mw","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  来到本书第五，六章，在介绍完Java操作符及一些关键字后，开始介绍一些机制。如：类的初始化，垃圾回收清理，访问权限等。这些都是有助于我们更好了解代码执行过程的知识点。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"初始化与清理\"><a href=\"#初始化与清理\" class=\"headerlink\" title=\"初始化与清理\"></a>初始化与清理</h3><p>  本书的第五章，主要介绍了构造器，方法的重载，类初始化的顺序及对象的回收等。关于对象的回收想放到Java虚拟机的总结中，所以这里没有记录。主要就方法重载和类初始化顺序记录一下。</p>\n<h4 id=\"涉及基本类型的重载\"><a href=\"#涉及基本类型的重载\" class=\"headerlink\" title=\"涉及基本类型的重载\"></a>涉及基本类型的重载</h4><p>  方法的重载是多个方法名一样，参数列表不一样的方法。参数列表不一样包括类型和顺序，例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> a, String b)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// ·····</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">method</span><span class=\"params\">(String a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// ·····</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  而如果涉及基本类型的重载，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">method(<span class=\"number\">5</span>);<span class=\"comment\">// method1</span></span><br><span class=\"line\">method(<span class=\"number\">5f</span>);<span class=\"comment\">// method1</span></span><br><span class=\"line\">method(<span class=\"number\">5</span>d);<span class=\"comment\">// method2</span></span><br><span class=\"line\">method(<span class=\"string\">'1'</span>);<span class=\"comment\">// method1</span></span><br><span class=\"line\"><span class=\"comment\">// method1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">float</span> f)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"float\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// method2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">double</span> d)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"double\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>  当入参为基本类型时，没指定具体类型的情况下，常量数值会被当作int处理。而如果这时没有对应int类型入\n参的方法，就会提升数据类型(例如这里的method(5)就提升为float类型)。而char类型则是当没有对应类型的\n方法时，被当作int处理。</code></pre><h4 id=\"初始化的顺序\"><a href=\"#初始化的顺序\" class=\"headerlink\" title=\"初始化的顺序\"></a>初始化的顺序</h4><p>  第二章中有提到static关键字。而在一个类中，如果有静态代码块等，其初始化顺序是怎样的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"静态方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ClassParent() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassChild</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassParent</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        b = <span class=\"number\">1</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"child-静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"child-代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"child-静态方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ClassChild() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"child-构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   如上两个类，当创建类的实例或者直接调用类的静态方法，他的初始化顺序如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassChild cc = <span class=\"keyword\">new</span> ClassChild();</span><br><span class=\"line\"><span class=\"comment\">// 输出为：</span></span><br><span class=\"line\"><span class=\"comment\">//静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">//child-静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">//代码块</span></span><br><span class=\"line\"><span class=\"comment\">//构造方法</span></span><br><span class=\"line\"><span class=\"comment\">//child-代码块</span></span><br><span class=\"line\"><span class=\"comment\">//child-构造方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">ClassChild.function();</span><br><span class=\"line\"><span class=\"comment\">// 输出为：</span></span><br><span class=\"line\"><span class=\"comment\">//静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">//child-静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">//child-静态方法</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>  可以看出，静态代码块总是优先加载，在有父类的情况下，也是按照父类-&gt;子类的顺序先把静态代码块加载\n完。然后才是加载各自的代码块和构造方法。而直接调用静态方法，也会先初始化父类及子类的静态代码块。但\n因为没有涉及类的实例化，所以不会有代码块和构造方法的初始化。</code></pre><h3 id=\"访问权限控制\"><a href=\"#访问权限控制\" class=\"headerlink\" title=\"访问权限控制\"></a>访问权限控制</h3><p>  本书第六章，主要介绍Java访问权限的相关知识。</p>\n<h4 id=\"访问权限的类型\"><a href=\"#访问权限的类型\" class=\"headerlink\" title=\"访问权限的类型\"></a>访问权限的类型</h4><pre><code>1. public：接口访问权限，对public修饰的变量，方法的访问没有限制\n2. 默认访问：包访问权限，不加任何修饰词的话，默认是同一个包下才有访问权限\n3. protected：继承访问权限，首先会提供包访问权限，其次，如果子类继承了某个类，那么可以不在同\n              一个包下也能访问父类中用protected修饰的资源\n4. private：类访问权限，只能在本类中被访问</code></pre><img src=\"/image/ThinkingInJava/ThinkingInJava3-1.png\" class=\"\" title=\"访问权限\">\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  这两章主要介绍了Java类相关的知识点。类的初始化，构造方法的一些注意点。基础类型参数的重载方法\n是以前没注意到的，所以记录了下。类的初始化顺序，也是相对重要的知识点，静态代码块的优先级是最高\n的，所以也常用作一个默认值设置等初始化操作。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/09/ThinkingInJava4/\">&lt;ThinkingInJava-4&gt;</a></p>\n</blockquote>\n","site":{"data":{}},"length":945,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  来到本书第五，六章，在介绍完Java操作符及一些关键字后，开始介绍一些机制。如：类的初始化，垃圾回收清理，访问权限等。这些都是有助于我们更好了解代码执行过程的知识点。</p>","more":"<h3 id=\"初始化与清理\"><a href=\"#初始化与清理\" class=\"headerlink\" title=\"初始化与清理\"></a>初始化与清理</h3><p>  本书的第五章，主要介绍了构造器，方法的重载，类初始化的顺序及对象的回收等。关于对象的回收想放到Java虚拟机的总结中，所以这里没有记录。主要就方法重载和类初始化顺序记录一下。</p>\n<h4 id=\"涉及基本类型的重载\"><a href=\"#涉及基本类型的重载\" class=\"headerlink\" title=\"涉及基本类型的重载\"></a>涉及基本类型的重载</h4><p>  方法的重载是多个方法名一样，参数列表不一样的方法。参数列表不一样包括类型和顺序，例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> a, String b)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// ·····</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">method</span><span class=\"params\">(String a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// ·····</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  而如果涉及基本类型的重载，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">method(<span class=\"number\">5</span>);<span class=\"comment\">// method1</span></span><br><span class=\"line\">method(<span class=\"number\">5f</span>);<span class=\"comment\">// method1</span></span><br><span class=\"line\">method(<span class=\"number\">5</span>d);<span class=\"comment\">// method2</span></span><br><span class=\"line\">method(<span class=\"string\">'1'</span>);<span class=\"comment\">// method1</span></span><br><span class=\"line\"><span class=\"comment\">// method1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">float</span> f)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"float\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// method2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">double</span> d)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"double\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>  当入参为基本类型时，没指定具体类型的情况下，常量数值会被当作int处理。而如果这时没有对应int类型入\n参的方法，就会提升数据类型(例如这里的method(5)就提升为float类型)。而char类型则是当没有对应类型的\n方法时，被当作int处理。</code></pre><h4 id=\"初始化的顺序\"><a href=\"#初始化的顺序\" class=\"headerlink\" title=\"初始化的顺序\"></a>初始化的顺序</h4><p>  第二章中有提到static关键字。而在一个类中，如果有静态代码块等，其初始化顺序是怎样的呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassParent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        a = <span class=\"number\">1</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"静态方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ClassParent() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassChild</span> <span class=\"keyword\">extends</span> <span class=\"title\">ClassParent</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">        b = <span class=\"number\">1</span>;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"child-静态代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"child-代码块\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"child-静态方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ClassChild() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"child-构造方法\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   如上两个类，当创建类的实例或者直接调用类的静态方法，他的初始化顺序如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ClassChild cc = <span class=\"keyword\">new</span> ClassChild();</span><br><span class=\"line\"><span class=\"comment\">// 输出为：</span></span><br><span class=\"line\"><span class=\"comment\">//静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">//child-静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">//代码块</span></span><br><span class=\"line\"><span class=\"comment\">//构造方法</span></span><br><span class=\"line\"><span class=\"comment\">//child-代码块</span></span><br><span class=\"line\"><span class=\"comment\">//child-构造方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">ClassChild.function();</span><br><span class=\"line\"><span class=\"comment\">// 输出为：</span></span><br><span class=\"line\"><span class=\"comment\">//静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">//child-静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">//child-静态方法</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>  可以看出，静态代码块总是优先加载，在有父类的情况下，也是按照父类-&gt;子类的顺序先把静态代码块加载\n完。然后才是加载各自的代码块和构造方法。而直接调用静态方法，也会先初始化父类及子类的静态代码块。但\n因为没有涉及类的实例化，所以不会有代码块和构造方法的初始化。</code></pre><h3 id=\"访问权限控制\"><a href=\"#访问权限控制\" class=\"headerlink\" title=\"访问权限控制\"></a>访问权限控制</h3><p>  本书第六章，主要介绍Java访问权限的相关知识。</p>\n<h4 id=\"访问权限的类型\"><a href=\"#访问权限的类型\" class=\"headerlink\" title=\"访问权限的类型\"></a>访问权限的类型</h4><pre><code>1. public：接口访问权限，对public修饰的变量，方法的访问没有限制\n2. 默认访问：包访问权限，不加任何修饰词的话，默认是同一个包下才有访问权限\n3. protected：继承访问权限，首先会提供包访问权限，其次，如果子类继承了某个类，那么可以不在同\n              一个包下也能访问父类中用protected修饰的资源\n4. private：类访问权限，只能在本类中被访问</code></pre><img src=\"/image/ThinkingInJava/ThinkingInJava3-1.png\" class=\"\" title=\"访问权限\">\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  这两章主要介绍了Java类相关的知识点。类的初始化，构造方法的一些注意点。基础类型参数的重载方法\n是以前没注意到的，所以记录了下。类的初始化顺序，也是相对重要的知识点，静态代码块的优先级是最高\n的，所以也常用作一个默认值设置等初始化操作。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/09/ThinkingInJava4/\">&lt;ThinkingInJava-4&gt;</a></p>\n</blockquote>"},{"title":"ThinkingInJava-4","date":"2020-06-09T08:03:50.000Z","_content":"\n### 前言\n  \n  类的关系，用来概括七，八两章的内容应该足以。从第七章的继承，组合到第八章的多态。Java中能够为类设计的关系结构初步展现出来。\n<!-- more -->\n\n### 复用类\n\n  本书的第七章，主要内容是关于类的复用。\n  类的复用能够减少代码的重复，并且使得整体更具结构化，而不是杂乱无章。\n  复用主要依靠类的组合和继承两种方式，组合倾向于使用现有类的功能，继承则是完整复用了现有类的结构(属性，方法等)。\n\n#### 组合和继承\n\n  组合是将一个类的实例作为自己的属性，然后通过这个实例复用他的一些方法。\n  继承则可以理解为直接复用了父类的结构，在此基础上做了扩展(当然，也可以重写父类的方法)。\n\n  对于复用类的初始化两者的区别：\n\n    组合关系：复用类作为一个属性，对于他的初始化我们可以选择在定义时初始化，在构造方法中初始化，或者在\n             使用到的时候才去完成初始化。\n    继承关系：在子类初始化之前完成父类的初始化。并且属于一种隐式操作，从外表来看，我们只是初始化了一个\n             子类的实例。其实这个子类实例内部包含了一个父类实例。\n  \n  基于初始化的区别可以看出，组合更像是为复用类预留了一个位置，我需要用你的时候就会初始化。而继承，父类的实例成了子类实例的一个影子，相互关系更加紧密。\n  当然，继承更重要的一个作用是多态。子类对象可以当作他的父类处理，即*向上转型*。所以如果不是必须使用向上转型，还是推荐使用组合。\n\n#### 代理\n   \n  代理属于继承和组合的中间选择，结构上和组合一样，将复用类当作自己的属性，但方法与复用类一致，处理则是直接调用了复用类的方法。\n  例如：\n{% codeblock lang:java %}\npublic class ClassChild {\n    private static ClassOther co;\n\n    public void add(){\n        co.add();\n    }\n\n    public void minus(){\n        co.minus();\n    }\n}\n{% endcodeblock %}\n  \n   可以简单理解为为了隐藏复用类，套了一个壳子。\n\n#### final\n  \n  通常来说，final的修饰的含义是\"不可改变\"。具体到属性，方法，类上又有些差别。\n\n  1. 属性\n     对于基本类型的修饰，表示该基本类型的值，不可更改。但如果是一个对象而非基本类型的话，\n     因为修饰的实际上是对象的引用，所以其实际意义是这个引用不可再指向其他对象，但不影响对象自身的修改。\n  2. 方法\n     对于方法的修饰可以在继承时禁止方法被重写\n  3. 类\n     final类不可被继承\n\n### 多态\n\n  本书的第八章，多态。\n\n#### 后期绑定\n\n  后期绑定是确保多态能正确执行的关键之一。编译器不关心对象的具体类型，直到运行时才能判断对象的类型，从而调用正确的方法体。\n  Java中除了static，final，private方法外，都是后期绑定的。\n\n#### 协变返回类型\n\n  子类重写的方法的返回类型可以是对应父类方法中返回类型的子类\n\n### 小结\n\n      这两章的内容其实较为单一。类的继承占了很大的篇章。这也是因为继承是Java中最常用最重要的行为之一。\n    良好的继承关系能够提升代码的复用性，提高代码的阅读性，设计出精妙的数据结构。当然，就像第七章中表\n    达的那样，继承某种程度加强了代码的耦合性。所以，不是必须使用多态，更推荐组合这种更加灵活，更容易\n    扩展的结构。\n      关于多态，其实书中举了很多使用多态的例子，包括一些问题，例如静态方法，对类数据域的访问等不过实\n    际开发中由于相关开发规范，并不会遇到这些问题，所以没有记录。\n\n> 下一章 [\\<ThinkingInJava-5>](https://rel-fly.com/2020/06/11/ThinkingInJava5/)","source":"_posts/2020/06/ThinkingInJava4.md","raw":"---\ntitle: ThinkingInJava-4\ndate: 2020-06-09 16:03:50\ntags:\n- ThinkingInJava\ncategories:\n- 读书笔记\n- ThinkingInJava\n---\n\n### 前言\n  \n  类的关系，用来概括七，八两章的内容应该足以。从第七章的继承，组合到第八章的多态。Java中能够为类设计的关系结构初步展现出来。\n<!-- more -->\n\n### 复用类\n\n  本书的第七章，主要内容是关于类的复用。\n  类的复用能够减少代码的重复，并且使得整体更具结构化，而不是杂乱无章。\n  复用主要依靠类的组合和继承两种方式，组合倾向于使用现有类的功能，继承则是完整复用了现有类的结构(属性，方法等)。\n\n#### 组合和继承\n\n  组合是将一个类的实例作为自己的属性，然后通过这个实例复用他的一些方法。\n  继承则可以理解为直接复用了父类的结构，在此基础上做了扩展(当然，也可以重写父类的方法)。\n\n  对于复用类的初始化两者的区别：\n\n    组合关系：复用类作为一个属性，对于他的初始化我们可以选择在定义时初始化，在构造方法中初始化，或者在\n             使用到的时候才去完成初始化。\n    继承关系：在子类初始化之前完成父类的初始化。并且属于一种隐式操作，从外表来看，我们只是初始化了一个\n             子类的实例。其实这个子类实例内部包含了一个父类实例。\n  \n  基于初始化的区别可以看出，组合更像是为复用类预留了一个位置，我需要用你的时候就会初始化。而继承，父类的实例成了子类实例的一个影子，相互关系更加紧密。\n  当然，继承更重要的一个作用是多态。子类对象可以当作他的父类处理，即*向上转型*。所以如果不是必须使用向上转型，还是推荐使用组合。\n\n#### 代理\n   \n  代理属于继承和组合的中间选择，结构上和组合一样，将复用类当作自己的属性，但方法与复用类一致，处理则是直接调用了复用类的方法。\n  例如：\n{% codeblock lang:java %}\npublic class ClassChild {\n    private static ClassOther co;\n\n    public void add(){\n        co.add();\n    }\n\n    public void minus(){\n        co.minus();\n    }\n}\n{% endcodeblock %}\n  \n   可以简单理解为为了隐藏复用类，套了一个壳子。\n\n#### final\n  \n  通常来说，final的修饰的含义是\"不可改变\"。具体到属性，方法，类上又有些差别。\n\n  1. 属性\n     对于基本类型的修饰，表示该基本类型的值，不可更改。但如果是一个对象而非基本类型的话，\n     因为修饰的实际上是对象的引用，所以其实际意义是这个引用不可再指向其他对象，但不影响对象自身的修改。\n  2. 方法\n     对于方法的修饰可以在继承时禁止方法被重写\n  3. 类\n     final类不可被继承\n\n### 多态\n\n  本书的第八章，多态。\n\n#### 后期绑定\n\n  后期绑定是确保多态能正确执行的关键之一。编译器不关心对象的具体类型，直到运行时才能判断对象的类型，从而调用正确的方法体。\n  Java中除了static，final，private方法外，都是后期绑定的。\n\n#### 协变返回类型\n\n  子类重写的方法的返回类型可以是对应父类方法中返回类型的子类\n\n### 小结\n\n      这两章的内容其实较为单一。类的继承占了很大的篇章。这也是因为继承是Java中最常用最重要的行为之一。\n    良好的继承关系能够提升代码的复用性，提高代码的阅读性，设计出精妙的数据结构。当然，就像第七章中表\n    达的那样，继承某种程度加强了代码的耦合性。所以，不是必须使用多态，更推荐组合这种更加灵活，更容易\n    扩展的结构。\n      关于多态，其实书中举了很多使用多态的例子，包括一些问题，例如静态方法，对类数据域的访问等不过实\n    际开发中由于相关开发规范，并不会遇到这些问题，所以没有记录。\n\n> 下一章 [\\<ThinkingInJava-5>](https://rel-fly.com/2020/06/11/ThinkingInJava5/)","slug":"ThinkingInJava4","published":1,"updated":"2020-08-15T12:34:05.001Z","_id":"ckdvmudyf0010nwb5ds1bdq4j","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  类的关系，用来概括七，八两章的内容应该足以。从第七章的继承，组合到第八章的多态。Java中能够为类设计的关系结构初步展现出来。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"复用类\"><a href=\"#复用类\" class=\"headerlink\" title=\"复用类\"></a>复用类</h3><p>  本书的第七章，主要内容是关于类的复用。<br>  类的复用能够减少代码的重复，并且使得整体更具结构化，而不是杂乱无章。<br>  复用主要依靠类的组合和继承两种方式，组合倾向于使用现有类的功能，继承则是完整复用了现有类的结构(属性，方法等)。</p>\n<h4 id=\"组合和继承\"><a href=\"#组合和继承\" class=\"headerlink\" title=\"组合和继承\"></a>组合和继承</h4><p>  组合是将一个类的实例作为自己的属性，然后通过这个实例复用他的一些方法。<br>  继承则可以理解为直接复用了父类的结构，在此基础上做了扩展(当然，也可以重写父类的方法)。</p>\n<p>  对于复用类的初始化两者的区别：</p>\n<pre><code>组合关系：复用类作为一个属性，对于他的初始化我们可以选择在定义时初始化，在构造方法中初始化，或者在\n         使用到的时候才去完成初始化。\n继承关系：在子类初始化之前完成父类的初始化。并且属于一种隐式操作，从外表来看，我们只是初始化了一个\n         子类的实例。其实这个子类实例内部包含了一个父类实例。</code></pre><p>  基于初始化的区别可以看出，组合更像是为复用类预留了一个位置，我需要用你的时候就会初始化。而继承，父类的实例成了子类实例的一个影子，相互关系更加紧密。<br>  当然，继承更重要的一个作用是多态。子类对象可以当作他的父类处理，即<em>向上转型</em>。所以如果不是必须使用向上转型，还是推荐使用组合。</p>\n<h4 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h4><p>  代理属于继承和组合的中间选择，结构上和组合一样，将复用类当作自己的属性，但方法与复用类一致，处理则是直接调用了复用类的方法。<br>  例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassChild</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ClassOther co;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        co.add();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">minus</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        co.minus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   可以简单理解为为了隐藏复用类，套了一个壳子。</p>\n<h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>  通常来说，final的修饰的含义是”不可改变”。具体到属性，方法，类上又有些差别。</p>\n<ol>\n<li>属性<br>对于基本类型的修饰，表示该基本类型的值，不可更改。但如果是一个对象而非基本类型的话，<br>因为修饰的实际上是对象的引用，所以其实际意义是这个引用不可再指向其他对象，但不影响对象自身的修改。</li>\n<li>方法<br>对于方法的修饰可以在继承时禁止方法被重写</li>\n<li>类<br>final类不可被继承</li>\n</ol>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>  本书的第八章，多态。</p>\n<h4 id=\"后期绑定\"><a href=\"#后期绑定\" class=\"headerlink\" title=\"后期绑定\"></a>后期绑定</h4><p>  后期绑定是确保多态能正确执行的关键之一。编译器不关心对象的具体类型，直到运行时才能判断对象的类型，从而调用正确的方法体。<br>  Java中除了static，final，private方法外，都是后期绑定的。</p>\n<h4 id=\"协变返回类型\"><a href=\"#协变返回类型\" class=\"headerlink\" title=\"协变返回类型\"></a>协变返回类型</h4><p>  子类重写的方法的返回类型可以是对应父类方法中返回类型的子类</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  这两章的内容其实较为单一。类的继承占了很大的篇章。这也是因为继承是Java中最常用最重要的行为之一。\n良好的继承关系能够提升代码的复用性，提高代码的阅读性，设计出精妙的数据结构。当然，就像第七章中表\n达的那样，继承某种程度加强了代码的耦合性。所以，不是必须使用多态，更推荐组合这种更加灵活，更容易\n扩展的结构。\n  关于多态，其实书中举了很多使用多态的例子，包括一些问题，例如静态方法，对类数据域的访问等不过实\n际开发中由于相关开发规范，并不会遇到这些问题，所以没有记录。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/11/ThinkingInJava5/\">&lt;ThinkingInJava-5&gt;</a></p>\n</blockquote>\n","site":{"data":{}},"length":1220,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  类的关系，用来概括七，八两章的内容应该足以。从第七章的继承，组合到第八章的多态。Java中能够为类设计的关系结构初步展现出来。</p>","more":"<h3 id=\"复用类\"><a href=\"#复用类\" class=\"headerlink\" title=\"复用类\"></a>复用类</h3><p>  本书的第七章，主要内容是关于类的复用。<br>  类的复用能够减少代码的重复，并且使得整体更具结构化，而不是杂乱无章。<br>  复用主要依靠类的组合和继承两种方式，组合倾向于使用现有类的功能，继承则是完整复用了现有类的结构(属性，方法等)。</p>\n<h4 id=\"组合和继承\"><a href=\"#组合和继承\" class=\"headerlink\" title=\"组合和继承\"></a>组合和继承</h4><p>  组合是将一个类的实例作为自己的属性，然后通过这个实例复用他的一些方法。<br>  继承则可以理解为直接复用了父类的结构，在此基础上做了扩展(当然，也可以重写父类的方法)。</p>\n<p>  对于复用类的初始化两者的区别：</p>\n<pre><code>组合关系：复用类作为一个属性，对于他的初始化我们可以选择在定义时初始化，在构造方法中初始化，或者在\n         使用到的时候才去完成初始化。\n继承关系：在子类初始化之前完成父类的初始化。并且属于一种隐式操作，从外表来看，我们只是初始化了一个\n         子类的实例。其实这个子类实例内部包含了一个父类实例。</code></pre><p>  基于初始化的区别可以看出，组合更像是为复用类预留了一个位置，我需要用你的时候就会初始化。而继承，父类的实例成了子类实例的一个影子，相互关系更加紧密。<br>  当然，继承更重要的一个作用是多态。子类对象可以当作他的父类处理，即<em>向上转型</em>。所以如果不是必须使用向上转型，还是推荐使用组合。</p>\n<h4 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h4><p>  代理属于继承和组合的中间选择，结构上和组合一样，将复用类当作自己的属性，但方法与复用类一致，处理则是直接调用了复用类的方法。<br>  例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassChild</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ClassOther co;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        co.add();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">minus</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        co.minus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   可以简单理解为为了隐藏复用类，套了一个壳子。</p>\n<h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>  通常来说，final的修饰的含义是”不可改变”。具体到属性，方法，类上又有些差别。</p>\n<ol>\n<li>属性<br>对于基本类型的修饰，表示该基本类型的值，不可更改。但如果是一个对象而非基本类型的话，<br>因为修饰的实际上是对象的引用，所以其实际意义是这个引用不可再指向其他对象，但不影响对象自身的修改。</li>\n<li>方法<br>对于方法的修饰可以在继承时禁止方法被重写</li>\n<li>类<br>final类不可被继承</li>\n</ol>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>  本书的第八章，多态。</p>\n<h4 id=\"后期绑定\"><a href=\"#后期绑定\" class=\"headerlink\" title=\"后期绑定\"></a>后期绑定</h4><p>  后期绑定是确保多态能正确执行的关键之一。编译器不关心对象的具体类型，直到运行时才能判断对象的类型，从而调用正确的方法体。<br>  Java中除了static，final，private方法外，都是后期绑定的。</p>\n<h4 id=\"协变返回类型\"><a href=\"#协变返回类型\" class=\"headerlink\" title=\"协变返回类型\"></a>协变返回类型</h4><p>  子类重写的方法的返回类型可以是对应父类方法中返回类型的子类</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  这两章的内容其实较为单一。类的继承占了很大的篇章。这也是因为继承是Java中最常用最重要的行为之一。\n良好的继承关系能够提升代码的复用性，提高代码的阅读性，设计出精妙的数据结构。当然，就像第七章中表\n达的那样，继承某种程度加强了代码的耦合性。所以，不是必须使用多态，更推荐组合这种更加灵活，更容易\n扩展的结构。\n  关于多态，其实书中举了很多使用多态的例子，包括一些问题，例如静态方法，对类数据域的访问等不过实\n际开发中由于相关开发规范，并不会遇到这些问题，所以没有记录。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/11/ThinkingInJava5/\">&lt;ThinkingInJava-5&gt;</a></p>\n</blockquote>"},{"title":"ThinkingInJava-6","date":"2020-06-14T03:20:50.000Z","_content":"\n### 前言\n\n  集合是Java中较为重要的一个模块。也是我们日常使用较多的功能。容器的种类繁多，各有特点，所以只有了解\n  掌握好各个容器的特点才能在适合的场景使用正确的容器。\n  本章涉及的都是常用的同步容器，如ArrayList,LinkedList,HashMap等。\n<!-- more -->\n\n### 持有对象\n  \n  本书第十一章，从对象的保存引入集合概念。介绍了Java中常用的几大集合类型即迭代器等工具的使用。\n\n#### Collection\n  \n    独立元素的序列，其下又分为List，Queue，Set三大类。\n\n##### List\n  \n    List是一个按照插入顺序排序的集合，常用的有ArrayList和LinkedList。\n\n1. ArrayList：基于数组结构的集合，优势在于随机访问，但是新增和删除操作较慢。可以参考[\\<ArrayList(jdk1.8)>](https://rel-fly.com/2020/05/26/arrayList1/)\n\n2. LinkedList：实现List接口的同时还实现了Deque(Queue的子接口)，所以可以用作栈，队列等结构。其基于双向循环链表，优势在于顺序访问及代价较低的新增和删除操作，但是随机访问较慢。\n\n##### Queue\n  \n      Queue的大多实现遵循先进先出的规则，事物的放入顺序与取出顺序一样。因为其特点，在并发中\n    起到了非常重要的作用。\n\n1. PriorityQueue：优先队列，其队列规则是下一个弹出的元素是优先级最高的而不是等待时间最长(先进先出即弹出等待时间最长的)。\n\n##### Set\n\n    非重复元素集合，常用作元素在集合中存在性的判断。\n\n1. HashSet：底层基于HashMap存储数据，实现Set接口，所以具有Set集合的特点，不接受重复元素。其查询效率较高。\n\n2. TreeSet：与HashSet不同的是实现了NavigableSet(SortedSet的子接口)，元素处于排序状态。\n\n3. LinkedHashSet：以插入顺序保存元素。\n\n#### Map\n\n    Map是一种对象与对象关联的设计，键值对类型能够让基于key的查询保持很高的效率。\n\n1. HashMap：基于数组+链表/红黑树的结构。因为键值对的特点，根据key值的查询较快，新增删除如果涉及到扩容和链表/树结构的变化代价会较大。具体可参考[\\<HashMap(jdk1.8)>](https://rel-fly.com/2020/05/30/hashMap1/)\n\n2. TreeMap：基于红黑树的结构。保持key始终处于排序状态。\n\n3. LinkedHashMap：HashMap的子类，在HashMap的结构基础上增加了一个双向链表记录元素插入顺序。所以他的key保持插入顺序排序，同时查询速度也很快。\n\n### 小结\n\n      哪怕只是同步集合，其实内容也比较多。相对来说，自己对集合的使用还是较为死板。像List可能就无\n    脑用ArrayList了，这点需要在实际开发中注意。而且还有对并发集合的选择，正确的选择才能有效提高\n    代码效率和安全性。\n      书中还提到了用其他的Collection对象来完成初始化，Arrays.asList()的使用，以及集合与迭代器\n    的使用等。这些留待之后单独的一一研究记录。本章只是单纯的对常用同步集合做了一个罗列，也准备之后\n    挨个以源码解读的方式记录。\n\n> 下一章 [\\<ThinkingInJava-7>](https://rel-fly.com/2020/06/15/ThinkingInJava7/)","source":"_posts/2020/06/ThinkingInJava6.md","raw":"---\ntitle: ThinkingInJava-6\ndate: 2020-06-14 11:20:50\ntags:\n- ThinkingInJava\ncategories:\n- 读书笔记\n- ThinkingInJava\n---\n\n### 前言\n\n  集合是Java中较为重要的一个模块。也是我们日常使用较多的功能。容器的种类繁多，各有特点，所以只有了解\n  掌握好各个容器的特点才能在适合的场景使用正确的容器。\n  本章涉及的都是常用的同步容器，如ArrayList,LinkedList,HashMap等。\n<!-- more -->\n\n### 持有对象\n  \n  本书第十一章，从对象的保存引入集合概念。介绍了Java中常用的几大集合类型即迭代器等工具的使用。\n\n#### Collection\n  \n    独立元素的序列，其下又分为List，Queue，Set三大类。\n\n##### List\n  \n    List是一个按照插入顺序排序的集合，常用的有ArrayList和LinkedList。\n\n1. ArrayList：基于数组结构的集合，优势在于随机访问，但是新增和删除操作较慢。可以参考[\\<ArrayList(jdk1.8)>](https://rel-fly.com/2020/05/26/arrayList1/)\n\n2. LinkedList：实现List接口的同时还实现了Deque(Queue的子接口)，所以可以用作栈，队列等结构。其基于双向循环链表，优势在于顺序访问及代价较低的新增和删除操作，但是随机访问较慢。\n\n##### Queue\n  \n      Queue的大多实现遵循先进先出的规则，事物的放入顺序与取出顺序一样。因为其特点，在并发中\n    起到了非常重要的作用。\n\n1. PriorityQueue：优先队列，其队列规则是下一个弹出的元素是优先级最高的而不是等待时间最长(先进先出即弹出等待时间最长的)。\n\n##### Set\n\n    非重复元素集合，常用作元素在集合中存在性的判断。\n\n1. HashSet：底层基于HashMap存储数据，实现Set接口，所以具有Set集合的特点，不接受重复元素。其查询效率较高。\n\n2. TreeSet：与HashSet不同的是实现了NavigableSet(SortedSet的子接口)，元素处于排序状态。\n\n3. LinkedHashSet：以插入顺序保存元素。\n\n#### Map\n\n    Map是一种对象与对象关联的设计，键值对类型能够让基于key的查询保持很高的效率。\n\n1. HashMap：基于数组+链表/红黑树的结构。因为键值对的特点，根据key值的查询较快，新增删除如果涉及到扩容和链表/树结构的变化代价会较大。具体可参考[\\<HashMap(jdk1.8)>](https://rel-fly.com/2020/05/30/hashMap1/)\n\n2. TreeMap：基于红黑树的结构。保持key始终处于排序状态。\n\n3. LinkedHashMap：HashMap的子类，在HashMap的结构基础上增加了一个双向链表记录元素插入顺序。所以他的key保持插入顺序排序，同时查询速度也很快。\n\n### 小结\n\n      哪怕只是同步集合，其实内容也比较多。相对来说，自己对集合的使用还是较为死板。像List可能就无\n    脑用ArrayList了，这点需要在实际开发中注意。而且还有对并发集合的选择，正确的选择才能有效提高\n    代码效率和安全性。\n      书中还提到了用其他的Collection对象来完成初始化，Arrays.asList()的使用，以及集合与迭代器\n    的使用等。这些留待之后单独的一一研究记录。本章只是单纯的对常用同步集合做了一个罗列，也准备之后\n    挨个以源码解读的方式记录。\n\n> 下一章 [\\<ThinkingInJava-7>](https://rel-fly.com/2020/06/15/ThinkingInJava7/)","slug":"ThinkingInJava6","published":1,"updated":"2020-08-15T12:34:05.001Z","_id":"ckdvmudyg0012nwb5evp1fgcz","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  集合是Java中较为重要的一个模块。也是我们日常使用较多的功能。容器的种类繁多，各有特点，所以只有了解<br>  掌握好各个容器的特点才能在适合的场景使用正确的容器。<br>  本章涉及的都是常用的同步容器，如ArrayList,LinkedList,HashMap等。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"持有对象\"><a href=\"#持有对象\" class=\"headerlink\" title=\"持有对象\"></a>持有对象</h3><p>  本书第十一章，从对象的保存引入集合概念。介绍了Java中常用的几大集合类型即迭代器等工具的使用。</p>\n<h4 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h4><pre><code>独立元素的序列，其下又分为List，Queue，Set三大类。</code></pre><h5 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h5><pre><code>List是一个按照插入顺序排序的集合，常用的有ArrayList和LinkedList。</code></pre><ol>\n<li><p>ArrayList：基于数组结构的集合，优势在于随机访问，但是新增和删除操作较慢。可以参考<a href=\"https://rel-fly.com/2020/05/26/arrayList1/\">&lt;ArrayList(jdk1.8)&gt;</a></p>\n</li>\n<li><p>LinkedList：实现List接口的同时还实现了Deque(Queue的子接口)，所以可以用作栈，队列等结构。其基于双向循环链表，优势在于顺序访问及代价较低的新增和删除操作，但是随机访问较慢。</p>\n</li>\n</ol>\n<h5 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h5><pre><code>  Queue的大多实现遵循先进先出的规则，事物的放入顺序与取出顺序一样。因为其特点，在并发中\n起到了非常重要的作用。</code></pre><ol>\n<li>PriorityQueue：优先队列，其队列规则是下一个弹出的元素是优先级最高的而不是等待时间最长(先进先出即弹出等待时间最长的)。</li>\n</ol>\n<h5 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h5><pre><code>非重复元素集合，常用作元素在集合中存在性的判断。</code></pre><ol>\n<li><p>HashSet：底层基于HashMap存储数据，实现Set接口，所以具有Set集合的特点，不接受重复元素。其查询效率较高。</p>\n</li>\n<li><p>TreeSet：与HashSet不同的是实现了NavigableSet(SortedSet的子接口)，元素处于排序状态。</p>\n</li>\n<li><p>LinkedHashSet：以插入顺序保存元素。</p>\n</li>\n</ol>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><pre><code>Map是一种对象与对象关联的设计，键值对类型能够让基于key的查询保持很高的效率。</code></pre><ol>\n<li><p>HashMap：基于数组+链表/红黑树的结构。因为键值对的特点，根据key值的查询较快，新增删除如果涉及到扩容和链表/树结构的变化代价会较大。具体可参考<a href=\"https://rel-fly.com/2020/05/30/hashMap1/\">&lt;HashMap(jdk1.8)&gt;</a></p>\n</li>\n<li><p>TreeMap：基于红黑树的结构。保持key始终处于排序状态。</p>\n</li>\n<li><p>LinkedHashMap：HashMap的子类，在HashMap的结构基础上增加了一个双向链表记录元素插入顺序。所以他的key保持插入顺序排序，同时查询速度也很快。</p>\n</li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  哪怕只是同步集合，其实内容也比较多。相对来说，自己对集合的使用还是较为死板。像List可能就无\n脑用ArrayList了，这点需要在实际开发中注意。而且还有对并发集合的选择，正确的选择才能有效提高\n代码效率和安全性。\n  书中还提到了用其他的Collection对象来完成初始化，Arrays.asList()的使用，以及集合与迭代器\n的使用等。这些留待之后单独的一一研究记录。本章只是单纯的对常用同步集合做了一个罗列，也准备之后\n挨个以源码解读的方式记录。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/15/ThinkingInJava7/\">&lt;ThinkingInJava-7&gt;</a></p>\n</blockquote>\n","site":{"data":{}},"length":1101,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  集合是Java中较为重要的一个模块。也是我们日常使用较多的功能。容器的种类繁多，各有特点，所以只有了解<br>  掌握好各个容器的特点才能在适合的场景使用正确的容器。<br>  本章涉及的都是常用的同步容器，如ArrayList,LinkedList,HashMap等。</p>","more":"<h3 id=\"持有对象\"><a href=\"#持有对象\" class=\"headerlink\" title=\"持有对象\"></a>持有对象</h3><p>  本书第十一章，从对象的保存引入集合概念。介绍了Java中常用的几大集合类型即迭代器等工具的使用。</p>\n<h4 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h4><pre><code>独立元素的序列，其下又分为List，Queue，Set三大类。</code></pre><h5 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h5><pre><code>List是一个按照插入顺序排序的集合，常用的有ArrayList和LinkedList。</code></pre><ol>\n<li><p>ArrayList：基于数组结构的集合，优势在于随机访问，但是新增和删除操作较慢。可以参考<a href=\"https://rel-fly.com/2020/05/26/arrayList1/\">&lt;ArrayList(jdk1.8)&gt;</a></p>\n</li>\n<li><p>LinkedList：实现List接口的同时还实现了Deque(Queue的子接口)，所以可以用作栈，队列等结构。其基于双向循环链表，优势在于顺序访问及代价较低的新增和删除操作，但是随机访问较慢。</p>\n</li>\n</ol>\n<h5 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue\"></a>Queue</h5><pre><code>  Queue的大多实现遵循先进先出的规则，事物的放入顺序与取出顺序一样。因为其特点，在并发中\n起到了非常重要的作用。</code></pre><ol>\n<li>PriorityQueue：优先队列，其队列规则是下一个弹出的元素是优先级最高的而不是等待时间最长(先进先出即弹出等待时间最长的)。</li>\n</ol>\n<h5 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h5><pre><code>非重复元素集合，常用作元素在集合中存在性的判断。</code></pre><ol>\n<li><p>HashSet：底层基于HashMap存储数据，实现Set接口，所以具有Set集合的特点，不接受重复元素。其查询效率较高。</p>\n</li>\n<li><p>TreeSet：与HashSet不同的是实现了NavigableSet(SortedSet的子接口)，元素处于排序状态。</p>\n</li>\n<li><p>LinkedHashSet：以插入顺序保存元素。</p>\n</li>\n</ol>\n<h4 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h4><pre><code>Map是一种对象与对象关联的设计，键值对类型能够让基于key的查询保持很高的效率。</code></pre><ol>\n<li><p>HashMap：基于数组+链表/红黑树的结构。因为键值对的特点，根据key值的查询较快，新增删除如果涉及到扩容和链表/树结构的变化代价会较大。具体可参考<a href=\"https://rel-fly.com/2020/05/30/hashMap1/\">&lt;HashMap(jdk1.8)&gt;</a></p>\n</li>\n<li><p>TreeMap：基于红黑树的结构。保持key始终处于排序状态。</p>\n</li>\n<li><p>LinkedHashMap：HashMap的子类，在HashMap的结构基础上增加了一个双向链表记录元素插入顺序。所以他的key保持插入顺序排序，同时查询速度也很快。</p>\n</li>\n</ol>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  哪怕只是同步集合，其实内容也比较多。相对来说，自己对集合的使用还是较为死板。像List可能就无\n脑用ArrayList了，这点需要在实际开发中注意。而且还有对并发集合的选择，正确的选择才能有效提高\n代码效率和安全性。\n  书中还提到了用其他的Collection对象来完成初始化，Arrays.asList()的使用，以及集合与迭代器\n的使用等。这些留待之后单独的一一研究记录。本章只是单纯的对常用同步集合做了一个罗列，也准备之后\n挨个以源码解读的方式记录。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/15/ThinkingInJava7/\">&lt;ThinkingInJava-7&gt;</a></p>\n</blockquote>"},{"title":"ThinkingInJava-5","date":"2020-06-11T01:16:22.000Z","_content":"\n### 前言\n\n  在介绍完基本的类和相关设计方法如继承，组合后，就开始扩展类的定义了。\n  抽象类和接口是普通类向抽象化进一步延申的类型，两者的出现使得继承这种关系更加灵活且更容易扩展。\n  而内部类则是与接口一起，解决了Java无法多继承的问题。变相实现了Java的多继承。\n<!-- more -->\n\n### 接口\n  \n  本书第九章，主要介绍了抽象类和接口的使用。\n\n#### 抽象类\n\n    定义：使用abstract关键字修饰的类，其特点是无法被实例化，所以只能用来被继承。\n    抽象方法：1.抽象类中可以没有抽象方法，但有抽象方法的一定是抽象类\n             2.抽象方法没有方法体，需要由抽象类的非抽象类子类重写\n             3.抽象方法不能定义为private，因为无法被继承，与第二点相悖\n\n  抽象类的出现使得开发者不必关心父类中方法的实现细节，只需要定义某一类型的行为。然后在各个子类中重写方法，定义具体的实现逻辑。\n\n#### 接口\n    \n    定义：使用interface关键字修饰，其特点是：\n          1. 无法实例化，没有构造方法\n          2. 接口中的方法都被隐式的指定为public abstract 且无法修改，同样必须在其子类中被重写\n          3. 接口的属性都被隐式的指定为public static final 且无法修改\n          4. 接口中不能含有代码块及静态方法\n          5. 用implements表示实现接口，并且可以实现多个接口，用逗号分隔\n\n  可以看到，相比抽象类，接口是一种更抽象化的类型。\n  抽象类还保留有类的一些结构，而接口则可以说是完全的抽象。而且不受单继承的限制，这使得对类结构的设计更加灵活，可扩展。\n\n#### 同名方法的冲突\n\n  书中提到了一种情况，实际开发中因为开发规范等没有遇到过，所以自己试了下。\n  问题就是，一个类继承的父类和实现的接口有同名的方法，会怎么样？\n  这里就不展示代码了，直接说结果：\n\n    1. 同名且参数列表不同\n       没有冲突，可以各自重写\n    2. 同名，参数列表相同，返回值也相同\n       可以理解为当作了一个方法。如果父该方法是抽象方法，只用也只能重写一次\n       (要不然两个一样的方法妥妥的冲突，这点很好理解)。如果不是抽象方法，可不用重写，因为父类已经实现\n       了方法逻辑\n    3. 同名，参数列表相同，返回值不同\n       会有冲突，你对其中一个方法的重写也被视作对另一个方法的重写，但是返回类型不一样就会报错。两个都\n       重写，不符合重载方法的规则，也会报错。\n\n  这个问题，日常开发应该不会遇到，而且也应该避免这种同名方法，很容易带来混淆。\n\n\n### 内部类\n  \n  本书第十章，在认识了抽象类，接口后，开始介绍另一种类-内部类。\n\n#### 不同的内部类\n\n1. 成员内部类\n   最常见的内部类定义，相当于外部类的成员，拥有外部类所有资源的访问权限。\n\n2. 局域内部类\n   定义于类方法或作用域中的内部类，只在包含他的方法和作用域中有效。属于方法而不是类的一部分。\n\n3. 匿名内部类\n   应该是比较常用的一种内部类定义。主要是在父类或接口存在的情况下，创建一个继承该父类或实现接口的子类对象，并实现对应方法。\n   这种方式可以避免单独创建类，如果不考虑类的复用，那么这种写法能节省很多代码量。\n\n4. 静态内部类(嵌套类)\n   如果不需要内部类对象与其外围类有联系，则可以声明为static。\n   静态内部类的创建不需要外围类的对象，且不能从静态内部类的对象中访问非静态的外围类对象。\n\n代码示例：\n\n{% codeblock lang:java %}\npublic class ExternalClass {\n    private int a;\n    private static int b;\n\n    private void method1() {\n        // 外围类对内部类的创建及访问\n        InsideClass ic = new InsideClass();\n        ic.show();\n        InsideClass2 ic2 = new InsideClass2();\n        ic2.show();\n        InsideClass2.show2();\n\n        // 局域内部类\n        class InsideClass3 {\n            private int i;\n\n            private void method() {\n                // 可以访问外围类成员\n                System.out.println(a);\n            }\n        }\n        // 只能在方法内访问到\n        InsideClass3 ic3 = new InsideClass3();\n        ic3.method();\n        // 匿名内部类\n        // 新建一个实现接口InterfaceTest的子类的对象\n        new InterfaceTest() {\n\n            @Override\n            public void method(int i) {\n                System.out.println(i);\n            }\n        };\n    }\n\n    private static void method2() {\n        System.out.println(\"2\");\n        class InsideClass3 {\n            private int i;\n\n            private void method() {\n                System.out.println(\"```\");\n            }\n        }\n        InsideClass3 ic = new InsideClass3();\n        ic.method();\n    }\n\n    // 成员内部类 不能创建static属性或方法\n    public class InsideClass {\n        private int i;\n\n        private void show() {\n            // 可以访问外部类的所有资源\n            a = 1;\n            b = 2;\n            method1();\n            method2();\n            ExternalClass.this.method1();\n        }\n    }\n\n    // 静态内部类\n    public static class InsideClass2 {\n        private int i;\n        private static int j;\n\n        private void show() {\n            // 只能访问外部类的静态资源\n            b = 2;\n            method2();\n            System.out.println(\"InsideClass2\");\n        }\n\n        private static void show2() {\n            b = 2;\n            method2();\n            System.out.println(\"InsideClass2\");\n        }\n    }\n}\n{% endcodeblock%}\n{% codeblock lang:java %}\n// 成员内部类的对象新建方法\n// 需要先取得外围类的对象再新建其内部类对象\nExternalClass.InsideClass ic = new ExternalClass().new InsideClass();\n// 静态内部类的对象新建方法： \nExternalClass.InsideClass2 ic2 = new ExternalClass.InsideClass2();\n{% endcodeblock%}\n\n### 小结\n\n        接口，抽象类，内部类，这三者为类的设计提供了更多的可能和思路。特别是接口和内部类，变相实现了\n    Java的多继承。\n        内部类感觉要比接口和抽象类复杂一些。内部类与外围类相互独立，一个类可以建立多个内部类来继承不\n    同的类或实现不同的接口已突破单一继承的限制。另一方面，内部类也是可以被继承的，这在增加了更多可能\n    的同时，也会增加类关系的复杂度。所以还是要依据实际业务场景去设计(HashMap和LinkedHashMap应该算\n    是个不错的参考对象)。\n\n> 下一章 [\\<ThinkingInJava-6>](https://rel-fly.com/2020/06/14/ThinkingInJava6/)","source":"_posts/2020/06/ThinkingInJava5.md","raw":"---\ntitle: ThinkingInJava-5\ndate: 2020-06-11 09:16:22\ntags:\n- ThinkingInJava\ncategories:\n- 读书笔记\n- ThinkingInJava\n---\n\n### 前言\n\n  在介绍完基本的类和相关设计方法如继承，组合后，就开始扩展类的定义了。\n  抽象类和接口是普通类向抽象化进一步延申的类型，两者的出现使得继承这种关系更加灵活且更容易扩展。\n  而内部类则是与接口一起，解决了Java无法多继承的问题。变相实现了Java的多继承。\n<!-- more -->\n\n### 接口\n  \n  本书第九章，主要介绍了抽象类和接口的使用。\n\n#### 抽象类\n\n    定义：使用abstract关键字修饰的类，其特点是无法被实例化，所以只能用来被继承。\n    抽象方法：1.抽象类中可以没有抽象方法，但有抽象方法的一定是抽象类\n             2.抽象方法没有方法体，需要由抽象类的非抽象类子类重写\n             3.抽象方法不能定义为private，因为无法被继承，与第二点相悖\n\n  抽象类的出现使得开发者不必关心父类中方法的实现细节，只需要定义某一类型的行为。然后在各个子类中重写方法，定义具体的实现逻辑。\n\n#### 接口\n    \n    定义：使用interface关键字修饰，其特点是：\n          1. 无法实例化，没有构造方法\n          2. 接口中的方法都被隐式的指定为public abstract 且无法修改，同样必须在其子类中被重写\n          3. 接口的属性都被隐式的指定为public static final 且无法修改\n          4. 接口中不能含有代码块及静态方法\n          5. 用implements表示实现接口，并且可以实现多个接口，用逗号分隔\n\n  可以看到，相比抽象类，接口是一种更抽象化的类型。\n  抽象类还保留有类的一些结构，而接口则可以说是完全的抽象。而且不受单继承的限制，这使得对类结构的设计更加灵活，可扩展。\n\n#### 同名方法的冲突\n\n  书中提到了一种情况，实际开发中因为开发规范等没有遇到过，所以自己试了下。\n  问题就是，一个类继承的父类和实现的接口有同名的方法，会怎么样？\n  这里就不展示代码了，直接说结果：\n\n    1. 同名且参数列表不同\n       没有冲突，可以各自重写\n    2. 同名，参数列表相同，返回值也相同\n       可以理解为当作了一个方法。如果父该方法是抽象方法，只用也只能重写一次\n       (要不然两个一样的方法妥妥的冲突，这点很好理解)。如果不是抽象方法，可不用重写，因为父类已经实现\n       了方法逻辑\n    3. 同名，参数列表相同，返回值不同\n       会有冲突，你对其中一个方法的重写也被视作对另一个方法的重写，但是返回类型不一样就会报错。两个都\n       重写，不符合重载方法的规则，也会报错。\n\n  这个问题，日常开发应该不会遇到，而且也应该避免这种同名方法，很容易带来混淆。\n\n\n### 内部类\n  \n  本书第十章，在认识了抽象类，接口后，开始介绍另一种类-内部类。\n\n#### 不同的内部类\n\n1. 成员内部类\n   最常见的内部类定义，相当于外部类的成员，拥有外部类所有资源的访问权限。\n\n2. 局域内部类\n   定义于类方法或作用域中的内部类，只在包含他的方法和作用域中有效。属于方法而不是类的一部分。\n\n3. 匿名内部类\n   应该是比较常用的一种内部类定义。主要是在父类或接口存在的情况下，创建一个继承该父类或实现接口的子类对象，并实现对应方法。\n   这种方式可以避免单独创建类，如果不考虑类的复用，那么这种写法能节省很多代码量。\n\n4. 静态内部类(嵌套类)\n   如果不需要内部类对象与其外围类有联系，则可以声明为static。\n   静态内部类的创建不需要外围类的对象，且不能从静态内部类的对象中访问非静态的外围类对象。\n\n代码示例：\n\n{% codeblock lang:java %}\npublic class ExternalClass {\n    private int a;\n    private static int b;\n\n    private void method1() {\n        // 外围类对内部类的创建及访问\n        InsideClass ic = new InsideClass();\n        ic.show();\n        InsideClass2 ic2 = new InsideClass2();\n        ic2.show();\n        InsideClass2.show2();\n\n        // 局域内部类\n        class InsideClass3 {\n            private int i;\n\n            private void method() {\n                // 可以访问外围类成员\n                System.out.println(a);\n            }\n        }\n        // 只能在方法内访问到\n        InsideClass3 ic3 = new InsideClass3();\n        ic3.method();\n        // 匿名内部类\n        // 新建一个实现接口InterfaceTest的子类的对象\n        new InterfaceTest() {\n\n            @Override\n            public void method(int i) {\n                System.out.println(i);\n            }\n        };\n    }\n\n    private static void method2() {\n        System.out.println(\"2\");\n        class InsideClass3 {\n            private int i;\n\n            private void method() {\n                System.out.println(\"```\");\n            }\n        }\n        InsideClass3 ic = new InsideClass3();\n        ic.method();\n    }\n\n    // 成员内部类 不能创建static属性或方法\n    public class InsideClass {\n        private int i;\n\n        private void show() {\n            // 可以访问外部类的所有资源\n            a = 1;\n            b = 2;\n            method1();\n            method2();\n            ExternalClass.this.method1();\n        }\n    }\n\n    // 静态内部类\n    public static class InsideClass2 {\n        private int i;\n        private static int j;\n\n        private void show() {\n            // 只能访问外部类的静态资源\n            b = 2;\n            method2();\n            System.out.println(\"InsideClass2\");\n        }\n\n        private static void show2() {\n            b = 2;\n            method2();\n            System.out.println(\"InsideClass2\");\n        }\n    }\n}\n{% endcodeblock%}\n{% codeblock lang:java %}\n// 成员内部类的对象新建方法\n// 需要先取得外围类的对象再新建其内部类对象\nExternalClass.InsideClass ic = new ExternalClass().new InsideClass();\n// 静态内部类的对象新建方法： \nExternalClass.InsideClass2 ic2 = new ExternalClass.InsideClass2();\n{% endcodeblock%}\n\n### 小结\n\n        接口，抽象类，内部类，这三者为类的设计提供了更多的可能和思路。特别是接口和内部类，变相实现了\n    Java的多继承。\n        内部类感觉要比接口和抽象类复杂一些。内部类与外围类相互独立，一个类可以建立多个内部类来继承不\n    同的类或实现不同的接口已突破单一继承的限制。另一方面，内部类也是可以被继承的，这在增加了更多可能\n    的同时，也会增加类关系的复杂度。所以还是要依据实际业务场景去设计(HashMap和LinkedHashMap应该算\n    是个不错的参考对象)。\n\n> 下一章 [\\<ThinkingInJava-6>](https://rel-fly.com/2020/06/14/ThinkingInJava6/)","slug":"ThinkingInJava5","published":1,"updated":"2020-08-15T12:34:05.001Z","_id":"ckdvmudyh0014nwb53r4l0jti","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  在介绍完基本的类和相关设计方法如继承，组合后，就开始扩展类的定义了。<br>  抽象类和接口是普通类向抽象化进一步延申的类型，两者的出现使得继承这种关系更加灵活且更容易扩展。<br>  而内部类则是与接口一起，解决了Java无法多继承的问题。变相实现了Java的多继承。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>  本书第九章，主要介绍了抽象类和接口的使用。</p>\n<h4 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h4><pre><code>定义：使用abstract关键字修饰的类，其特点是无法被实例化，所以只能用来被继承。\n抽象方法：1.抽象类中可以没有抽象方法，但有抽象方法的一定是抽象类\n         2.抽象方法没有方法体，需要由抽象类的非抽象类子类重写\n         3.抽象方法不能定义为private，因为无法被继承，与第二点相悖</code></pre><p>  抽象类的出现使得开发者不必关心父类中方法的实现细节，只需要定义某一类型的行为。然后在各个子类中重写方法，定义具体的实现逻辑。</p>\n<h4 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h4><pre><code>定义：使用interface关键字修饰，其特点是：\n      1. 无法实例化，没有构造方法\n      2. 接口中的方法都被隐式的指定为public abstract 且无法修改，同样必须在其子类中被重写\n      3. 接口的属性都被隐式的指定为public static final 且无法修改\n      4. 接口中不能含有代码块及静态方法\n      5. 用implements表示实现接口，并且可以实现多个接口，用逗号分隔</code></pre><p>  可以看到，相比抽象类，接口是一种更抽象化的类型。<br>  抽象类还保留有类的一些结构，而接口则可以说是完全的抽象。而且不受单继承的限制，这使得对类结构的设计更加灵活，可扩展。</p>\n<h4 id=\"同名方法的冲突\"><a href=\"#同名方法的冲突\" class=\"headerlink\" title=\"同名方法的冲突\"></a>同名方法的冲突</h4><p>  书中提到了一种情况，实际开发中因为开发规范等没有遇到过，所以自己试了下。<br>  问题就是，一个类继承的父类和实现的接口有同名的方法，会怎么样？<br>  这里就不展示代码了，直接说结果：</p>\n<pre><code>1. 同名且参数列表不同\n   没有冲突，可以各自重写\n2. 同名，参数列表相同，返回值也相同\n   可以理解为当作了一个方法。如果父该方法是抽象方法，只用也只能重写一次\n   (要不然两个一样的方法妥妥的冲突，这点很好理解)。如果不是抽象方法，可不用重写，因为父类已经实现\n   了方法逻辑\n3. 同名，参数列表相同，返回值不同\n   会有冲突，你对其中一个方法的重写也被视作对另一个方法的重写，但是返回类型不一样就会报错。两个都\n   重写，不符合重载方法的规则，也会报错。</code></pre><p>  这个问题，日常开发应该不会遇到，而且也应该避免这种同名方法，很容易带来混淆。</p>\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><p>  本书第十章，在认识了抽象类，接口后，开始介绍另一种类-内部类。</p>\n<h4 id=\"不同的内部类\"><a href=\"#不同的内部类\" class=\"headerlink\" title=\"不同的内部类\"></a>不同的内部类</h4><ol>\n<li><p>成员内部类<br>最常见的内部类定义，相当于外部类的成员，拥有外部类所有资源的访问权限。</p>\n</li>\n<li><p>局域内部类<br>定义于类方法或作用域中的内部类，只在包含他的方法和作用域中有效。属于方法而不是类的一部分。</p>\n</li>\n<li><p>匿名内部类<br>应该是比较常用的一种内部类定义。主要是在父类或接口存在的情况下，创建一个继承该父类或实现接口的子类对象，并实现对应方法。<br>这种方式可以避免单独创建类，如果不考虑类的复用，那么这种写法能节省很多代码量。</p>\n</li>\n<li><p>静态内部类(嵌套类)<br>如果不需要内部类对象与其外围类有联系，则可以声明为static。<br>静态内部类的创建不需要外围类的对象，且不能从静态内部类的对象中访问非静态的外围类对象。</p>\n</li>\n</ol>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 外围类对内部类的创建及访问</span></span><br><span class=\"line\">        InsideClass ic = <span class=\"keyword\">new</span> InsideClass();</span><br><span class=\"line\">        ic.show();</span><br><span class=\"line\">        InsideClass2 ic2 = <span class=\"keyword\">new</span> InsideClass2();</span><br><span class=\"line\">        ic2.show();</span><br><span class=\"line\">        InsideClass2.show2();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 局域内部类</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsideClass3</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 可以访问外围类成员</span></span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只能在方法内访问到</span></span><br><span class=\"line\">        InsideClass3 ic3 = <span class=\"keyword\">new</span> InsideClass3();</span><br><span class=\"line\">        ic3.method();</span><br><span class=\"line\">        <span class=\"comment\">// 匿名内部类</span></span><br><span class=\"line\">        <span class=\"comment\">// 新建一个实现接口InterfaceTest的子类的对象</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> InterfaceTest() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsideClass3</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"```\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        InsideClass3 ic = <span class=\"keyword\">new</span> InsideClass3();</span><br><span class=\"line\">        ic.method();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 成员内部类 不能创建static属性或方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsideClass</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以访问外部类的所有资源</span></span><br><span class=\"line\">            a = <span class=\"number\">1</span>;</span><br><span class=\"line\">            b = <span class=\"number\">2</span>;</span><br><span class=\"line\">            method1();</span><br><span class=\"line\">            method2();</span><br><span class=\"line\">            ExternalClass.<span class=\"keyword\">this</span>.method1();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态内部类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsideClass2</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> j;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只能访问外部类的静态资源</span></span><br><span class=\"line\">            b = <span class=\"number\">2</span>;</span><br><span class=\"line\">            method2();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"InsideClass2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">show2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            b = <span class=\"number\">2</span>;</span><br><span class=\"line\">            method2();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"InsideClass2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 成员内部类的对象新建方法</span></span><br><span class=\"line\"><span class=\"comment\">// 需要先取得外围类的对象再新建其内部类对象</span></span><br><span class=\"line\">ExternalClass.InsideClass ic = <span class=\"keyword\">new</span> ExternalClass().<span class=\"keyword\">new</span> InsideClass();</span><br><span class=\"line\"><span class=\"comment\">// 静态内部类的对象新建方法： </span></span><br><span class=\"line\">ExternalClass.InsideClass2 ic2 = <span class=\"keyword\">new</span> ExternalClass.InsideClass2();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>    接口，抽象类，内部类，这三者为类的设计提供了更多的可能和思路。特别是接口和内部类，变相实现了\nJava的多继承。\n    内部类感觉要比接口和抽象类复杂一些。内部类与外围类相互独立，一个类可以建立多个内部类来继承不\n同的类或实现不同的接口已突破单一继承的限制。另一方面，内部类也是可以被继承的，这在增加了更多可能\n的同时，也会增加类关系的复杂度。所以还是要依据实际业务场景去设计(HashMap和LinkedHashMap应该算\n是个不错的参考对象)。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/14/ThinkingInJava6/\">&lt;ThinkingInJava-6&gt;</a></p>\n</blockquote>\n","site":{"data":{}},"length":1517,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  在介绍完基本的类和相关设计方法如继承，组合后，就开始扩展类的定义了。<br>  抽象类和接口是普通类向抽象化进一步延申的类型，两者的出现使得继承这种关系更加灵活且更容易扩展。<br>  而内部类则是与接口一起，解决了Java无法多继承的问题。变相实现了Java的多继承。</p>","more":"<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>  本书第九章，主要介绍了抽象类和接口的使用。</p>\n<h4 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h4><pre><code>定义：使用abstract关键字修饰的类，其特点是无法被实例化，所以只能用来被继承。\n抽象方法：1.抽象类中可以没有抽象方法，但有抽象方法的一定是抽象类\n         2.抽象方法没有方法体，需要由抽象类的非抽象类子类重写\n         3.抽象方法不能定义为private，因为无法被继承，与第二点相悖</code></pre><p>  抽象类的出现使得开发者不必关心父类中方法的实现细节，只需要定义某一类型的行为。然后在各个子类中重写方法，定义具体的实现逻辑。</p>\n<h4 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h4><pre><code>定义：使用interface关键字修饰，其特点是：\n      1. 无法实例化，没有构造方法\n      2. 接口中的方法都被隐式的指定为public abstract 且无法修改，同样必须在其子类中被重写\n      3. 接口的属性都被隐式的指定为public static final 且无法修改\n      4. 接口中不能含有代码块及静态方法\n      5. 用implements表示实现接口，并且可以实现多个接口，用逗号分隔</code></pre><p>  可以看到，相比抽象类，接口是一种更抽象化的类型。<br>  抽象类还保留有类的一些结构，而接口则可以说是完全的抽象。而且不受单继承的限制，这使得对类结构的设计更加灵活，可扩展。</p>\n<h4 id=\"同名方法的冲突\"><a href=\"#同名方法的冲突\" class=\"headerlink\" title=\"同名方法的冲突\"></a>同名方法的冲突</h4><p>  书中提到了一种情况，实际开发中因为开发规范等没有遇到过，所以自己试了下。<br>  问题就是，一个类继承的父类和实现的接口有同名的方法，会怎么样？<br>  这里就不展示代码了，直接说结果：</p>\n<pre><code>1. 同名且参数列表不同\n   没有冲突，可以各自重写\n2. 同名，参数列表相同，返回值也相同\n   可以理解为当作了一个方法。如果父该方法是抽象方法，只用也只能重写一次\n   (要不然两个一样的方法妥妥的冲突，这点很好理解)。如果不是抽象方法，可不用重写，因为父类已经实现\n   了方法逻辑\n3. 同名，参数列表相同，返回值不同\n   会有冲突，你对其中一个方法的重写也被视作对另一个方法的重写，但是返回类型不一样就会报错。两个都\n   重写，不符合重载方法的规则，也会报错。</code></pre><p>  这个问题，日常开发应该不会遇到，而且也应该避免这种同名方法，很容易带来混淆。</p>\n<h3 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h3><p>  本书第十章，在认识了抽象类，接口后，开始介绍另一种类-内部类。</p>\n<h4 id=\"不同的内部类\"><a href=\"#不同的内部类\" class=\"headerlink\" title=\"不同的内部类\"></a>不同的内部类</h4><ol>\n<li><p>成员内部类<br>最常见的内部类定义，相当于外部类的成员，拥有外部类所有资源的访问权限。</p>\n</li>\n<li><p>局域内部类<br>定义于类方法或作用域中的内部类，只在包含他的方法和作用域中有效。属于方法而不是类的一部分。</p>\n</li>\n<li><p>匿名内部类<br>应该是比较常用的一种内部类定义。主要是在父类或接口存在的情况下，创建一个继承该父类或实现接口的子类对象，并实现对应方法。<br>这种方式可以避免单独创建类，如果不考虑类的复用，那么这种写法能节省很多代码量。</p>\n</li>\n<li><p>静态内部类(嵌套类)<br>如果不需要内部类对象与其外围类有联系，则可以声明为static。<br>静态内部类的创建不需要外围类的对象，且不能从静态内部类的对象中访问非静态的外围类对象。</p>\n</li>\n</ol>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExternalClass</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 外围类对内部类的创建及访问</span></span><br><span class=\"line\">        InsideClass ic = <span class=\"keyword\">new</span> InsideClass();</span><br><span class=\"line\">        ic.show();</span><br><span class=\"line\">        InsideClass2 ic2 = <span class=\"keyword\">new</span> InsideClass2();</span><br><span class=\"line\">        ic2.show();</span><br><span class=\"line\">        InsideClass2.show2();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 局域内部类</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsideClass3</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 可以访问外围类成员</span></span><br><span class=\"line\">                System.out.println(a);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 只能在方法内访问到</span></span><br><span class=\"line\">        InsideClass3 ic3 = <span class=\"keyword\">new</span> InsideClass3();</span><br><span class=\"line\">        ic3.method();</span><br><span class=\"line\">        <span class=\"comment\">// 匿名内部类</span></span><br><span class=\"line\">        <span class=\"comment\">// 新建一个实现接口InterfaceTest的子类的对象</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> InterfaceTest() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsideClass3</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"```\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        InsideClass3 ic = <span class=\"keyword\">new</span> InsideClass3();</span><br><span class=\"line\">        ic.method();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 成员内部类 不能创建static属性或方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsideClass</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 可以访问外部类的所有资源</span></span><br><span class=\"line\">            a = <span class=\"number\">1</span>;</span><br><span class=\"line\">            b = <span class=\"number\">2</span>;</span><br><span class=\"line\">            method1();</span><br><span class=\"line\">            method2();</span><br><span class=\"line\">            ExternalClass.<span class=\"keyword\">this</span>.method1();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态内部类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InsideClass2</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> j;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 只能访问外部类的静态资源</span></span><br><span class=\"line\">            b = <span class=\"number\">2</span>;</span><br><span class=\"line\">            method2();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"InsideClass2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">show2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            b = <span class=\"number\">2</span>;</span><br><span class=\"line\">            method2();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"InsideClass2\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 成员内部类的对象新建方法</span></span><br><span class=\"line\"><span class=\"comment\">// 需要先取得外围类的对象再新建其内部类对象</span></span><br><span class=\"line\">ExternalClass.InsideClass ic = <span class=\"keyword\">new</span> ExternalClass().<span class=\"keyword\">new</span> InsideClass();</span><br><span class=\"line\"><span class=\"comment\">// 静态内部类的对象新建方法： </span></span><br><span class=\"line\">ExternalClass.InsideClass2 ic2 = <span class=\"keyword\">new</span> ExternalClass.InsideClass2();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>    接口，抽象类，内部类，这三者为类的设计提供了更多的可能和思路。特别是接口和内部类，变相实现了\nJava的多继承。\n    内部类感觉要比接口和抽象类复杂一些。内部类与外围类相互独立，一个类可以建立多个内部类来继承不\n同的类或实现不同的接口已突破单一继承的限制。另一方面，内部类也是可以被继承的，这在增加了更多可能\n的同时，也会增加类关系的复杂度。所以还是要依据实际业务场景去设计(HashMap和LinkedHashMap应该算\n是个不错的参考对象)。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/14/ThinkingInJava6/\">&lt;ThinkingInJava-6&gt;</a></p>\n</blockquote>"},{"title":"ThinkingInJava-7","date":"2020-06-15T06:16:51.000Z","_content":"\n### 前言\n\n  错误是代码难以避免的问题。编译器的错误可以直接修改代码，运行期的错误就需要将其传递到其他能处理的地方，这时候就要用到Java的异常机制。\n\n<!-- more -->\n\n### 通过异常处理错误\n\n  本书第十二章，主要讲述了Java异常及异常处理的相关内容。\n\n#### Java异常\n  \n  Java异常都继承自Throwable，然后其下分为Exception和Error两个子类\n\n1. Error(错误)\n   Error指一些无法恢复或不能捕捉的严重错误，此类错误会导致程序中断。\n\n2. Exception(异常)\n   Exception又分为运行时异常和非运行时异常\n\n   * 运行时异常\n     继承自Exception子类RuntimeException的异常类，可以被捕捉处理，也可以不处理。\n     常见的包括：NullPointerException，IndexOutOfBoundsException等\n\n   * 非运行时异常\n     继承自Exception的非RuntimeException的异常类，统称为非运行时异常。\n     这种异常必须要捕捉处理，否则编译无法通过。\n     常见的如：IOException\n\n#### 异常的处理\n\n1. 抛出异常\n   异常抛出的关键字有两个throw和throws，他们的区别很大：\n   throw：强调的是抛出异常的这个动作，只在方法体中使用\n   throws：是对方法可能抛出异常的声明，相当于告诉其他开发者这个方法可能抛出什么异常，需要处理\n{% codeblock lang:java %}\n// 手动抛出异常，程序中止\nthrow new MyException(\"10000\",\"error\");\n// 声明方法可能抛出的异常，可以声明多个以逗号分隔\nvoid method(int i) throws MyException, IOException;\n{% endcodeblock %}\n\n2. 捕获处理异常\n\n{% codeblock lang:java %}\ntry {// 执行逻辑\n    test.method(1);\n}catch(MyException e){// 异常捕捉\n    e.printStackTrace();\n}catch(IOException ioe){// 方法抛出的所有异常都要捕捉\n    System.out.println(\"不同的处理\");\n    ioe.printStackTrace();\n}finally {\n    // 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑\n    System.out.println(\"最后执行\");\n}\n\n\ntry {\n    test.method(1);\n}catch(MyException | IOException e){// 不同异常的处理逻辑相同则可以简写\n    e.printStackTrace();\n} finally {\n    System.out.println(\"最后执行\");\n}\n\n\n// try-with-resource语法，声明的资源会自动关闭，无需在finally手动执行\ntry (BufferedReader br = new BufferedReader(new FileReader(\"\"))) {\n     br.readLine();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n{% endcodeblock %}\n\n  用catch捕捉异常可以通过捕捉对应异常的父类异常，例如上述例子中可以这么写\n   \n{% codeblock lang:java %}\ntry {// 执行逻辑\n    test.method(1);\n}catch(Exception e){// 异常捕捉\n    e.printStackTrace();\n}finally {\n    // 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑\n    System.out.println(\"最后执行\");\n}\n{% endcodeblock %}    \n\n  因为Exception是其他异常的父类，所以可以捕捉到方法抛出的两种异常。当然，虽然这样看上去更加\n  简洁，但是异常信息就不够明确，所以一般情况不建议这样做。\n  因此，catch异常的顺序也需要特别注意，如果把大的异常(即父类异常)放到前面，由于对异常的匹配\n  寻找是按顺序来的，后面的小异常可能永远不会派上用场。\n\n#### 自定义异常\n\n  除了Java已经定义好的异常类，我们也可以根据自己的需求自定义异常类\n\n{% codeblock lang:java %}\n// 自定义异常需要继承Exception或其子类\npublic class MyException extends Exception {\n    private String code;\n    private String msg;\n\n    public MyException() {\n\n    }\n    // Exception提供了不同的有参构造方法\n    public MyException(String code, String msg) {\n        super(msg);\n        this.code = code;\n        this.msg = msg;\n    }\n    // 重写getMessage()方法以实现定制化的信息输出\n    @Override\n    public String getMessage() {\n        return \"MyException detail:\" + code + \"-\" + msg;\n    }\n}\n{% endcodeblock %}\n\n#### 异常的栈轨迹\n  \n  通常我们用*e.printStackTrace();*输出异常信息的时候可以看到一行行的方法地址。这就是异常的栈轨迹，表示异常一步步抛出到最外面的轨迹。\n\n{% codeblock lang:java %}\n  public void method(float f) {\n    InterfaceTest test = new Product();\n    try {\n        throw new MyException();\n    }catch(MyException e){\n        e.printStackTrace();\n        for(StackTraceElement ste:e.getStackTrace()){\n            System.out.println(ste.getMethodName());\n        }\n    }\n}\npublic void numberTwo(){method(1);}\npublic void numberThree(){numberTwo();}\n{% endcodeblock %}\n\n  比如上面这样层层调用，通过*e.getStackTrace()*获取栈轨迹的数组，然后逐个输出，就能看到如下结果\n\n     method\n     numberTwo\n     numberThree\n     main\n  \n  能够看到每一步调用的方法。\n  \n#### 异常链\n  \n  如果捕捉异常后，抛出新的异常，那么会丢失原异常的信息。\n  这时可以通过Exception的构造方法保留原异常的信息：\n\n{% codeblock lang:java %}\npublic Exception(String message, Throwable cause) {\n    super(message, cause);\n}\n{% endcodeblock %}\n\n  cause参数用来表示原始异常，可以通过这种方法将不同的异常信息串联起来，也被称作异常链。\n\n### 小结\n\n      异常不可避免，但是通过抛出/捕捉处理我们可以自由的控制异常。将他抛到我们需要处理的地方，或者直接\n    捕捉进行处理。这使得代码逻辑能够按照我们所设想的逻辑执行，而不会因为突如其来的异常导致程序中止，偏\n    离了我们的预想。\n      另一方面，对异常的信息输出也很关键了。良好的输出代表着代码有效的反馈，能够帮助开发者快速的定位问\n    题，然后决定如何修改优化。\n\n> 下一章 [\\<ThinkingInJava-8>](https://rel-fly.com/2020/06/17/ThinkingInJava8/)","source":"_posts/2020/06/ThinkingInJava7.md","raw":"---\ntitle: ThinkingInJava-7\ndate: 2020-06-15 14:16:51\ntags:\n- ThinkingInJava\ncategories:\n- 读书笔记\n- ThinkingInJava\n---\n\n### 前言\n\n  错误是代码难以避免的问题。编译器的错误可以直接修改代码，运行期的错误就需要将其传递到其他能处理的地方，这时候就要用到Java的异常机制。\n\n<!-- more -->\n\n### 通过异常处理错误\n\n  本书第十二章，主要讲述了Java异常及异常处理的相关内容。\n\n#### Java异常\n  \n  Java异常都继承自Throwable，然后其下分为Exception和Error两个子类\n\n1. Error(错误)\n   Error指一些无法恢复或不能捕捉的严重错误，此类错误会导致程序中断。\n\n2. Exception(异常)\n   Exception又分为运行时异常和非运行时异常\n\n   * 运行时异常\n     继承自Exception子类RuntimeException的异常类，可以被捕捉处理，也可以不处理。\n     常见的包括：NullPointerException，IndexOutOfBoundsException等\n\n   * 非运行时异常\n     继承自Exception的非RuntimeException的异常类，统称为非运行时异常。\n     这种异常必须要捕捉处理，否则编译无法通过。\n     常见的如：IOException\n\n#### 异常的处理\n\n1. 抛出异常\n   异常抛出的关键字有两个throw和throws，他们的区别很大：\n   throw：强调的是抛出异常的这个动作，只在方法体中使用\n   throws：是对方法可能抛出异常的声明，相当于告诉其他开发者这个方法可能抛出什么异常，需要处理\n{% codeblock lang:java %}\n// 手动抛出异常，程序中止\nthrow new MyException(\"10000\",\"error\");\n// 声明方法可能抛出的异常，可以声明多个以逗号分隔\nvoid method(int i) throws MyException, IOException;\n{% endcodeblock %}\n\n2. 捕获处理异常\n\n{% codeblock lang:java %}\ntry {// 执行逻辑\n    test.method(1);\n}catch(MyException e){// 异常捕捉\n    e.printStackTrace();\n}catch(IOException ioe){// 方法抛出的所有异常都要捕捉\n    System.out.println(\"不同的处理\");\n    ioe.printStackTrace();\n}finally {\n    // 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑\n    System.out.println(\"最后执行\");\n}\n\n\ntry {\n    test.method(1);\n}catch(MyException | IOException e){// 不同异常的处理逻辑相同则可以简写\n    e.printStackTrace();\n} finally {\n    System.out.println(\"最后执行\");\n}\n\n\n// try-with-resource语法，声明的资源会自动关闭，无需在finally手动执行\ntry (BufferedReader br = new BufferedReader(new FileReader(\"\"))) {\n     br.readLine();\n} catch (IOException e) {\n    e.printStackTrace();\n}\n{% endcodeblock %}\n\n  用catch捕捉异常可以通过捕捉对应异常的父类异常，例如上述例子中可以这么写\n   \n{% codeblock lang:java %}\ntry {// 执行逻辑\n    test.method(1);\n}catch(Exception e){// 异常捕捉\n    e.printStackTrace();\n}finally {\n    // 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑\n    System.out.println(\"最后执行\");\n}\n{% endcodeblock %}    \n\n  因为Exception是其他异常的父类，所以可以捕捉到方法抛出的两种异常。当然，虽然这样看上去更加\n  简洁，但是异常信息就不够明确，所以一般情况不建议这样做。\n  因此，catch异常的顺序也需要特别注意，如果把大的异常(即父类异常)放到前面，由于对异常的匹配\n  寻找是按顺序来的，后面的小异常可能永远不会派上用场。\n\n#### 自定义异常\n\n  除了Java已经定义好的异常类，我们也可以根据自己的需求自定义异常类\n\n{% codeblock lang:java %}\n// 自定义异常需要继承Exception或其子类\npublic class MyException extends Exception {\n    private String code;\n    private String msg;\n\n    public MyException() {\n\n    }\n    // Exception提供了不同的有参构造方法\n    public MyException(String code, String msg) {\n        super(msg);\n        this.code = code;\n        this.msg = msg;\n    }\n    // 重写getMessage()方法以实现定制化的信息输出\n    @Override\n    public String getMessage() {\n        return \"MyException detail:\" + code + \"-\" + msg;\n    }\n}\n{% endcodeblock %}\n\n#### 异常的栈轨迹\n  \n  通常我们用*e.printStackTrace();*输出异常信息的时候可以看到一行行的方法地址。这就是异常的栈轨迹，表示异常一步步抛出到最外面的轨迹。\n\n{% codeblock lang:java %}\n  public void method(float f) {\n    InterfaceTest test = new Product();\n    try {\n        throw new MyException();\n    }catch(MyException e){\n        e.printStackTrace();\n        for(StackTraceElement ste:e.getStackTrace()){\n            System.out.println(ste.getMethodName());\n        }\n    }\n}\npublic void numberTwo(){method(1);}\npublic void numberThree(){numberTwo();}\n{% endcodeblock %}\n\n  比如上面这样层层调用，通过*e.getStackTrace()*获取栈轨迹的数组，然后逐个输出，就能看到如下结果\n\n     method\n     numberTwo\n     numberThree\n     main\n  \n  能够看到每一步调用的方法。\n  \n#### 异常链\n  \n  如果捕捉异常后，抛出新的异常，那么会丢失原异常的信息。\n  这时可以通过Exception的构造方法保留原异常的信息：\n\n{% codeblock lang:java %}\npublic Exception(String message, Throwable cause) {\n    super(message, cause);\n}\n{% endcodeblock %}\n\n  cause参数用来表示原始异常，可以通过这种方法将不同的异常信息串联起来，也被称作异常链。\n\n### 小结\n\n      异常不可避免，但是通过抛出/捕捉处理我们可以自由的控制异常。将他抛到我们需要处理的地方，或者直接\n    捕捉进行处理。这使得代码逻辑能够按照我们所设想的逻辑执行，而不会因为突如其来的异常导致程序中止，偏\n    离了我们的预想。\n      另一方面，对异常的信息输出也很关键了。良好的输出代表着代码有效的反馈，能够帮助开发者快速的定位问\n    题，然后决定如何修改优化。\n\n> 下一章 [\\<ThinkingInJava-8>](https://rel-fly.com/2020/06/17/ThinkingInJava8/)","slug":"ThinkingInJava7","published":1,"updated":"2020-08-15T12:34:05.002Z","_id":"ckdvmudyi0017nwb531r1f4ta","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  错误是代码难以避免的问题。编译器的错误可以直接修改代码，运行期的错误就需要将其传递到其他能处理的地方，这时候就要用到Java的异常机制。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"通过异常处理错误\"><a href=\"#通过异常处理错误\" class=\"headerlink\" title=\"通过异常处理错误\"></a>通过异常处理错误</h3><p>  本书第十二章，主要讲述了Java异常及异常处理的相关内容。</p>\n<h4 id=\"Java异常\"><a href=\"#Java异常\" class=\"headerlink\" title=\"Java异常\"></a>Java异常</h4><p>  Java异常都继承自Throwable，然后其下分为Exception和Error两个子类</p>\n<ol>\n<li><p>Error(错误)<br>Error指一些无法恢复或不能捕捉的严重错误，此类错误会导致程序中断。</p>\n</li>\n<li><p>Exception(异常)<br>Exception又分为运行时异常和非运行时异常</p>\n<ul>\n<li><p>运行时异常<br>继承自Exception子类RuntimeException的异常类，可以被捕捉处理，也可以不处理。<br>常见的包括：NullPointerException，IndexOutOfBoundsException等</p>\n</li>\n<li><p>非运行时异常<br>继承自Exception的非RuntimeException的异常类，统称为非运行时异常。<br>这种异常必须要捕捉处理，否则编译无法通过。<br>常见的如：IOException</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"异常的处理\"><a href=\"#异常的处理\" class=\"headerlink\" title=\"异常的处理\"></a>异常的处理</h4><ol>\n<li><p>抛出异常<br>异常抛出的关键字有两个throw和throws，他们的区别很大：<br>throw：强调的是抛出异常的这个动作，只在方法体中使用<br>throws：是对方法可能抛出异常的声明，相当于告诉其他开发者这个方法可能抛出什么异常，需要处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手动抛出异常，程序中止</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"10000\"</span>,<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 声明方法可能抛出的异常，可以声明多个以逗号分隔</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> <span class=\"keyword\">throws</span> MyException, IOException</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>捕获处理异常</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;<span class=\"comment\">// 执行逻辑</span></span><br><span class=\"line\">    test.method(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(MyException e)&#123;<span class=\"comment\">// 异常捕捉</span></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(IOException ioe)&#123;<span class=\"comment\">// 方法抛出的所有异常都要捕捉</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"不同的处理\"</span>);</span><br><span class=\"line\">    ioe.printStackTrace();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"最后执行\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    test.method(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(MyException | IOException e)&#123;<span class=\"comment\">// 不同异常的处理逻辑相同则可以简写</span></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"最后执行\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// try-with-resource语法，声明的资源会自动关闭，无需在finally手动执行</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"\"</span>))) &#123;</span><br><span class=\"line\">     br.readLine();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  用catch捕捉异常可以通过捕捉对应异常的父类异常，例如上述例子中可以这么写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;<span class=\"comment\">// 执行逻辑</span></span><br><span class=\"line\">    test.method(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;<span class=\"comment\">// 异常捕捉</span></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"最后执行\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    \n\n<p>  因为Exception是其他异常的父类，所以可以捕捉到方法抛出的两种异常。当然，虽然这样看上去更加<br>  简洁，但是异常信息就不够明确，所以一般情况不建议这样做。<br>  因此，catch异常的顺序也需要特别注意，如果把大的异常(即父类异常)放到前面，由于对异常的匹配<br>  寻找是按顺序来的，后面的小异常可能永远不会派上用场。</p>\n<h4 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h4><p>  除了Java已经定义好的异常类，我们也可以根据自己的需求自定义异常类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义异常需要继承Exception或其子类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String code;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Exception提供了不同的有参构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyException</span><span class=\"params\">(String code, String msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(msg);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.msg = msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 重写getMessage()方法以实现定制化的信息输出</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"MyException detail:\"</span> + code + <span class=\"string\">\"-\"</span> + msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异常的栈轨迹\"><a href=\"#异常的栈轨迹\" class=\"headerlink\" title=\"异常的栈轨迹\"></a>异常的栈轨迹</h4><p>  通常我们用<em>e.printStackTrace();</em>输出异常信息的时候可以看到一行行的方法地址。这就是异常的栈轨迹，表示异常一步步抛出到最外面的轨迹。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">float</span> f)</span> </span>&#123;</span><br><span class=\"line\">    InterfaceTest test = <span class=\"keyword\">new</span> Product();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(MyException e)&#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(StackTraceElement ste:e.getStackTrace())&#123;</span><br><span class=\"line\">            System.out.println(ste.getMethodName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">numberTwo</span><span class=\"params\">()</span></span>&#123;method(<span class=\"number\">1</span>);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">numberThree</span><span class=\"params\">()</span></span>&#123;numberTwo();&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  比如上面这样层层调用，通过<em>e.getStackTrace()</em>获取栈轨迹的数组，然后逐个输出，就能看到如下结果</p>\n<pre><code>method\nnumberTwo\nnumberThree\nmain</code></pre><p>  能够看到每一步调用的方法。</p>\n<h4 id=\"异常链\"><a href=\"#异常链\" class=\"headerlink\" title=\"异常链\"></a>异常链</h4><p>  如果捕捉异常后，抛出新的异常，那么会丢失原异常的信息。<br>  这时可以通过Exception的构造方法保留原异常的信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Exception</span><span class=\"params\">(String message, Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(message, cause);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  cause参数用来表示原始异常，可以通过这种方法将不同的异常信息串联起来，也被称作异常链。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  异常不可避免，但是通过抛出/捕捉处理我们可以自由的控制异常。将他抛到我们需要处理的地方，或者直接\n捕捉进行处理。这使得代码逻辑能够按照我们所设想的逻辑执行，而不会因为突如其来的异常导致程序中止，偏\n离了我们的预想。\n  另一方面，对异常的信息输出也很关键了。良好的输出代表着代码有效的反馈，能够帮助开发者快速的定位问\n题，然后决定如何修改优化。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/17/ThinkingInJava8/\">&lt;ThinkingInJava-8&gt;</a></p>\n</blockquote>\n","site":{"data":{}},"length":1262,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  错误是代码难以避免的问题。编译器的错误可以直接修改代码，运行期的错误就需要将其传递到其他能处理的地方，这时候就要用到Java的异常机制。</p>","more":"<h3 id=\"通过异常处理错误\"><a href=\"#通过异常处理错误\" class=\"headerlink\" title=\"通过异常处理错误\"></a>通过异常处理错误</h3><p>  本书第十二章，主要讲述了Java异常及异常处理的相关内容。</p>\n<h4 id=\"Java异常\"><a href=\"#Java异常\" class=\"headerlink\" title=\"Java异常\"></a>Java异常</h4><p>  Java异常都继承自Throwable，然后其下分为Exception和Error两个子类</p>\n<ol>\n<li><p>Error(错误)<br>Error指一些无法恢复或不能捕捉的严重错误，此类错误会导致程序中断。</p>\n</li>\n<li><p>Exception(异常)<br>Exception又分为运行时异常和非运行时异常</p>\n<ul>\n<li><p>运行时异常<br>继承自Exception子类RuntimeException的异常类，可以被捕捉处理，也可以不处理。<br>常见的包括：NullPointerException，IndexOutOfBoundsException等</p>\n</li>\n<li><p>非运行时异常<br>继承自Exception的非RuntimeException的异常类，统称为非运行时异常。<br>这种异常必须要捕捉处理，否则编译无法通过。<br>常见的如：IOException</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"异常的处理\"><a href=\"#异常的处理\" class=\"headerlink\" title=\"异常的处理\"></a>异常的处理</h4><ol>\n<li><p>抛出异常<br>异常抛出的关键字有两个throw和throws，他们的区别很大：<br>throw：强调的是抛出异常的这个动作，只在方法体中使用<br>throws：是对方法可能抛出异常的声明，相当于告诉其他开发者这个方法可能抛出什么异常，需要处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手动抛出异常，程序中止</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException(<span class=\"string\">\"10000\"</span>,<span class=\"string\">\"error\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// 声明方法可能抛出的异常，可以声明多个以逗号分隔</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> <span class=\"keyword\">throws</span> MyException, IOException</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>捕获处理异常</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;<span class=\"comment\">// 执行逻辑</span></span><br><span class=\"line\">    test.method(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(MyException e)&#123;<span class=\"comment\">// 异常捕捉</span></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(IOException ioe)&#123;<span class=\"comment\">// 方法抛出的所有异常都要捕捉</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"不同的处理\"</span>);</span><br><span class=\"line\">    ioe.printStackTrace();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"最后执行\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    test.method(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(MyException | IOException e)&#123;<span class=\"comment\">// 不同异常的处理逻辑相同则可以简写</span></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"最后执行\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// try-with-resource语法，声明的资源会自动关闭，无需在finally手动执行</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (BufferedReader br = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"string\">\"\"</span>))) &#123;</span><br><span class=\"line\">     br.readLine();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  用catch捕捉异常可以通过捕捉对应异常的父类异常，例如上述例子中可以这么写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;<span class=\"comment\">// 执行逻辑</span></span><br><span class=\"line\">    test.method(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(Exception e)&#123;<span class=\"comment\">// 异常捕捉</span></span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最后执行的代码块，无论是否发生异常都会执行，通常用来执行一些资源的关闭逻辑</span></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"最后执行\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    \n\n<p>  因为Exception是其他异常的父类，所以可以捕捉到方法抛出的两种异常。当然，虽然这样看上去更加<br>  简洁，但是异常信息就不够明确，所以一般情况不建议这样做。<br>  因此，catch异常的顺序也需要特别注意，如果把大的异常(即父类异常)放到前面，由于对异常的匹配<br>  寻找是按顺序来的，后面的小异常可能永远不会派上用场。</p>\n<h4 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h4><p>  除了Java已经定义好的异常类，我们也可以根据自己的需求自定义异常类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义异常需要继承Exception或其子类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyException</span> <span class=\"keyword\">extends</span> <span class=\"title\">Exception</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String code;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String msg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyException</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Exception提供了不同的有参构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyException</span><span class=\"params\">(String code, String msg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(msg);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.msg = msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 重写getMessage()方法以实现定制化的信息输出</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"MyException detail:\"</span> + code + <span class=\"string\">\"-\"</span> + msg;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异常的栈轨迹\"><a href=\"#异常的栈轨迹\" class=\"headerlink\" title=\"异常的栈轨迹\"></a>异常的栈轨迹</h4><p>  通常我们用<em>e.printStackTrace();</em>输出异常信息的时候可以看到一行行的方法地址。这就是异常的栈轨迹，表示异常一步步抛出到最外面的轨迹。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">(<span class=\"keyword\">float</span> f)</span> </span>&#123;</span><br><span class=\"line\">    InterfaceTest test = <span class=\"keyword\">new</span> Product();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MyException();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(MyException e)&#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(StackTraceElement ste:e.getStackTrace())&#123;</span><br><span class=\"line\">            System.out.println(ste.getMethodName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">numberTwo</span><span class=\"params\">()</span></span>&#123;method(<span class=\"number\">1</span>);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">numberThree</span><span class=\"params\">()</span></span>&#123;numberTwo();&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  比如上面这样层层调用，通过<em>e.getStackTrace()</em>获取栈轨迹的数组，然后逐个输出，就能看到如下结果</p>\n<pre><code>method\nnumberTwo\nnumberThree\nmain</code></pre><p>  能够看到每一步调用的方法。</p>\n<h4 id=\"异常链\"><a href=\"#异常链\" class=\"headerlink\" title=\"异常链\"></a>异常链</h4><p>  如果捕捉异常后，抛出新的异常，那么会丢失原异常的信息。<br>  这时可以通过Exception的构造方法保留原异常的信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Exception</span><span class=\"params\">(String message, Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(message, cause);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  cause参数用来表示原始异常，可以通过这种方法将不同的异常信息串联起来，也被称作异常链。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  异常不可避免，但是通过抛出/捕捉处理我们可以自由的控制异常。将他抛到我们需要处理的地方，或者直接\n捕捉进行处理。这使得代码逻辑能够按照我们所设想的逻辑执行，而不会因为突如其来的异常导致程序中止，偏\n离了我们的预想。\n  另一方面，对异常的信息输出也很关键了。良好的输出代表着代码有效的反馈，能够帮助开发者快速的定位问\n题，然后决定如何修改优化。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/17/ThinkingInJava8/\">&lt;ThinkingInJava-8&gt;</a></p>\n</blockquote>"},{"title":"ThinkingInJava-8","date":"2020-06-17T02:33:35.000Z","_content":"\n### 前言\n\n  String应该是Java中较为特殊的对象。一方面他的使用场景非常多，其丰富的方法使得String类型的数据非常容易\n  处理。另一方面，他的不可变的特性也让其区分于其他对象。怎么理解String的不可变，以及他与StringBuilder和StringBuffer的区别等问题也是在面试中会问到的问题。\n<!-- more -->\n\n\n### 字符串\n   \n   本书第十三章，围绕String，介绍了String的不可变特性，StringBuilder对某些场景下String操作的优化，及正则表达式等内容。\n\n#### 不可变的String\n\n  作为我们用到的最多的一个对象之一，他的不可变让其显得有点特殊。对于参数的类型可能会这样区分：基本类型，String类型，集合类型，其他对象类型。\n  那么如何理解String的不可变呢？\n\n  首先从源码上看：\n{% codeblock lang:java %}\npublic final class String \n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    // 存放字符串数据的char数组.\n    private final char value[];\n{% endcodeblock %}\n  \n  可以看到，String类从以下三个方面保证了不可变：\n\n  1. 类不可继承，这就防止了子类的修改\n  2. 数组value用final修饰，表示指向数组的引用值不可变(但是数组本身是可变的)\n  3. 数组value用private修饰，避免外部访问修改数组，而String类本身也没有修改数组的操作，这就保证了数组的不变\n\n\n  综上三点是保证String不可变的实现逻辑。\n  然后我们看看，String的不可变为我们带来什么：\n{% codeblock lang:java %}\npublic static void main(String[] args) {\n    int i = 1;\n    String s = \"aaa\";\n    ClassChild cc = new ClassChild(i, s);\n    stringTest(i, s, cc);\n    logger.info(\"result1:{},{},{}\", i, s, cc);\n    stringTest2(i, s, cc);\n    logger.info(\"result2:{},{},{}\", i, s, cc);\n}\n\npublic void stringTest(int i, String param, ClassChild object) {\n    i = 2;\n    param = \"bbb\";\n    object.a = 2;\n    object.b = \"bbb\";\n}\n\npublic void stringTest2(int i, String param, ClassChild object) {\n    i = 3;\n    String newStr = \"ccc\";\n    param = newStr;\n    ClassChild cc = new ClassChild(3, \"ccc\");\n    object = cc;\n}\n// output:\n// result1:1,aaa,{\"a\":2,\"b\":\"bbb\"}\n// result2:1,aaa,{\"a\":2,\"b\":\"bbb\"}\n{% endcodeblock %}\n  \n  可以看到，同样是对象，传参的是引用值，String类型的原对象不变，而普通对象的原值变了。\n  对于给String类型重新赋值的操作,其实可以理解为新建了一个String对象然后将引用改为指向这个新对象。就如方法*stringTest2()* 的操作一样。\n  \n  另一点，已经定义过的字符串都会放在字符串常量池里。如果新建一个String对象，会首先去池里找有没有现成的，有则直接指向他，没有才会创建并放入常量池，这节省了大量的内存空间。\n\n#### StringBuilder和StringBuffer\n\n  StringBuilder和StringBuffer都继承了抽象类AbstractStringBuilder。两者是为了在某些场景下替换String的使用，作为一种优化方案。\n  他们的不同之处只在于StringBuffer的方法都用synchronized修饰，所以是线程安全的。\n{% codeblock lang:java %}\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    // 存储字符的数组\n    char[] value;\n{% endcodeblock%}\n\n  可以看到存放字符串的数组并不是private final，这就是StringBuiler，StringBuffer与String的最大区别，前者是可变的。\n{% codeblock lang:java %}\npublic static void main(String[] args) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(1);\n    logger.info(\"result:{}\", sb);\n    sbTest(sb);\n    logger.info(\"result:{}\", sb);\n}\npublic void sbTest(StringBuilder sb) {\n    sb.append(2);\n}\n// output:\n// result:1\n// result:12\n{% endcodeblock %}\n\n#### 正则表达式\n\n  正则表达式是过滤字符串和格式校验等方面极好用高效的工具。\n  正则表达式通过通配符构建匹配规则，然后针对目标字符串进行匹配处理。这里就不详细叙述他的规则了，简单介绍下Java中的用法。\n{% codeblock lang:java %}\nString regText = \"^[1-5]{1,3}$\";\nString checkText1 = \"1111\";\nString checkText2 = \"33\";\nString checkText3 = \"888\";\nlogger.info(\"result1:{}\", Pattern.matches(regText, checkText1));\nlogger.info(\"result2:{}\", Pattern.matches(regText, checkText2));\nlogger.info(\"result3:{}\", Pattern.matches(regText, checkText3));\n// output:\n// result1:false\n// result2:true\n// result3:false\n{% endcodeblock %}\n\n  上面就是一个很简单使用正则校验字符串的例子。\n  当我们对一些复杂的正则表达式很难快速理解的时候，可以借助正则表达式的可视化工具，这里推荐*regexper*。\n\n### 小结\n  \n      对于String，我们用得很多，但不一定理解的很深。String最重要的就是理解他的不可变，会有什么效\n    果，能有什么好处，什么时候用StringBuilder和StringBuffer等。\n      本章只是着重记录了对String不可变的理解，其实String的源码包括StringBuilder及StringBuffer\n    的源码都很值得一看。而且阅读源码才能够深入理解String。所以这里就简单的记录下，更多内容放在之后\n    对其源码解读上吧。\n\n> 下一章 [\\<ThinkingInJava-9>](https://rel-fly.com/2020/06/19/ThinkingInJava9/)","source":"_posts/2020/06/ThinkingInJava8.md","raw":"---\ntitle: ThinkingInJava-8\ndate: 2020-06-17 10:33:35\ntags:\n- ThinkingInJava\ncategories:\n- 读书笔记\n- ThinkingInJava\n---\n\n### 前言\n\n  String应该是Java中较为特殊的对象。一方面他的使用场景非常多，其丰富的方法使得String类型的数据非常容易\n  处理。另一方面，他的不可变的特性也让其区分于其他对象。怎么理解String的不可变，以及他与StringBuilder和StringBuffer的区别等问题也是在面试中会问到的问题。\n<!-- more -->\n\n\n### 字符串\n   \n   本书第十三章，围绕String，介绍了String的不可变特性，StringBuilder对某些场景下String操作的优化，及正则表达式等内容。\n\n#### 不可变的String\n\n  作为我们用到的最多的一个对象之一，他的不可变让其显得有点特殊。对于参数的类型可能会这样区分：基本类型，String类型，集合类型，其他对象类型。\n  那么如何理解String的不可变呢？\n\n  首先从源码上看：\n{% codeblock lang:java %}\npublic final class String \n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    // 存放字符串数据的char数组.\n    private final char value[];\n{% endcodeblock %}\n  \n  可以看到，String类从以下三个方面保证了不可变：\n\n  1. 类不可继承，这就防止了子类的修改\n  2. 数组value用final修饰，表示指向数组的引用值不可变(但是数组本身是可变的)\n  3. 数组value用private修饰，避免外部访问修改数组，而String类本身也没有修改数组的操作，这就保证了数组的不变\n\n\n  综上三点是保证String不可变的实现逻辑。\n  然后我们看看，String的不可变为我们带来什么：\n{% codeblock lang:java %}\npublic static void main(String[] args) {\n    int i = 1;\n    String s = \"aaa\";\n    ClassChild cc = new ClassChild(i, s);\n    stringTest(i, s, cc);\n    logger.info(\"result1:{},{},{}\", i, s, cc);\n    stringTest2(i, s, cc);\n    logger.info(\"result2:{},{},{}\", i, s, cc);\n}\n\npublic void stringTest(int i, String param, ClassChild object) {\n    i = 2;\n    param = \"bbb\";\n    object.a = 2;\n    object.b = \"bbb\";\n}\n\npublic void stringTest2(int i, String param, ClassChild object) {\n    i = 3;\n    String newStr = \"ccc\";\n    param = newStr;\n    ClassChild cc = new ClassChild(3, \"ccc\");\n    object = cc;\n}\n// output:\n// result1:1,aaa,{\"a\":2,\"b\":\"bbb\"}\n// result2:1,aaa,{\"a\":2,\"b\":\"bbb\"}\n{% endcodeblock %}\n  \n  可以看到，同样是对象，传参的是引用值，String类型的原对象不变，而普通对象的原值变了。\n  对于给String类型重新赋值的操作,其实可以理解为新建了一个String对象然后将引用改为指向这个新对象。就如方法*stringTest2()* 的操作一样。\n  \n  另一点，已经定义过的字符串都会放在字符串常量池里。如果新建一个String对象，会首先去池里找有没有现成的，有则直接指向他，没有才会创建并放入常量池，这节省了大量的内存空间。\n\n#### StringBuilder和StringBuffer\n\n  StringBuilder和StringBuffer都继承了抽象类AbstractStringBuilder。两者是为了在某些场景下替换String的使用，作为一种优化方案。\n  他们的不同之处只在于StringBuffer的方法都用synchronized修饰，所以是线程安全的。\n{% codeblock lang:java %}\nabstract class AbstractStringBuilder implements Appendable, CharSequence {\n    // 存储字符的数组\n    char[] value;\n{% endcodeblock%}\n\n  可以看到存放字符串的数组并不是private final，这就是StringBuiler，StringBuffer与String的最大区别，前者是可变的。\n{% codeblock lang:java %}\npublic static void main(String[] args) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(1);\n    logger.info(\"result:{}\", sb);\n    sbTest(sb);\n    logger.info(\"result:{}\", sb);\n}\npublic void sbTest(StringBuilder sb) {\n    sb.append(2);\n}\n// output:\n// result:1\n// result:12\n{% endcodeblock %}\n\n#### 正则表达式\n\n  正则表达式是过滤字符串和格式校验等方面极好用高效的工具。\n  正则表达式通过通配符构建匹配规则，然后针对目标字符串进行匹配处理。这里就不详细叙述他的规则了，简单介绍下Java中的用法。\n{% codeblock lang:java %}\nString regText = \"^[1-5]{1,3}$\";\nString checkText1 = \"1111\";\nString checkText2 = \"33\";\nString checkText3 = \"888\";\nlogger.info(\"result1:{}\", Pattern.matches(regText, checkText1));\nlogger.info(\"result2:{}\", Pattern.matches(regText, checkText2));\nlogger.info(\"result3:{}\", Pattern.matches(regText, checkText3));\n// output:\n// result1:false\n// result2:true\n// result3:false\n{% endcodeblock %}\n\n  上面就是一个很简单使用正则校验字符串的例子。\n  当我们对一些复杂的正则表达式很难快速理解的时候，可以借助正则表达式的可视化工具，这里推荐*regexper*。\n\n### 小结\n  \n      对于String，我们用得很多，但不一定理解的很深。String最重要的就是理解他的不可变，会有什么效\n    果，能有什么好处，什么时候用StringBuilder和StringBuffer等。\n      本章只是着重记录了对String不可变的理解，其实String的源码包括StringBuilder及StringBuffer\n    的源码都很值得一看。而且阅读源码才能够深入理解String。所以这里就简单的记录下，更多内容放在之后\n    对其源码解读上吧。\n\n> 下一章 [\\<ThinkingInJava-9>](https://rel-fly.com/2020/06/19/ThinkingInJava9/)","slug":"ThinkingInJava8","published":1,"updated":"2020-08-15T12:34:05.002Z","_id":"ckdvmudyi0019nwb55ax70afp","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  String应该是Java中较为特殊的对象。一方面他的使用场景非常多，其丰富的方法使得String类型的数据非常容易<br>  处理。另一方面，他的不可变的特性也让其区分于其他对象。怎么理解String的不可变，以及他与StringBuilder和StringBuffer的区别等问题也是在面试中会问到的问题。</p>\n<a id=\"more\"></a>\n\n\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>   本书第十三章，围绕String，介绍了String的不可变特性，StringBuilder对某些场景下String操作的优化，及正则表达式等内容。</p>\n<h4 id=\"不可变的String\"><a href=\"#不可变的String\" class=\"headerlink\" title=\"不可变的String\"></a>不可变的String</h4><p>  作为我们用到的最多的一个对象之一，他的不可变让其显得有点特殊。对于参数的类型可能会这样区分：基本类型，String类型，集合类型，其他对象类型。<br>  那么如何理解String的不可变呢？</p>\n<p>  首先从源码上看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存放字符串数据的char数组.</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br></pre></td></tr></table></figure>\n\n<p>  可以看到，String类从以下三个方面保证了不可变：</p>\n<ol>\n<li>类不可继承，这就防止了子类的修改</li>\n<li>数组value用final修饰，表示指向数组的引用值不可变(但是数组本身是可变的)</li>\n<li>数组value用private修饰，避免外部访问修改数组，而String类本身也没有修改数组的操作，这就保证了数组的不变</li>\n</ol>\n<p>  综上三点是保证String不可变的实现逻辑。<br>  然后我们看看，String的不可变为我们带来什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    String s = <span class=\"string\">\"aaa\"</span>;</span><br><span class=\"line\">    ClassChild cc = <span class=\"keyword\">new</span> ClassChild(i, s);</span><br><span class=\"line\">    stringTest(i, s, cc);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"result1:&#123;&#125;,&#123;&#125;,&#123;&#125;\"</span>, i, s, cc);</span><br><span class=\"line\">    stringTest2(i, s, cc);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"result2:&#123;&#125;,&#123;&#125;,&#123;&#125;\"</span>, i, s, cc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stringTest</span><span class=\"params\">(<span class=\"keyword\">int</span> i, String param, ClassChild object)</span> </span>&#123;</span><br><span class=\"line\">    i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    param = <span class=\"string\">\"bbb\"</span>;</span><br><span class=\"line\">    object.a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    object.b = <span class=\"string\">\"bbb\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stringTest2</span><span class=\"params\">(<span class=\"keyword\">int</span> i, String param, ClassChild object)</span> </span>&#123;</span><br><span class=\"line\">    i = <span class=\"number\">3</span>;</span><br><span class=\"line\">    String newStr = <span class=\"string\">\"ccc\"</span>;</span><br><span class=\"line\">    param = newStr;</span><br><span class=\"line\">    ClassChild cc = <span class=\"keyword\">new</span> ClassChild(<span class=\"number\">3</span>, <span class=\"string\">\"ccc\"</span>);</span><br><span class=\"line\">    object = cc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// result1:1,aaa,&#123;\"a\":2,\"b\":\"bbb\"&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// result2:1,aaa,&#123;\"a\":2,\"b\":\"bbb\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>  可以看到，同样是对象，传参的是引用值，String类型的原对象不变，而普通对象的原值变了。<br>  对于给String类型重新赋值的操作,其实可以理解为新建了一个String对象然后将引用改为指向这个新对象。就如方法<em>stringTest2()</em> 的操作一样。</p>\n<p>  另一点，已经定义过的字符串都会放在字符串常量池里。如果新建一个String对象，会首先去池里找有没有现成的，有则直接指向他，没有才会创建并放入常量池，这节省了大量的内存空间。</p>\n<h4 id=\"StringBuilder和StringBuffer\"><a href=\"#StringBuilder和StringBuffer\" class=\"headerlink\" title=\"StringBuilder和StringBuffer\"></a>StringBuilder和StringBuffer</h4><p>  StringBuilder和StringBuffer都继承了抽象类AbstractStringBuilder。两者是为了在某些场景下替换String的使用，作为一种优化方案。<br>  他们的不同之处只在于StringBuffer的方法都用synchronized修饰，所以是线程安全的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractStringBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Appendable</span>, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储字符的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] value;</span><br></pre></td></tr></table></figure>\n\n<p>  可以看到存放字符串的数组并不是private final，这就是StringBuiler，StringBuffer与String的最大区别，前者是可变的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    sb.append(<span class=\"number\">1</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"result:&#123;&#125;\"</span>, sb);</span><br><span class=\"line\">    sbTest(sb);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"result:&#123;&#125;\"</span>, sb);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sbTest</span><span class=\"params\">(StringBuilder sb)</span> </span>&#123;</span><br><span class=\"line\">    sb.append(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// result:1</span></span><br><span class=\"line\"><span class=\"comment\">// result:12</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><p>  正则表达式是过滤字符串和格式校验等方面极好用高效的工具。<br>  正则表达式通过通配符构建匹配规则，然后针对目标字符串进行匹配处理。这里就不详细叙述他的规则了，简单介绍下Java中的用法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String regText = <span class=\"string\">\"^[1-5]&#123;1,3&#125;$\"</span>;</span><br><span class=\"line\">String checkText1 = <span class=\"string\">\"1111\"</span>;</span><br><span class=\"line\">String checkText2 = <span class=\"string\">\"33\"</span>;</span><br><span class=\"line\">String checkText3 = <span class=\"string\">\"888\"</span>;</span><br><span class=\"line\">logger.info(<span class=\"string\">\"result1:&#123;&#125;\"</span>, Pattern.matches(regText, checkText1));</span><br><span class=\"line\">logger.info(<span class=\"string\">\"result2:&#123;&#125;\"</span>, Pattern.matches(regText, checkText2));</span><br><span class=\"line\">logger.info(<span class=\"string\">\"result3:&#123;&#125;\"</span>, Pattern.matches(regText, checkText3));</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// result1:false</span></span><br><span class=\"line\"><span class=\"comment\">// result2:true</span></span><br><span class=\"line\"><span class=\"comment\">// result3:false</span></span><br></pre></td></tr></table></figure>\n\n<p>  上面就是一个很简单使用正则校验字符串的例子。<br>  当我们对一些复杂的正则表达式很难快速理解的时候，可以借助正则表达式的可视化工具，这里推荐<em>regexper</em>。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  对于String，我们用得很多，但不一定理解的很深。String最重要的就是理解他的不可变，会有什么效\n果，能有什么好处，什么时候用StringBuilder和StringBuffer等。\n  本章只是着重记录了对String不可变的理解，其实String的源码包括StringBuilder及StringBuffer\n的源码都很值得一看。而且阅读源码才能够深入理解String。所以这里就简单的记录下，更多内容放在之后\n对其源码解读上吧。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/19/ThinkingInJava9/\">&lt;ThinkingInJava-9&gt;</a></p>\n</blockquote>\n","site":{"data":{}},"length":1386,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  String应该是Java中较为特殊的对象。一方面他的使用场景非常多，其丰富的方法使得String类型的数据非常容易<br>  处理。另一方面，他的不可变的特性也让其区分于其他对象。怎么理解String的不可变，以及他与StringBuilder和StringBuffer的区别等问题也是在面试中会问到的问题。</p>","more":"<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>   本书第十三章，围绕String，介绍了String的不可变特性，StringBuilder对某些场景下String操作的优化，及正则表达式等内容。</p>\n<h4 id=\"不可变的String\"><a href=\"#不可变的String\" class=\"headerlink\" title=\"不可变的String\"></a>不可变的String</h4><p>  作为我们用到的最多的一个对象之一，他的不可变让其显得有点特殊。对于参数的类型可能会这样区分：基本类型，String类型，集合类型，其他对象类型。<br>  那么如何理解String的不可变呢？</p>\n<p>  首先从源码上看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Comparable</span>&lt;<span class=\"title\">String</span>&gt;, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存放字符串数据的char数组.</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span> value[];</span><br></pre></td></tr></table></figure>\n\n<p>  可以看到，String类从以下三个方面保证了不可变：</p>\n<ol>\n<li>类不可继承，这就防止了子类的修改</li>\n<li>数组value用final修饰，表示指向数组的引用值不可变(但是数组本身是可变的)</li>\n<li>数组value用private修饰，避免外部访问修改数组，而String类本身也没有修改数组的操作，这就保证了数组的不变</li>\n</ol>\n<p>  综上三点是保证String不可变的实现逻辑。<br>  然后我们看看，String的不可变为我们带来什么：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    String s = <span class=\"string\">\"aaa\"</span>;</span><br><span class=\"line\">    ClassChild cc = <span class=\"keyword\">new</span> ClassChild(i, s);</span><br><span class=\"line\">    stringTest(i, s, cc);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"result1:&#123;&#125;,&#123;&#125;,&#123;&#125;\"</span>, i, s, cc);</span><br><span class=\"line\">    stringTest2(i, s, cc);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"result2:&#123;&#125;,&#123;&#125;,&#123;&#125;\"</span>, i, s, cc);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stringTest</span><span class=\"params\">(<span class=\"keyword\">int</span> i, String param, ClassChild object)</span> </span>&#123;</span><br><span class=\"line\">    i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    param = <span class=\"string\">\"bbb\"</span>;</span><br><span class=\"line\">    object.a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    object.b = <span class=\"string\">\"bbb\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stringTest2</span><span class=\"params\">(<span class=\"keyword\">int</span> i, String param, ClassChild object)</span> </span>&#123;</span><br><span class=\"line\">    i = <span class=\"number\">3</span>;</span><br><span class=\"line\">    String newStr = <span class=\"string\">\"ccc\"</span>;</span><br><span class=\"line\">    param = newStr;</span><br><span class=\"line\">    ClassChild cc = <span class=\"keyword\">new</span> ClassChild(<span class=\"number\">3</span>, <span class=\"string\">\"ccc\"</span>);</span><br><span class=\"line\">    object = cc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// result1:1,aaa,&#123;\"a\":2,\"b\":\"bbb\"&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// result2:1,aaa,&#123;\"a\":2,\"b\":\"bbb\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>  可以看到，同样是对象，传参的是引用值，String类型的原对象不变，而普通对象的原值变了。<br>  对于给String类型重新赋值的操作,其实可以理解为新建了一个String对象然后将引用改为指向这个新对象。就如方法<em>stringTest2()</em> 的操作一样。</p>\n<p>  另一点，已经定义过的字符串都会放在字符串常量池里。如果新建一个String对象，会首先去池里找有没有现成的，有则直接指向他，没有才会创建并放入常量池，这节省了大量的内存空间。</p>\n<h4 id=\"StringBuilder和StringBuffer\"><a href=\"#StringBuilder和StringBuffer\" class=\"headerlink\" title=\"StringBuilder和StringBuffer\"></a>StringBuilder和StringBuffer</h4><p>  StringBuilder和StringBuffer都继承了抽象类AbstractStringBuilder。两者是为了在某些场景下替换String的使用，作为一种优化方案。<br>  他们的不同之处只在于StringBuffer的方法都用synchronized修饰，所以是线程安全的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractStringBuilder</span> <span class=\"keyword\">implements</span> <span class=\"title\">Appendable</span>, <span class=\"title\">CharSequence</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 存储字符的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] value;</span><br></pre></td></tr></table></figure>\n\n<p>  可以看到存放字符串的数组并不是private final，这就是StringBuiler，StringBuffer与String的最大区别，前者是可变的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    sb.append(<span class=\"number\">1</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"result:&#123;&#125;\"</span>, sb);</span><br><span class=\"line\">    sbTest(sb);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"result:&#123;&#125;\"</span>, sb);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sbTest</span><span class=\"params\">(StringBuilder sb)</span> </span>&#123;</span><br><span class=\"line\">    sb.append(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// result:1</span></span><br><span class=\"line\"><span class=\"comment\">// result:12</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h4><p>  正则表达式是过滤字符串和格式校验等方面极好用高效的工具。<br>  正则表达式通过通配符构建匹配规则，然后针对目标字符串进行匹配处理。这里就不详细叙述他的规则了，简单介绍下Java中的用法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String regText = <span class=\"string\">\"^[1-5]&#123;1,3&#125;$\"</span>;</span><br><span class=\"line\">String checkText1 = <span class=\"string\">\"1111\"</span>;</span><br><span class=\"line\">String checkText2 = <span class=\"string\">\"33\"</span>;</span><br><span class=\"line\">String checkText3 = <span class=\"string\">\"888\"</span>;</span><br><span class=\"line\">logger.info(<span class=\"string\">\"result1:&#123;&#125;\"</span>, Pattern.matches(regText, checkText1));</span><br><span class=\"line\">logger.info(<span class=\"string\">\"result2:&#123;&#125;\"</span>, Pattern.matches(regText, checkText2));</span><br><span class=\"line\">logger.info(<span class=\"string\">\"result3:&#123;&#125;\"</span>, Pattern.matches(regText, checkText3));</span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// result1:false</span></span><br><span class=\"line\"><span class=\"comment\">// result2:true</span></span><br><span class=\"line\"><span class=\"comment\">// result3:false</span></span><br></pre></td></tr></table></figure>\n\n<p>  上面就是一个很简单使用正则校验字符串的例子。<br>  当我们对一些复杂的正则表达式很难快速理解的时候，可以借助正则表达式的可视化工具，这里推荐<em>regexper</em>。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  对于String，我们用得很多，但不一定理解的很深。String最重要的就是理解他的不可变，会有什么效\n果，能有什么好处，什么时候用StringBuilder和StringBuffer等。\n  本章只是着重记录了对String不可变的理解，其实String的源码包括StringBuilder及StringBuffer\n的源码都很值得一看。而且阅读源码才能够深入理解String。所以这里就简单的记录下，更多内容放在之后\n对其源码解读上吧。</code></pre><blockquote>\n<p>下一章 <a href=\"https://rel-fly.com/2020/06/19/ThinkingInJava9/\">&lt;ThinkingInJava-9&gt;</a></p>\n</blockquote>"},{"title":"Java-位运算符","date":"2020-06-02T07:01:20.000Z","_content":"\n### 前言\n  在阅读HashMap的源码中，对许多位运算符都分不太清了。所以这里对位运算符做一个复习。\n<!-- more -->\n\n### 位运算符\n  位运算符的特点是会按照二进制去进行运算，例如3&5，先把3和5转化为二进制，然后每一位进行&运算，得出二进制的结果\n\n#### ~  按位非\n\n    运算规则： ~b 先将b转化为二进制数，对每一位进行取反\n    eg: ~3的计算过程\n    3      00000000 00000000 00000000 00000011\n    result 11111111 11111111 11111111 11111100 (负数这里为补码需要转换)\n    -1     11111111 11111111 11111111 11111011 反码\n    ~      10000000 00000000 00000000 00000100 原码 => -4\n\n#### 移位\n\n##### << 和 >>\n    a<<b 左移位操作符，将a的二进制向左移动b位，0补位，等同于乘以2的b次方 \n    eg： 3<<2=12\n    3      00000000 00000000 00000000 00000011\n    ->     00000000 00000000 00000000 00001100\n  \n    a>>b 右移位操作符，将a的二进制向右移动b位，正数0补位，负数1补位，等同于除以2的b次方 \n    eg： 4>>2=1\n    4      00000000 00000000 00000000 00000100\n    ->     00000000 00000000 00000000 00000001\n  \n    eg： -4>>2=-1\n    -4     11111111 11111111 11111111 11111100\n    ->     11111111 11111111 11111111 11111111 (负数这里为补码需要转换)\n    -1     11111111 11111111 11111111 11111110 反码\n    ~      10000000 00000000 00000000 00000001 原码 => -1\n\n\n##### >>>  无符号右移\n\n    类似>>，区别在于不管正数负数都用0补位\n    eg： -4>>>2=1073741823\n    -4     11111111 11111111 11111111 11111100\n    ->     00111111 11111111 11111111 11111111\n\n#### &  按位与\n\n    运算规则： a&b 先将a,b转化为二进制数，当且仅当相同位数都为1时，结果是1，否则为0\n    eg: 3&5的计算过程\n    3      00000000 00000000 00000000 00000011\n    5      00000000 00000000 00000000 00000101\n    result 00000000 00000000 00000000 00000001 => 1\n\n#### |  按位或\n\n    运算规则： a|b 先将a,b转化为二进制数，当且仅当相同位数都为0时，结果是0，否则为1\n    eg: 3|5的计算过程\n    3      00000000 00000000 00000000 00000011\n    5      00000000 00000000 00000000 00000101\n    result 00000000 00000000 00000000 00000111 => 7\n\n#### ^  按位异或\n\n    运算规则： a^b 先将a,b转化为二进制数，当且仅当相同位数只有一个为1时，结果是1，否则为0\n    eg: 3^5的计算过程\n    3      00000000 00000000 00000000 00000011\n    5      00000000 00000000 00000000 00000101\n    result 00000000 00000000 00000000 00000110 => 6","source":"_posts/2020/06/bitwiseOperator.md","raw":"---\ntitle: Java-位运算符\ndate: 2020-06-02 15:01:20\ntags:\n- 位运算符\ncategories:\n- Java\n- 基础\n---\n\n### 前言\n  在阅读HashMap的源码中，对许多位运算符都分不太清了。所以这里对位运算符做一个复习。\n<!-- more -->\n\n### 位运算符\n  位运算符的特点是会按照二进制去进行运算，例如3&5，先把3和5转化为二进制，然后每一位进行&运算，得出二进制的结果\n\n#### ~  按位非\n\n    运算规则： ~b 先将b转化为二进制数，对每一位进行取反\n    eg: ~3的计算过程\n    3      00000000 00000000 00000000 00000011\n    result 11111111 11111111 11111111 11111100 (负数这里为补码需要转换)\n    -1     11111111 11111111 11111111 11111011 反码\n    ~      10000000 00000000 00000000 00000100 原码 => -4\n\n#### 移位\n\n##### << 和 >>\n    a<<b 左移位操作符，将a的二进制向左移动b位，0补位，等同于乘以2的b次方 \n    eg： 3<<2=12\n    3      00000000 00000000 00000000 00000011\n    ->     00000000 00000000 00000000 00001100\n  \n    a>>b 右移位操作符，将a的二进制向右移动b位，正数0补位，负数1补位，等同于除以2的b次方 \n    eg： 4>>2=1\n    4      00000000 00000000 00000000 00000100\n    ->     00000000 00000000 00000000 00000001\n  \n    eg： -4>>2=-1\n    -4     11111111 11111111 11111111 11111100\n    ->     11111111 11111111 11111111 11111111 (负数这里为补码需要转换)\n    -1     11111111 11111111 11111111 11111110 反码\n    ~      10000000 00000000 00000000 00000001 原码 => -1\n\n\n##### >>>  无符号右移\n\n    类似>>，区别在于不管正数负数都用0补位\n    eg： -4>>>2=1073741823\n    -4     11111111 11111111 11111111 11111100\n    ->     00111111 11111111 11111111 11111111\n\n#### &  按位与\n\n    运算规则： a&b 先将a,b转化为二进制数，当且仅当相同位数都为1时，结果是1，否则为0\n    eg: 3&5的计算过程\n    3      00000000 00000000 00000000 00000011\n    5      00000000 00000000 00000000 00000101\n    result 00000000 00000000 00000000 00000001 => 1\n\n#### |  按位或\n\n    运算规则： a|b 先将a,b转化为二进制数，当且仅当相同位数都为0时，结果是0，否则为1\n    eg: 3|5的计算过程\n    3      00000000 00000000 00000000 00000011\n    5      00000000 00000000 00000000 00000101\n    result 00000000 00000000 00000000 00000111 => 7\n\n#### ^  按位异或\n\n    运算规则： a^b 先将a,b转化为二进制数，当且仅当相同位数只有一个为1时，结果是1，否则为0\n    eg: 3^5的计算过程\n    3      00000000 00000000 00000000 00000011\n    5      00000000 00000000 00000000 00000101\n    result 00000000 00000000 00000000 00000110 => 6","slug":"bitwiseOperator","published":1,"updated":"2020-08-15T12:34:05.003Z","_id":"ckdvmudyj001cnwb5cmfhfn75","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  在阅读HashMap的源码中，对许多位运算符都分不太清了。所以这里对位运算符做一个复习。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h3><p>  位运算符的特点是会按照二进制去进行运算，例如3&amp;5，先把3和5转化为二进制，然后每一位进行&amp;运算，得出二进制的结果</p>\n<h4 id=\"按位非\"><a href=\"#按位非\" class=\"headerlink\" title=\"~  按位非\"></a>~  按位非</h4><pre><code>运算规则： ~b 先将b转化为二进制数，对每一位进行取反\neg: ~3的计算过程\n3      00000000 00000000 00000000 00000011\nresult 11111111 11111111 11111111 11111100 (负数这里为补码需要转换)\n-1     11111111 11111111 11111111 11111011 反码\n~      10000000 00000000 00000000 00000100 原码 =&gt; -4</code></pre><h4 id=\"移位\"><a href=\"#移位\" class=\"headerlink\" title=\"移位\"></a>移位</h4><h5 id=\"lt-lt-和-gt-gt\"><a href=\"#lt-lt-和-gt-gt\" class=\"headerlink\" title=\"&lt;&lt; 和 &gt;&gt;\"></a>&lt;&lt; 和 &gt;&gt;</h5><pre><code>a&lt;&lt;b 左移位操作符，将a的二进制向左移动b位，0补位，等同于乘以2的b次方 \neg： 3&lt;&lt;2=12\n3      00000000 00000000 00000000 00000011\n-&gt;     00000000 00000000 00000000 00001100\n\na&gt;&gt;b 右移位操作符，将a的二进制向右移动b位，正数0补位，负数1补位，等同于除以2的b次方 \neg： 4&gt;&gt;2=1\n4      00000000 00000000 00000000 00000100\n-&gt;     00000000 00000000 00000000 00000001\n\neg： -4&gt;&gt;2=-1\n-4     11111111 11111111 11111111 11111100\n-&gt;     11111111 11111111 11111111 11111111 (负数这里为补码需要转换)\n-1     11111111 11111111 11111111 11111110 反码\n~      10000000 00000000 00000000 00000001 原码 =&gt; -1</code></pre><h5 id=\"gt-gt-gt-无符号右移\"><a href=\"#gt-gt-gt-无符号右移\" class=\"headerlink\" title=\"&gt;&gt;&gt;  无符号右移\"></a>&gt;&gt;&gt;  无符号右移</h5><pre><code>类似&gt;&gt;，区别在于不管正数负数都用0补位\neg： -4&gt;&gt;&gt;2=1073741823\n-4     11111111 11111111 11111111 11111100\n-&gt;     00111111 11111111 11111111 11111111</code></pre><h4 id=\"amp-按位与\"><a href=\"#amp-按位与\" class=\"headerlink\" title=\"&amp;  按位与\"></a>&amp;  按位与</h4><pre><code>运算规则： a&amp;b 先将a,b转化为二进制数，当且仅当相同位数都为1时，结果是1，否则为0\neg: 3&amp;5的计算过程\n3      00000000 00000000 00000000 00000011\n5      00000000 00000000 00000000 00000101\nresult 00000000 00000000 00000000 00000001 =&gt; 1</code></pre><h4 id=\"按位或\"><a href=\"#按位或\" class=\"headerlink\" title=\"|  按位或\"></a>|  按位或</h4><pre><code>运算规则： a|b 先将a,b转化为二进制数，当且仅当相同位数都为0时，结果是0，否则为1\neg: 3|5的计算过程\n3      00000000 00000000 00000000 00000011\n5      00000000 00000000 00000000 00000101\nresult 00000000 00000000 00000000 00000111 =&gt; 7</code></pre><h4 id=\"按位异或\"><a href=\"#按位异或\" class=\"headerlink\" title=\"^  按位异或\"></a>^  按位异或</h4><pre><code>运算规则： a^b 先将a,b转化为二进制数，当且仅当相同位数只有一个为1时，结果是1，否则为0\neg: 3^5的计算过程\n3      00000000 00000000 00000000 00000011\n5      00000000 00000000 00000000 00000101\nresult 00000000 00000000 00000000 00000110 =&gt; 6</code></pre>","site":{"data":{}},"length":1445,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  在阅读HashMap的源码中，对许多位运算符都分不太清了。所以这里对位运算符做一个复习。</p>","more":"<h3 id=\"位运算符\"><a href=\"#位运算符\" class=\"headerlink\" title=\"位运算符\"></a>位运算符</h3><p>  位运算符的特点是会按照二进制去进行运算，例如3&amp;5，先把3和5转化为二进制，然后每一位进行&amp;运算，得出二进制的结果</p>\n<h4 id=\"按位非\"><a href=\"#按位非\" class=\"headerlink\" title=\"~  按位非\"></a>~  按位非</h4><pre><code>运算规则： ~b 先将b转化为二进制数，对每一位进行取反\neg: ~3的计算过程\n3      00000000 00000000 00000000 00000011\nresult 11111111 11111111 11111111 11111100 (负数这里为补码需要转换)\n-1     11111111 11111111 11111111 11111011 反码\n~      10000000 00000000 00000000 00000100 原码 =&gt; -4</code></pre><h4 id=\"移位\"><a href=\"#移位\" class=\"headerlink\" title=\"移位\"></a>移位</h4><h5 id=\"lt-lt-和-gt-gt\"><a href=\"#lt-lt-和-gt-gt\" class=\"headerlink\" title=\"&lt;&lt; 和 &gt;&gt;\"></a>&lt;&lt; 和 &gt;&gt;</h5><pre><code>a&lt;&lt;b 左移位操作符，将a的二进制向左移动b位，0补位，等同于乘以2的b次方 \neg： 3&lt;&lt;2=12\n3      00000000 00000000 00000000 00000011\n-&gt;     00000000 00000000 00000000 00001100\n\na&gt;&gt;b 右移位操作符，将a的二进制向右移动b位，正数0补位，负数1补位，等同于除以2的b次方 \neg： 4&gt;&gt;2=1\n4      00000000 00000000 00000000 00000100\n-&gt;     00000000 00000000 00000000 00000001\n\neg： -4&gt;&gt;2=-1\n-4     11111111 11111111 11111111 11111100\n-&gt;     11111111 11111111 11111111 11111111 (负数这里为补码需要转换)\n-1     11111111 11111111 11111111 11111110 反码\n~      10000000 00000000 00000000 00000001 原码 =&gt; -1</code></pre><h5 id=\"gt-gt-gt-无符号右移\"><a href=\"#gt-gt-gt-无符号右移\" class=\"headerlink\" title=\"&gt;&gt;&gt;  无符号右移\"></a>&gt;&gt;&gt;  无符号右移</h5><pre><code>类似&gt;&gt;，区别在于不管正数负数都用0补位\neg： -4&gt;&gt;&gt;2=1073741823\n-4     11111111 11111111 11111111 11111100\n-&gt;     00111111 11111111 11111111 11111111</code></pre><h4 id=\"amp-按位与\"><a href=\"#amp-按位与\" class=\"headerlink\" title=\"&amp;  按位与\"></a>&amp;  按位与</h4><pre><code>运算规则： a&amp;b 先将a,b转化为二进制数，当且仅当相同位数都为1时，结果是1，否则为0\neg: 3&amp;5的计算过程\n3      00000000 00000000 00000000 00000011\n5      00000000 00000000 00000000 00000101\nresult 00000000 00000000 00000000 00000001 =&gt; 1</code></pre><h4 id=\"按位或\"><a href=\"#按位或\" class=\"headerlink\" title=\"|  按位或\"></a>|  按位或</h4><pre><code>运算规则： a|b 先将a,b转化为二进制数，当且仅当相同位数都为0时，结果是0，否则为1\neg: 3|5的计算过程\n3      00000000 00000000 00000000 00000011\n5      00000000 00000000 00000000 00000101\nresult 00000000 00000000 00000000 00000111 =&gt; 7</code></pre><h4 id=\"按位异或\"><a href=\"#按位异或\" class=\"headerlink\" title=\"^  按位异或\"></a>^  按位异或</h4><pre><code>运算规则： a^b 先将a,b转化为二进制数，当且仅当相同位数只有一个为1时，结果是1，否则为0\neg: 3^5的计算过程\n3      00000000 00000000 00000000 00000011\n5      00000000 00000000 00000000 00000101\nresult 00000000 00000000 00000000 00000110 =&gt; 6</code></pre>"},{"title":"MySql-InnoDB锁","date":"2020-06-03T02:32:30.000Z","_content":"\n### 前言\n\n  在了解分布式锁的过程中看到了MySql锁的相关知识，所以针对MySql-InnoDB锁的相关内容做一个梳理。\n<!-- more -->\n\n### InnoDB锁\n\n  相对于MyISAM，InnoDB的不同之处在于引入了事务，并且主要使用的是行级锁而不是表级锁。\n\n#### InnoDB事务\n\n##### 并发事务的问题\n\n  1. 脏读：事务A的未提交的写操作导致的数据修改被另一个事务读到\n  2. 不可重复读：一个事务内对同一行数据的前后两次查询结果不一样，由其他事务的update，delete操作影响\n  3. 幻读：一个事务内对同一批数据的前后两次查询结果不一样，由其他事务的insert操作影响\n\n##### 事务隔离级别\n\n{% img  /image/innoDBLock/InnoDBLock3.png  '\"事务隔离级别\"' %}\n\n#### InnoDB的锁模式\n\n  InnoDB行级锁是针对索引的索引项加锁，也叫记录锁。如果某个sql没有用到索引，那么就会使用聚集索引。\n  在聚集索引的所有索引项上加锁(类似表级锁)，MySQL之后会进行优化，释放掉不符合条件的索引项的锁。\n  但这个加锁和释放的过程仍然执行了，所以要保证sql尽量用到索引。\n\n##### 共享锁与排他锁\n\n    共享锁(s)：读锁，允许一个事务读一行，并阻止其他事务获取相同数据集的排他锁\n    排他锁(x)：写锁，允许一个事务读/写一行，并阻止其他事务获取相同数据集的排他锁和共享锁\n    updat，insert，delete操作会自动加排他锁，而select默认不加锁，在串行读下会加共享锁\n\n##### 意向锁\n\n\t意向锁属于表级锁，由数据库完成其申请操作，分为意向共享锁和意向排他锁。\n\t其解决的问题是：事务A先获取了表table的一个行级写锁，之后事务B想获取table的表级写锁，为了避免冲突\n\t逐行检查有没有冲突的行级锁，这样明显很浪费时间。\n\n\t而意向锁的作用就是：在事务申请一个行级锁之前，数据库会自动先申请一个意向锁。如果已经有事务持有该表\n\t的表级锁就会等待锁释放，而申请成功后，如果再有事务申请该表的表级锁，也会等待锁释放。这就避免了逐行\n\t检查的开销。\n\n{% img  /image/innoDBLock/InnoDBLock.png  '\"意向锁和表级锁的兼容关系\"' %}\n\n    上图是意向锁和表级共享锁，排他锁的兼容关系(绿色表示兼容，红色表示冲突)，可以看到，意向锁之间是不\n    冲突的。从这里就可以看到，意向锁的主要目的还是解决表级锁和行级锁的冲突。有了意向锁作为一种前置判断\n    可以很方便的进行检查防止冲突。\n\n##### 间隙锁与临键锁\n\n  前面提到，InnoDB的行级锁是针对索引的索引项的，可以设想这样一种情况：\n\n{% img  /image/innoDBLock/InnoDBLock2.png  '\"示例表\"' %}\n\n    对上图的表数据，age字段存在非唯一索引，那么执行以下sql：\n\t事务A：select name,age where age > 4;\n\t\t  update set name = 'xx' where age > 4;\n\t\t  select name,age where age > 4;\n\t事务B：insert into table(id,name,age) values(5,'bb',7);\n\n\t按照前文对行级锁的理解，事务A的update操作会通过age的索引锁定主键索引4并加排他锁，事务B的操作不会\n\t因为锁阻塞。那么这时事务A的第二个查询就会和第一个查询的结果不一样，莫名多了一条数据。\n\n\t为解决这种问题，就使用了间隙锁(GAP-LOCK)\n\t间隙锁(GAP-LOCK)：是指对表中不存在的数据上加锁，一般处于两个数据行的间隙，所以叫间隙锁。用来防止\n\t                 其他事务的新增操作导致幻读，通常会在条件是一个范围的时候使用，而如果条件索引是唯\n\t                 一索引或者结果是唯一值(可以理解为不会因为其他事务的新增操作影响结果)，会放弃间隙\n\t                 锁而只使用记录锁\n\t临键锁(Next-Key)：临键锁比较好理解，他等于记录锁+间隙锁\n\n#### MVCC(多版本并发控制)\n  MVCC通过对每一行数据增加两个隐藏值：事务ID，回滚指针，来实现并发控制。\n  不同事务对一行数据的写操作会产生多个版本，通过回滚指针形成一个链表的结构。\n  读操作不用加锁，可以减少锁的使用和等待等开销。\n\n##### 快照读和当前读\n  根据MVCC的版本记录，就产生了两种读取方式：快照读和当前读\n    快照读：读取记录的可见版本，默认的select就是快照读，不用加锁\n    当前读：读取记录的最新版本并加锁，防止其他事务的操作，属于当前读的操作有\n           1. select …… from …… where …… lock in share mode; 加共享锁\n           2. select …… from …… where …… for update; 加排他锁\n           3. insert，update，delete\n\n##### ReadView\n  ReadView用来控制快照读的可见版本，其操作原理是在生成ReadView时会保存一个当前活跃事务\n  ID的列表，在进行select操作时，会将版本链中数据的事务ID与ReadView中的ID列表比对，判断版本是否可见。\n\n  例如：如果版本的事务ID大于ReadView事务ID列表的最大值，那么说明该版本数据是在生成ReadView之后提交的，自然对当前事务不可见，通过回滚指针遍历之前的版本继续比对。\n\n#### 不同事务隔离级别的区别\n\n1. 未提交读：读不加锁，只读取最新版本数据，可以读到未提交的记录\n2. 已提交读：使用MVCC，select使用快照读，写操作只用记录锁\n            每一次select都会生成一个新的ReadView,所以可以读取提交的数据版本，导致不可重复读\n3. 可重复读：mysql默认隔离级别\n            使用MVCC，select使用快照读，写操作会使用记录锁，间隙锁和临键锁\n            在第一次select时生成一个ReadView，之后不再改变，所以不会读到之后提交的数据版本，\n            保证前后读取的数据一致性(所以这里也可以防止幻读)\n4. 串行读：select加共享锁，读写互斥\n\n#### 死锁\n\n  产生死锁的原因主要就是加锁的顺序不一样，因为MySql的加锁是对符合条件的数据逐行加锁。\n  这就会导致两个事务持有对方需要的锁，导致互相等待，形成死锁\n\n### 小结\n  \n      关于MySql-InnoDB锁的相关知识点，对于基本的行锁的概念和作用其实很好理解，包括事务隔离级别及其避\n    免的并发问题，不过在我阅读相关博客时，对一些细节始终没有找到准确的答案，比如ReadView的具体实现方\n    式，间隙锁的具体情况下的加锁操作。这些之后需要找些相关书籍确定答案，这里就还是做一下小结：\n    1.InnoDB的默认事务隔离级别是可重复读，写操作会涉及锁的加载和释放。所以合理的sql操作及索引配置能\n      够有效减小开销及死锁的风险。这也是sql的优化的一个方向。(所以索引对于sql优化很重要)\n    2.MVCC的版本控制思想是解决并发问题的常用办法，例如：CAS解决aba问题就是添加版本号的方式\n    3.使用select……for update 实现分布式锁就是利用他给行数据添加了排他锁的原理，这样就解决了并发下\n      对同数据集的操作，不过不想使用锁的话就可以借用版本控制的方法，增加一个版本号的字段进行判断","source":"_posts/2020/06/innoDBLock.md","raw":"---\ntitle: MySql-InnoDB锁\ndate: 2020-06-03 10:32:30\ntags:\n- InnoDB锁\ncategories:\n- MySql\n---\n\n### 前言\n\n  在了解分布式锁的过程中看到了MySql锁的相关知识，所以针对MySql-InnoDB锁的相关内容做一个梳理。\n<!-- more -->\n\n### InnoDB锁\n\n  相对于MyISAM，InnoDB的不同之处在于引入了事务，并且主要使用的是行级锁而不是表级锁。\n\n#### InnoDB事务\n\n##### 并发事务的问题\n\n  1. 脏读：事务A的未提交的写操作导致的数据修改被另一个事务读到\n  2. 不可重复读：一个事务内对同一行数据的前后两次查询结果不一样，由其他事务的update，delete操作影响\n  3. 幻读：一个事务内对同一批数据的前后两次查询结果不一样，由其他事务的insert操作影响\n\n##### 事务隔离级别\n\n{% img  /image/innoDBLock/InnoDBLock3.png  '\"事务隔离级别\"' %}\n\n#### InnoDB的锁模式\n\n  InnoDB行级锁是针对索引的索引项加锁，也叫记录锁。如果某个sql没有用到索引，那么就会使用聚集索引。\n  在聚集索引的所有索引项上加锁(类似表级锁)，MySQL之后会进行优化，释放掉不符合条件的索引项的锁。\n  但这个加锁和释放的过程仍然执行了，所以要保证sql尽量用到索引。\n\n##### 共享锁与排他锁\n\n    共享锁(s)：读锁，允许一个事务读一行，并阻止其他事务获取相同数据集的排他锁\n    排他锁(x)：写锁，允许一个事务读/写一行，并阻止其他事务获取相同数据集的排他锁和共享锁\n    updat，insert，delete操作会自动加排他锁，而select默认不加锁，在串行读下会加共享锁\n\n##### 意向锁\n\n\t意向锁属于表级锁，由数据库完成其申请操作，分为意向共享锁和意向排他锁。\n\t其解决的问题是：事务A先获取了表table的一个行级写锁，之后事务B想获取table的表级写锁，为了避免冲突\n\t逐行检查有没有冲突的行级锁，这样明显很浪费时间。\n\n\t而意向锁的作用就是：在事务申请一个行级锁之前，数据库会自动先申请一个意向锁。如果已经有事务持有该表\n\t的表级锁就会等待锁释放，而申请成功后，如果再有事务申请该表的表级锁，也会等待锁释放。这就避免了逐行\n\t检查的开销。\n\n{% img  /image/innoDBLock/InnoDBLock.png  '\"意向锁和表级锁的兼容关系\"' %}\n\n    上图是意向锁和表级共享锁，排他锁的兼容关系(绿色表示兼容，红色表示冲突)，可以看到，意向锁之间是不\n    冲突的。从这里就可以看到，意向锁的主要目的还是解决表级锁和行级锁的冲突。有了意向锁作为一种前置判断\n    可以很方便的进行检查防止冲突。\n\n##### 间隙锁与临键锁\n\n  前面提到，InnoDB的行级锁是针对索引的索引项的，可以设想这样一种情况：\n\n{% img  /image/innoDBLock/InnoDBLock2.png  '\"示例表\"' %}\n\n    对上图的表数据，age字段存在非唯一索引，那么执行以下sql：\n\t事务A：select name,age where age > 4;\n\t\t  update set name = 'xx' where age > 4;\n\t\t  select name,age where age > 4;\n\t事务B：insert into table(id,name,age) values(5,'bb',7);\n\n\t按照前文对行级锁的理解，事务A的update操作会通过age的索引锁定主键索引4并加排他锁，事务B的操作不会\n\t因为锁阻塞。那么这时事务A的第二个查询就会和第一个查询的结果不一样，莫名多了一条数据。\n\n\t为解决这种问题，就使用了间隙锁(GAP-LOCK)\n\t间隙锁(GAP-LOCK)：是指对表中不存在的数据上加锁，一般处于两个数据行的间隙，所以叫间隙锁。用来防止\n\t                 其他事务的新增操作导致幻读，通常会在条件是一个范围的时候使用，而如果条件索引是唯\n\t                 一索引或者结果是唯一值(可以理解为不会因为其他事务的新增操作影响结果)，会放弃间隙\n\t                 锁而只使用记录锁\n\t临键锁(Next-Key)：临键锁比较好理解，他等于记录锁+间隙锁\n\n#### MVCC(多版本并发控制)\n  MVCC通过对每一行数据增加两个隐藏值：事务ID，回滚指针，来实现并发控制。\n  不同事务对一行数据的写操作会产生多个版本，通过回滚指针形成一个链表的结构。\n  读操作不用加锁，可以减少锁的使用和等待等开销。\n\n##### 快照读和当前读\n  根据MVCC的版本记录，就产生了两种读取方式：快照读和当前读\n    快照读：读取记录的可见版本，默认的select就是快照读，不用加锁\n    当前读：读取记录的最新版本并加锁，防止其他事务的操作，属于当前读的操作有\n           1. select …… from …… where …… lock in share mode; 加共享锁\n           2. select …… from …… where …… for update; 加排他锁\n           3. insert，update，delete\n\n##### ReadView\n  ReadView用来控制快照读的可见版本，其操作原理是在生成ReadView时会保存一个当前活跃事务\n  ID的列表，在进行select操作时，会将版本链中数据的事务ID与ReadView中的ID列表比对，判断版本是否可见。\n\n  例如：如果版本的事务ID大于ReadView事务ID列表的最大值，那么说明该版本数据是在生成ReadView之后提交的，自然对当前事务不可见，通过回滚指针遍历之前的版本继续比对。\n\n#### 不同事务隔离级别的区别\n\n1. 未提交读：读不加锁，只读取最新版本数据，可以读到未提交的记录\n2. 已提交读：使用MVCC，select使用快照读，写操作只用记录锁\n            每一次select都会生成一个新的ReadView,所以可以读取提交的数据版本，导致不可重复读\n3. 可重复读：mysql默认隔离级别\n            使用MVCC，select使用快照读，写操作会使用记录锁，间隙锁和临键锁\n            在第一次select时生成一个ReadView，之后不再改变，所以不会读到之后提交的数据版本，\n            保证前后读取的数据一致性(所以这里也可以防止幻读)\n4. 串行读：select加共享锁，读写互斥\n\n#### 死锁\n\n  产生死锁的原因主要就是加锁的顺序不一样，因为MySql的加锁是对符合条件的数据逐行加锁。\n  这就会导致两个事务持有对方需要的锁，导致互相等待，形成死锁\n\n### 小结\n  \n      关于MySql-InnoDB锁的相关知识点，对于基本的行锁的概念和作用其实很好理解，包括事务隔离级别及其避\n    免的并发问题，不过在我阅读相关博客时，对一些细节始终没有找到准确的答案，比如ReadView的具体实现方\n    式，间隙锁的具体情况下的加锁操作。这些之后需要找些相关书籍确定答案，这里就还是做一下小结：\n    1.InnoDB的默认事务隔离级别是可重复读，写操作会涉及锁的加载和释放。所以合理的sql操作及索引配置能\n      够有效减小开销及死锁的风险。这也是sql的优化的一个方向。(所以索引对于sql优化很重要)\n    2.MVCC的版本控制思想是解决并发问题的常用办法，例如：CAS解决aba问题就是添加版本号的方式\n    3.使用select……for update 实现分布式锁就是利用他给行数据添加了排他锁的原理，这样就解决了并发下\n      对同数据集的操作，不过不想使用锁的话就可以借用版本控制的方法，增加一个版本号的字段进行判断","slug":"innoDBLock","published":1,"updated":"2021-05-15T14:49:15.629Z","_id":"ckdvmudyk001enwb5hi4v54i6","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  在了解分布式锁的过程中看到了MySql锁的相关知识，所以针对MySql-InnoDB锁的相关内容做一个梳理。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"InnoDB锁\"><a href=\"#InnoDB锁\" class=\"headerlink\" title=\"InnoDB锁\"></a>InnoDB锁</h3><p>  相对于MyISAM，InnoDB的不同之处在于引入了事务，并且主要使用的是行级锁而不是表级锁。</p>\n<h4 id=\"InnoDB事务\"><a href=\"#InnoDB事务\" class=\"headerlink\" title=\"InnoDB事务\"></a>InnoDB事务</h4><h5 id=\"并发事务的问题\"><a href=\"#并发事务的问题\" class=\"headerlink\" title=\"并发事务的问题\"></a>并发事务的问题</h5><ol>\n<li>脏读：事务A的未提交的写操作导致的数据修改被另一个事务读到</li>\n<li>不可重复读：一个事务内对同一行数据的前后两次查询结果不一样，由其他事务的update，delete操作影响</li>\n<li>幻读：一个事务内对同一批数据的前后两次查询结果不一样，由其他事务的insert操作影响</li>\n</ol>\n<h5 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h5><img src=\"/image/innoDBLock/InnoDBLock3.png\" class=\"\" title=\"事务隔离级别\">\n\n<h4 id=\"InnoDB的锁模式\"><a href=\"#InnoDB的锁模式\" class=\"headerlink\" title=\"InnoDB的锁模式\"></a>InnoDB的锁模式</h4><p>  InnoDB行级锁是针对索引的索引项加锁，也叫记录锁。如果某个sql没有用到索引，那么就会使用聚集索引。<br>  在聚集索引的所有索引项上加锁(类似表级锁)，MySQL之后会进行优化，释放掉不符合条件的索引项的锁。<br>  但这个加锁和释放的过程仍然执行了，所以要保证sql尽量用到索引。</p>\n<h5 id=\"共享锁与排他锁\"><a href=\"#共享锁与排他锁\" class=\"headerlink\" title=\"共享锁与排他锁\"></a>共享锁与排他锁</h5><pre><code>共享锁(s)：读锁，允许一个事务读一行，并阻止其他事务获取相同数据集的排他锁\n排他锁(x)：写锁，允许一个事务读/写一行，并阻止其他事务获取相同数据集的排他锁和共享锁\nupdat，insert，delete操作会自动加排他锁，而select默认不加锁，在串行读下会加共享锁</code></pre><h5 id=\"意向锁\"><a href=\"#意向锁\" class=\"headerlink\" title=\"意向锁\"></a>意向锁</h5><pre><code>意向锁属于表级锁，由数据库完成其申请操作，分为意向共享锁和意向排他锁。\n其解决的问题是：事务A先获取了表table的一个行级写锁，之后事务B想获取table的表级写锁，为了避免冲突\n逐行检查有没有冲突的行级锁，这样明显很浪费时间。\n\n而意向锁的作用就是：在事务申请一个行级锁之前，数据库会自动先申请一个意向锁。如果已经有事务持有该表\n的表级锁就会等待锁释放，而申请成功后，如果再有事务申请该表的表级锁，也会等待锁释放。这就避免了逐行\n检查的开销。</code></pre><img src=\"/image/innoDBLock/InnoDBLock.png\" class=\"\" title=\"意向锁和表级锁的兼容关系\">\n\n<pre><code>上图是意向锁和表级共享锁，排他锁的兼容关系(绿色表示兼容，红色表示冲突)，可以看到，意向锁之间是不\n冲突的。从这里就可以看到，意向锁的主要目的还是解决表级锁和行级锁的冲突。有了意向锁作为一种前置判断\n可以很方便的进行检查防止冲突。</code></pre><h5 id=\"间隙锁与临键锁\"><a href=\"#间隙锁与临键锁\" class=\"headerlink\" title=\"间隙锁与临键锁\"></a>间隙锁与临键锁</h5><p>  前面提到，InnoDB的行级锁是针对索引的索引项的，可以设想这样一种情况：</p>\n<img src=\"/image/innoDBLock/InnoDBLock2.png\" class=\"\" title=\"示例表\">\n\n<pre><code>对上图的表数据，age字段存在非唯一索引，那么执行以下sql：\n事务A：select name,age where age &gt; 4;\n      update set name = &apos;xx&apos; where age &gt; 4;\n      select name,age where age &gt; 4;\n事务B：insert into table(id,name,age) values(5,&apos;bb&apos;,7);\n\n按照前文对行级锁的理解，事务A的update操作会通过age的索引锁定主键索引4并加排他锁，事务B的操作不会\n因为锁阻塞。那么这时事务A的第二个查询就会和第一个查询的结果不一样，莫名多了一条数据。\n\n为解决这种问题，就使用了间隙锁(GAP-LOCK)\n间隙锁(GAP-LOCK)：是指对表中不存在的数据上加锁，一般处于两个数据行的间隙，所以叫间隙锁。用来防止\n                 其他事务的新增操作导致幻读，通常会在条件是一个范围的时候使用，而如果条件索引是唯\n                 一索引或者结果是唯一值(可以理解为不会因为其他事务的新增操作影响结果)，会放弃间隙\n                 锁而只使用记录锁\n临键锁(Next-Key)：临键锁比较好理解，他等于记录锁+间隙锁</code></pre><h4 id=\"MVCC-多版本并发控制\"><a href=\"#MVCC-多版本并发控制\" class=\"headerlink\" title=\"MVCC(多版本并发控制)\"></a>MVCC(多版本并发控制)</h4><p>  MVCC通过对每一行数据增加两个隐藏值：事务ID，回滚指针，来实现并发控制。<br>  不同事务对一行数据的写操作会产生多个版本，通过回滚指针形成一个链表的结构。<br>  读操作不用加锁，可以减少锁的使用和等待等开销。</p>\n<h5 id=\"快照读和当前读\"><a href=\"#快照读和当前读\" class=\"headerlink\" title=\"快照读和当前读\"></a>快照读和当前读</h5><p>  根据MVCC的版本记录，就产生了两种读取方式：快照读和当前读<br>    快照读：读取记录的可见版本，默认的select就是快照读，不用加锁<br>    当前读：读取记录的最新版本并加锁，防止其他事务的操作，属于当前读的操作有<br>           1. select …… from …… where …… lock in share mode; 加共享锁<br>           2. select …… from …… where …… for update; 加排他锁<br>           3. insert，update，delete</p>\n<h5 id=\"ReadView\"><a href=\"#ReadView\" class=\"headerlink\" title=\"ReadView\"></a>ReadView</h5><p>  ReadView用来控制快照读的可见版本，其操作原理是在生成ReadView时会保存一个当前活跃事务<br>  ID的列表，在进行select操作时，会将版本链中数据的事务ID与ReadView中的ID列表比对，判断版本是否可见。</p>\n<p>  例如：如果版本的事务ID大于ReadView事务ID列表的最大值，那么说明该版本数据是在生成ReadView之后提交的，自然对当前事务不可见，通过回滚指针遍历之前的版本继续比对。</p>\n<h4 id=\"不同事务隔离级别的区别\"><a href=\"#不同事务隔离级别的区别\" class=\"headerlink\" title=\"不同事务隔离级别的区别\"></a>不同事务隔离级别的区别</h4><ol>\n<li>未提交读：读不加锁，只读取最新版本数据，可以读到未提交的记录</li>\n<li>已提交读：使用MVCC，select使用快照读，写操作只用记录锁<pre><code>每一次select都会生成一个新的ReadView,所以可以读取提交的数据版本，导致不可重复读</code></pre></li>\n<li>可重复读：mysql默认隔离级别<pre><code>使用MVCC，select使用快照读，写操作会使用记录锁，间隙锁和临键锁\n在第一次select时生成一个ReadView，之后不再改变，所以不会读到之后提交的数据版本，\n保证前后读取的数据一致性(所以这里也可以防止幻读)</code></pre></li>\n<li>串行读：select加共享锁，读写互斥</li>\n</ol>\n<h4 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h4><p>  产生死锁的原因主要就是加锁的顺序不一样，因为MySql的加锁是对符合条件的数据逐行加锁。<br>  这就会导致两个事务持有对方需要的锁，导致互相等待，形成死锁</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  关于MySql-InnoDB锁的相关知识点，对于基本的行锁的概念和作用其实很好理解，包括事务隔离级别及其避\n免的并发问题，不过在我阅读相关博客时，对一些细节始终没有找到准确的答案，比如ReadView的具体实现方\n式，间隙锁的具体情况下的加锁操作。这些之后需要找些相关书籍确定答案，这里就还是做一下小结：\n1.InnoDB的默认事务隔离级别是可重复读，写操作会涉及锁的加载和释放。所以合理的sql操作及索引配置能\n  够有效减小开销及死锁的风险。这也是sql的优化的一个方向。(所以索引对于sql优化很重要)\n2.MVCC的版本控制思想是解决并发问题的常用办法，例如：CAS解决aba问题就是添加版本号的方式\n3.使用select……for update 实现分布式锁就是利用他给行数据添加了排他锁的原理，这样就解决了并发下\n  对同数据集的操作，不过不想使用锁的话就可以借用版本控制的方法，增加一个版本号的字段进行判断</code></pre>","site":{"data":{}},"length":2622,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  在了解分布式锁的过程中看到了MySql锁的相关知识，所以针对MySql-InnoDB锁的相关内容做一个梳理。</p>","more":"<h3 id=\"InnoDB锁\"><a href=\"#InnoDB锁\" class=\"headerlink\" title=\"InnoDB锁\"></a>InnoDB锁</h3><p>  相对于MyISAM，InnoDB的不同之处在于引入了事务，并且主要使用的是行级锁而不是表级锁。</p>\n<h4 id=\"InnoDB事务\"><a href=\"#InnoDB事务\" class=\"headerlink\" title=\"InnoDB事务\"></a>InnoDB事务</h4><h5 id=\"并发事务的问题\"><a href=\"#并发事务的问题\" class=\"headerlink\" title=\"并发事务的问题\"></a>并发事务的问题</h5><ol>\n<li>脏读：事务A的未提交的写操作导致的数据修改被另一个事务读到</li>\n<li>不可重复读：一个事务内对同一行数据的前后两次查询结果不一样，由其他事务的update，delete操作影响</li>\n<li>幻读：一个事务内对同一批数据的前后两次查询结果不一样，由其他事务的insert操作影响</li>\n</ol>\n<h5 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h5><img src=\"/image/innoDBLock/InnoDBLock3.png\" class=\"\" title=\"事务隔离级别\">\n\n<h4 id=\"InnoDB的锁模式\"><a href=\"#InnoDB的锁模式\" class=\"headerlink\" title=\"InnoDB的锁模式\"></a>InnoDB的锁模式</h4><p>  InnoDB行级锁是针对索引的索引项加锁，也叫记录锁。如果某个sql没有用到索引，那么就会使用聚集索引。<br>  在聚集索引的所有索引项上加锁(类似表级锁)，MySQL之后会进行优化，释放掉不符合条件的索引项的锁。<br>  但这个加锁和释放的过程仍然执行了，所以要保证sql尽量用到索引。</p>\n<h5 id=\"共享锁与排他锁\"><a href=\"#共享锁与排他锁\" class=\"headerlink\" title=\"共享锁与排他锁\"></a>共享锁与排他锁</h5><pre><code>共享锁(s)：读锁，允许一个事务读一行，并阻止其他事务获取相同数据集的排他锁\n排他锁(x)：写锁，允许一个事务读/写一行，并阻止其他事务获取相同数据集的排他锁和共享锁\nupdat，insert，delete操作会自动加排他锁，而select默认不加锁，在串行读下会加共享锁</code></pre><h5 id=\"意向锁\"><a href=\"#意向锁\" class=\"headerlink\" title=\"意向锁\"></a>意向锁</h5><pre><code>意向锁属于表级锁，由数据库完成其申请操作，分为意向共享锁和意向排他锁。\n其解决的问题是：事务A先获取了表table的一个行级写锁，之后事务B想获取table的表级写锁，为了避免冲突\n逐行检查有没有冲突的行级锁，这样明显很浪费时间。\n\n而意向锁的作用就是：在事务申请一个行级锁之前，数据库会自动先申请一个意向锁。如果已经有事务持有该表\n的表级锁就会等待锁释放，而申请成功后，如果再有事务申请该表的表级锁，也会等待锁释放。这就避免了逐行\n检查的开销。</code></pre><img src=\"/image/innoDBLock/InnoDBLock.png\" class=\"\" title=\"意向锁和表级锁的兼容关系\">\n\n<pre><code>上图是意向锁和表级共享锁，排他锁的兼容关系(绿色表示兼容，红色表示冲突)，可以看到，意向锁之间是不\n冲突的。从这里就可以看到，意向锁的主要目的还是解决表级锁和行级锁的冲突。有了意向锁作为一种前置判断\n可以很方便的进行检查防止冲突。</code></pre><h5 id=\"间隙锁与临键锁\"><a href=\"#间隙锁与临键锁\" class=\"headerlink\" title=\"间隙锁与临键锁\"></a>间隙锁与临键锁</h5><p>  前面提到，InnoDB的行级锁是针对索引的索引项的，可以设想这样一种情况：</p>\n<img src=\"/image/innoDBLock/InnoDBLock2.png\" class=\"\" title=\"示例表\">\n\n<pre><code>对上图的表数据，age字段存在非唯一索引，那么执行以下sql：\n事务A：select name,age where age &gt; 4;\n      update set name = &apos;xx&apos; where age &gt; 4;\n      select name,age where age &gt; 4;\n事务B：insert into table(id,name,age) values(5,&apos;bb&apos;,7);\n\n按照前文对行级锁的理解，事务A的update操作会通过age的索引锁定主键索引4并加排他锁，事务B的操作不会\n因为锁阻塞。那么这时事务A的第二个查询就会和第一个查询的结果不一样，莫名多了一条数据。\n\n为解决这种问题，就使用了间隙锁(GAP-LOCK)\n间隙锁(GAP-LOCK)：是指对表中不存在的数据上加锁，一般处于两个数据行的间隙，所以叫间隙锁。用来防止\n                 其他事务的新增操作导致幻读，通常会在条件是一个范围的时候使用，而如果条件索引是唯\n                 一索引或者结果是唯一值(可以理解为不会因为其他事务的新增操作影响结果)，会放弃间隙\n                 锁而只使用记录锁\n临键锁(Next-Key)：临键锁比较好理解，他等于记录锁+间隙锁</code></pre><h4 id=\"MVCC-多版本并发控制\"><a href=\"#MVCC-多版本并发控制\" class=\"headerlink\" title=\"MVCC(多版本并发控制)\"></a>MVCC(多版本并发控制)</h4><p>  MVCC通过对每一行数据增加两个隐藏值：事务ID，回滚指针，来实现并发控制。<br>  不同事务对一行数据的写操作会产生多个版本，通过回滚指针形成一个链表的结构。<br>  读操作不用加锁，可以减少锁的使用和等待等开销。</p>\n<h5 id=\"快照读和当前读\"><a href=\"#快照读和当前读\" class=\"headerlink\" title=\"快照读和当前读\"></a>快照读和当前读</h5><p>  根据MVCC的版本记录，就产生了两种读取方式：快照读和当前读<br>    快照读：读取记录的可见版本，默认的select就是快照读，不用加锁<br>    当前读：读取记录的最新版本并加锁，防止其他事务的操作，属于当前读的操作有<br>           1. select …… from …… where …… lock in share mode; 加共享锁<br>           2. select …… from …… where …… for update; 加排他锁<br>           3. insert，update，delete</p>\n<h5 id=\"ReadView\"><a href=\"#ReadView\" class=\"headerlink\" title=\"ReadView\"></a>ReadView</h5><p>  ReadView用来控制快照读的可见版本，其操作原理是在生成ReadView时会保存一个当前活跃事务<br>  ID的列表，在进行select操作时，会将版本链中数据的事务ID与ReadView中的ID列表比对，判断版本是否可见。</p>\n<p>  例如：如果版本的事务ID大于ReadView事务ID列表的最大值，那么说明该版本数据是在生成ReadView之后提交的，自然对当前事务不可见，通过回滚指针遍历之前的版本继续比对。</p>\n<h4 id=\"不同事务隔离级别的区别\"><a href=\"#不同事务隔离级别的区别\" class=\"headerlink\" title=\"不同事务隔离级别的区别\"></a>不同事务隔离级别的区别</h4><ol>\n<li>未提交读：读不加锁，只读取最新版本数据，可以读到未提交的记录</li>\n<li>已提交读：使用MVCC，select使用快照读，写操作只用记录锁<pre><code>每一次select都会生成一个新的ReadView,所以可以读取提交的数据版本，导致不可重复读</code></pre></li>\n<li>可重复读：mysql默认隔离级别<pre><code>使用MVCC，select使用快照读，写操作会使用记录锁，间隙锁和临键锁\n在第一次select时生成一个ReadView，之后不再改变，所以不会读到之后提交的数据版本，\n保证前后读取的数据一致性(所以这里也可以防止幻读)</code></pre></li>\n<li>串行读：select加共享锁，读写互斥</li>\n</ol>\n<h4 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h4><p>  产生死锁的原因主要就是加锁的顺序不一样，因为MySql的加锁是对符合条件的数据逐行加锁。<br>  这就会导致两个事务持有对方需要的锁，导致互相等待，形成死锁</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  关于MySql-InnoDB锁的相关知识点，对于基本的行锁的概念和作用其实很好理解，包括事务隔离级别及其避\n免的并发问题，不过在我阅读相关博客时，对一些细节始终没有找到准确的答案，比如ReadView的具体实现方\n式，间隙锁的具体情况下的加锁操作。这些之后需要找些相关书籍确定答案，这里就还是做一下小结：\n1.InnoDB的默认事务隔离级别是可重复读，写操作会涉及锁的加载和释放。所以合理的sql操作及索引配置能\n  够有效减小开销及死锁的风险。这也是sql的优化的一个方向。(所以索引对于sql优化很重要)\n2.MVCC的版本控制思想是解决并发问题的常用办法，例如：CAS解决aba问题就是添加版本号的方式\n3.使用select……for update 实现分布式锁就是利用他给行数据添加了排他锁的原理，这样就解决了并发下\n  对同数据集的操作，不过不想使用锁的话就可以借用版本控制的方法，增加一个版本号的字段进行判断</code></pre>"},{"title":"jvm知识点梳理","date":"2020-06-28T01:22:11.000Z","_content":"\n### 前言\n\n  本章主要对JVM主要的知识点进行梳理总结。\n<!-- more -->\n\n### 运行时区域\n\n  1. 程序计数器：线程私有，是当前线程执行的字节码的行号指示器，决定命令的执行顺序\n  2. Java虚拟机栈：线程私有，生命周期与线程相同，其描述的是Java方法的内存模型\n     *每个方法执行时，都会创建一个栈帧，存储局部变量表，操作数栈，动态链接，方法出口等信息。*\n     *方法的从执行到完成，对应着栈帧在虚拟机栈中入栈和出栈的过程。*\n  3. 本地方法栈：类似于虚拟机栈，所不同的时，本地方法栈服务的对象时Native方法\n  4. 堆：几乎所有的对象实例都在堆中分配内存，也是垃圾收集器管理的主要区域\n  5. 方法区：存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据\n\n### 对象存活判断\n\n  1. 引用计数法：在对象中添加一个引用计数器，每当被引用时则+1，引用失效就-1，当为0时表示对象不会再被使用，其缺陷是没法解决相互循环引用的问题\n  2. 可达性分析：将一系列的对象定义为\"GC Roots\"，然后分析一个对象有没有直达\"GC Roots\"的引用链，没有则表示对象没有被使用\n     可作为\"GC Roots\"的对象有以下几种：\n     * 虚拟机栈，栈帧中局部变量表中引用的对象\n     * 方法区中类静态属性引用的对象\n     * 方法区中常量引用的对象\n     * 本地方法栈中JNI(Native方法)引用的对象\n\n### 引用类型\n  \n  1. 强引用：普遍存在类似\"Object o = new Object()\"这种，垃圾收集器不会回收掉强引用还存在的对象\n  2. 软引用：软引用关联的对象会在系统将要发生内存溢出前进行第二次回收，可通过SoftReference实现\n  3. 弱引用：弱引用关联的对象只能生存到下一次垃圾回收之前，可通过WeakReference实现\n  4. 虚引用：不影响对象的生存时间，只会在其被回收时收到一个系统通知，可通过PhantomReference实现\n\n### 垃圾收集算法\n\n  1. 标记-清除算法\n     先标记需要回收的对象，然后再执行回收操作。缺点是效率不高，且会产生大量的内存碎片，可能导致大对象进入时引发不必要的垃圾回收\n  2. 复制算法\n     将内存分为两块，每次只使用其中一块。当执行回收操作时，将存活对象复制到空的那块上，然后清空使用过的，效率较高，但空间浪费了\n  3. 标记-整理算法\n     以标记-清理算法为基础，在回收前将存活对象向一端移动，然后清理掉边界以外的内存，保证内存的连续性\n  4. 分代收集算法\n     在实际虚拟机中采用分代收集算法，根据对象的存活周期划分为年轻代和老年代，根据各个年代的特点采取不同的收集算法\n     * 年轻代\n       采用复制算法，以HotSpot为例，空间按8:1:1的比例分为Eden，及两个Survivor共三个空间。每次回收时将Eden和Survivor中存活对象复制到空着的那个Survivor中，然后对其内存清理\n       如果空着的Survivor没有足够空间存放，这些对象就会进入老年代\n     * 老年代\n       由于老年代的对象存活率高，通常采用标记-清理或者标记-整理来进行回收\n\n#### 对象分配及回收条件\n  \n  对象优先在Eden中进行分配，若Eden中没有空间可进行分配就会触发MinorGC。\n\n  大对象直接进入老年代，可通过-XX:PretenureSizeThreshold参数设置这个大对象的判断阈值。\n\n  长期存活的对象也会进入老年代，每经历过一次MinorGC还存活的对象，其年龄就增加一岁(虚拟机为每一个对象定义了一个年龄计数器)，当达到一定年龄时就会进入老年代(默认15)。\n  年龄阈值可通过参数-XX:MaxTenuringThreshold控制。\n  \n  当老年代空间不足时就会触发Full GC，Full GC对性能影响较大，应尽量避免。\n\n\n### JDK命令行工具\n  \n  1. jps:虚拟机进程状态查询，可以显示正在运行的虚拟机进程及LVMID等信息\n  2. jstat：虚拟机统计信息查询，现实虚拟机中各空间的使用信息，GC的统计信息等\n  3. jinfo：实时的查看和调整虚拟机各项参数\n  4. jmap：Java内存映像工具，可用于生成堆转储快照\n  5. jhat：针对jmap生成的快照文件进行分析，可以在浏览器中查看分析结果\n  6. jstack：生成虚拟机当前时刻的线程快照","source":"_posts/2020/06/jvm1.md","raw":"---\ntitle: jvm知识点梳理\ndate: 2020-06-28 09:22:11\ntags:\n- JVM\ncategories:\n- JVM\n---\n\n### 前言\n\n  本章主要对JVM主要的知识点进行梳理总结。\n<!-- more -->\n\n### 运行时区域\n\n  1. 程序计数器：线程私有，是当前线程执行的字节码的行号指示器，决定命令的执行顺序\n  2. Java虚拟机栈：线程私有，生命周期与线程相同，其描述的是Java方法的内存模型\n     *每个方法执行时，都会创建一个栈帧，存储局部变量表，操作数栈，动态链接，方法出口等信息。*\n     *方法的从执行到完成，对应着栈帧在虚拟机栈中入栈和出栈的过程。*\n  3. 本地方法栈：类似于虚拟机栈，所不同的时，本地方法栈服务的对象时Native方法\n  4. 堆：几乎所有的对象实例都在堆中分配内存，也是垃圾收集器管理的主要区域\n  5. 方法区：存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据\n\n### 对象存活判断\n\n  1. 引用计数法：在对象中添加一个引用计数器，每当被引用时则+1，引用失效就-1，当为0时表示对象不会再被使用，其缺陷是没法解决相互循环引用的问题\n  2. 可达性分析：将一系列的对象定义为\"GC Roots\"，然后分析一个对象有没有直达\"GC Roots\"的引用链，没有则表示对象没有被使用\n     可作为\"GC Roots\"的对象有以下几种：\n     * 虚拟机栈，栈帧中局部变量表中引用的对象\n     * 方法区中类静态属性引用的对象\n     * 方法区中常量引用的对象\n     * 本地方法栈中JNI(Native方法)引用的对象\n\n### 引用类型\n  \n  1. 强引用：普遍存在类似\"Object o = new Object()\"这种，垃圾收集器不会回收掉强引用还存在的对象\n  2. 软引用：软引用关联的对象会在系统将要发生内存溢出前进行第二次回收，可通过SoftReference实现\n  3. 弱引用：弱引用关联的对象只能生存到下一次垃圾回收之前，可通过WeakReference实现\n  4. 虚引用：不影响对象的生存时间，只会在其被回收时收到一个系统通知，可通过PhantomReference实现\n\n### 垃圾收集算法\n\n  1. 标记-清除算法\n     先标记需要回收的对象，然后再执行回收操作。缺点是效率不高，且会产生大量的内存碎片，可能导致大对象进入时引发不必要的垃圾回收\n  2. 复制算法\n     将内存分为两块，每次只使用其中一块。当执行回收操作时，将存活对象复制到空的那块上，然后清空使用过的，效率较高，但空间浪费了\n  3. 标记-整理算法\n     以标记-清理算法为基础，在回收前将存活对象向一端移动，然后清理掉边界以外的内存，保证内存的连续性\n  4. 分代收集算法\n     在实际虚拟机中采用分代收集算法，根据对象的存活周期划分为年轻代和老年代，根据各个年代的特点采取不同的收集算法\n     * 年轻代\n       采用复制算法，以HotSpot为例，空间按8:1:1的比例分为Eden，及两个Survivor共三个空间。每次回收时将Eden和Survivor中存活对象复制到空着的那个Survivor中，然后对其内存清理\n       如果空着的Survivor没有足够空间存放，这些对象就会进入老年代\n     * 老年代\n       由于老年代的对象存活率高，通常采用标记-清理或者标记-整理来进行回收\n\n#### 对象分配及回收条件\n  \n  对象优先在Eden中进行分配，若Eden中没有空间可进行分配就会触发MinorGC。\n\n  大对象直接进入老年代，可通过-XX:PretenureSizeThreshold参数设置这个大对象的判断阈值。\n\n  长期存活的对象也会进入老年代，每经历过一次MinorGC还存活的对象，其年龄就增加一岁(虚拟机为每一个对象定义了一个年龄计数器)，当达到一定年龄时就会进入老年代(默认15)。\n  年龄阈值可通过参数-XX:MaxTenuringThreshold控制。\n  \n  当老年代空间不足时就会触发Full GC，Full GC对性能影响较大，应尽量避免。\n\n\n### JDK命令行工具\n  \n  1. jps:虚拟机进程状态查询，可以显示正在运行的虚拟机进程及LVMID等信息\n  2. jstat：虚拟机统计信息查询，现实虚拟机中各空间的使用信息，GC的统计信息等\n  3. jinfo：实时的查看和调整虚拟机各项参数\n  4. jmap：Java内存映像工具，可用于生成堆转储快照\n  5. jhat：针对jmap生成的快照文件进行分析，可以在浏览器中查看分析结果\n  6. jstack：生成虚拟机当前时刻的线程快照","slug":"jvm1","published":1,"updated":"2020-08-15T12:34:05.003Z","_id":"ckdvmudyn001hnwb5cyiacgrc","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章主要对JVM主要的知识点进行梳理总结。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"运行时区域\"><a href=\"#运行时区域\" class=\"headerlink\" title=\"运行时区域\"></a>运行时区域</h3><ol>\n<li>程序计数器：线程私有，是当前线程执行的字节码的行号指示器，决定命令的执行顺序</li>\n<li>Java虚拟机栈：线程私有，生命周期与线程相同，其描述的是Java方法的内存模型<br><em>每个方法执行时，都会创建一个栈帧，存储局部变量表，操作数栈，动态链接，方法出口等信息。</em><br><em>方法的从执行到完成，对应着栈帧在虚拟机栈中入栈和出栈的过程。</em></li>\n<li>本地方法栈：类似于虚拟机栈，所不同的时，本地方法栈服务的对象时Native方法</li>\n<li>堆：几乎所有的对象实例都在堆中分配内存，也是垃圾收集器管理的主要区域</li>\n<li>方法区：存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据</li>\n</ol>\n<h3 id=\"对象存活判断\"><a href=\"#对象存活判断\" class=\"headerlink\" title=\"对象存活判断\"></a>对象存活判断</h3><ol>\n<li>引用计数法：在对象中添加一个引用计数器，每当被引用时则+1，引用失效就-1，当为0时表示对象不会再被使用，其缺陷是没法解决相互循环引用的问题</li>\n<li>可达性分析：将一系列的对象定义为”GC Roots”，然后分析一个对象有没有直达”GC Roots”的引用链，没有则表示对象没有被使用<br>可作为”GC Roots”的对象有以下几种：<ul>\n<li>虚拟机栈，栈帧中局部变量表中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI(Native方法)引用的对象</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><ol>\n<li>强引用：普遍存在类似”Object o = new Object()”这种，垃圾收集器不会回收掉强引用还存在的对象</li>\n<li>软引用：软引用关联的对象会在系统将要发生内存溢出前进行第二次回收，可通过SoftReference实现</li>\n<li>弱引用：弱引用关联的对象只能生存到下一次垃圾回收之前，可通过WeakReference实现</li>\n<li>虚引用：不影响对象的生存时间，只会在其被回收时收到一个系统通知，可通过PhantomReference实现</li>\n</ol>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><ol>\n<li>标记-清除算法<br>先标记需要回收的对象，然后再执行回收操作。缺点是效率不高，且会产生大量的内存碎片，可能导致大对象进入时引发不必要的垃圾回收</li>\n<li>复制算法<br>将内存分为两块，每次只使用其中一块。当执行回收操作时，将存活对象复制到空的那块上，然后清空使用过的，效率较高，但空间浪费了</li>\n<li>标记-整理算法<br>以标记-清理算法为基础，在回收前将存活对象向一端移动，然后清理掉边界以外的内存，保证内存的连续性</li>\n<li>分代收集算法<br>在实际虚拟机中采用分代收集算法，根据对象的存活周期划分为年轻代和老年代，根据各个年代的特点采取不同的收集算法<ul>\n<li>年轻代<br>采用复制算法，以HotSpot为例，空间按8:1:1的比例分为Eden，及两个Survivor共三个空间。每次回收时将Eden和Survivor中存活对象复制到空着的那个Survivor中，然后对其内存清理<br>如果空着的Survivor没有足够空间存放，这些对象就会进入老年代</li>\n<li>老年代<br>由于老年代的对象存活率高，通常采用标记-清理或者标记-整理来进行回收</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"对象分配及回收条件\"><a href=\"#对象分配及回收条件\" class=\"headerlink\" title=\"对象分配及回收条件\"></a>对象分配及回收条件</h4><p>  对象优先在Eden中进行分配，若Eden中没有空间可进行分配就会触发MinorGC。</p>\n<p>  大对象直接进入老年代，可通过-XX:PretenureSizeThreshold参数设置这个大对象的判断阈值。</p>\n<p>  长期存活的对象也会进入老年代，每经历过一次MinorGC还存活的对象，其年龄就增加一岁(虚拟机为每一个对象定义了一个年龄计数器)，当达到一定年龄时就会进入老年代(默认15)。<br>  年龄阈值可通过参数-XX:MaxTenuringThreshold控制。</p>\n<p>  当老年代空间不足时就会触发Full GC，Full GC对性能影响较大，应尽量避免。</p>\n<h3 id=\"JDK命令行工具\"><a href=\"#JDK命令行工具\" class=\"headerlink\" title=\"JDK命令行工具\"></a>JDK命令行工具</h3><ol>\n<li>jps:虚拟机进程状态查询，可以显示正在运行的虚拟机进程及LVMID等信息</li>\n<li>jstat：虚拟机统计信息查询，现实虚拟机中各空间的使用信息，GC的统计信息等</li>\n<li>jinfo：实时的查看和调整虚拟机各项参数</li>\n<li>jmap：Java内存映像工具，可用于生成堆转储快照</li>\n<li>jhat：针对jmap生成的快照文件进行分析，可以在浏览器中查看分析结果</li>\n<li>jstack：生成虚拟机当前时刻的线程快照</li>\n</ol>\n","site":{"data":{}},"length":1615,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章主要对JVM主要的知识点进行梳理总结。</p>","more":"<h3 id=\"运行时区域\"><a href=\"#运行时区域\" class=\"headerlink\" title=\"运行时区域\"></a>运行时区域</h3><ol>\n<li>程序计数器：线程私有，是当前线程执行的字节码的行号指示器，决定命令的执行顺序</li>\n<li>Java虚拟机栈：线程私有，生命周期与线程相同，其描述的是Java方法的内存模型<br><em>每个方法执行时，都会创建一个栈帧，存储局部变量表，操作数栈，动态链接，方法出口等信息。</em><br><em>方法的从执行到完成，对应着栈帧在虚拟机栈中入栈和出栈的过程。</em></li>\n<li>本地方法栈：类似于虚拟机栈，所不同的时，本地方法栈服务的对象时Native方法</li>\n<li>堆：几乎所有的对象实例都在堆中分配内存，也是垃圾收集器管理的主要区域</li>\n<li>方法区：存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据</li>\n</ol>\n<h3 id=\"对象存活判断\"><a href=\"#对象存活判断\" class=\"headerlink\" title=\"对象存活判断\"></a>对象存活判断</h3><ol>\n<li>引用计数法：在对象中添加一个引用计数器，每当被引用时则+1，引用失效就-1，当为0时表示对象不会再被使用，其缺陷是没法解决相互循环引用的问题</li>\n<li>可达性分析：将一系列的对象定义为”GC Roots”，然后分析一个对象有没有直达”GC Roots”的引用链，没有则表示对象没有被使用<br>可作为”GC Roots”的对象有以下几种：<ul>\n<li>虚拟机栈，栈帧中局部变量表中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI(Native方法)引用的对象</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><ol>\n<li>强引用：普遍存在类似”Object o = new Object()”这种，垃圾收集器不会回收掉强引用还存在的对象</li>\n<li>软引用：软引用关联的对象会在系统将要发生内存溢出前进行第二次回收，可通过SoftReference实现</li>\n<li>弱引用：弱引用关联的对象只能生存到下一次垃圾回收之前，可通过WeakReference实现</li>\n<li>虚引用：不影响对象的生存时间，只会在其被回收时收到一个系统通知，可通过PhantomReference实现</li>\n</ol>\n<h3 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h3><ol>\n<li>标记-清除算法<br>先标记需要回收的对象，然后再执行回收操作。缺点是效率不高，且会产生大量的内存碎片，可能导致大对象进入时引发不必要的垃圾回收</li>\n<li>复制算法<br>将内存分为两块，每次只使用其中一块。当执行回收操作时，将存活对象复制到空的那块上，然后清空使用过的，效率较高，但空间浪费了</li>\n<li>标记-整理算法<br>以标记-清理算法为基础，在回收前将存活对象向一端移动，然后清理掉边界以外的内存，保证内存的连续性</li>\n<li>分代收集算法<br>在实际虚拟机中采用分代收集算法，根据对象的存活周期划分为年轻代和老年代，根据各个年代的特点采取不同的收集算法<ul>\n<li>年轻代<br>采用复制算法，以HotSpot为例，空间按8:1:1的比例分为Eden，及两个Survivor共三个空间。每次回收时将Eden和Survivor中存活对象复制到空着的那个Survivor中，然后对其内存清理<br>如果空着的Survivor没有足够空间存放，这些对象就会进入老年代</li>\n<li>老年代<br>由于老年代的对象存活率高，通常采用标记-清理或者标记-整理来进行回收</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"对象分配及回收条件\"><a href=\"#对象分配及回收条件\" class=\"headerlink\" title=\"对象分配及回收条件\"></a>对象分配及回收条件</h4><p>  对象优先在Eden中进行分配，若Eden中没有空间可进行分配就会触发MinorGC。</p>\n<p>  大对象直接进入老年代，可通过-XX:PretenureSizeThreshold参数设置这个大对象的判断阈值。</p>\n<p>  长期存活的对象也会进入老年代，每经历过一次MinorGC还存活的对象，其年龄就增加一岁(虚拟机为每一个对象定义了一个年龄计数器)，当达到一定年龄时就会进入老年代(默认15)。<br>  年龄阈值可通过参数-XX:MaxTenuringThreshold控制。</p>\n<p>  当老年代空间不足时就会触发Full GC，Full GC对性能影响较大，应尽量避免。</p>\n<h3 id=\"JDK命令行工具\"><a href=\"#JDK命令行工具\" class=\"headerlink\" title=\"JDK命令行工具\"></a>JDK命令行工具</h3><ol>\n<li>jps:虚拟机进程状态查询，可以显示正在运行的虚拟机进程及LVMID等信息</li>\n<li>jstat：虚拟机统计信息查询，现实虚拟机中各空间的使用信息，GC的统计信息等</li>\n<li>jinfo：实时的查看和调整虚拟机各项参数</li>\n<li>jmap：Java内存映像工具，可用于生成堆转储快照</li>\n<li>jhat：针对jmap生成的快照文件进行分析，可以在浏览器中查看分析结果</li>\n<li>jstack：生成虚拟机当前时刻的线程快照</li>\n</ol>"},{"title":"redis-过期策略及淘汰机制","date":"2020-06-27T02:07:50.000Z","_content":"\n### 前言\n\n  之前有做过redis的一些知识点总结，本章主要针对redis中key的过期策略和淘汰机制内容做一下总结。\n<!-- more -->\n\n### 过期策略\n\n 1. 定期删除：属于主动删除策略，每隔一段时间随机选择一批key，删除其中过期的\n\n 2. 惰性删除：通过key获取值时，判断key是否已过期，是则删除\n\n### 内存淘汰机制\n  \n  redis的过期策略很明显存在过期key未被及时删除而占用内存的情况。如果极端情况下漏了大量key未被及时删除，就过于浪费内存空间了。\n\n  所以redis还提供了内存淘汰机制应对这种情况：\n  1. 内存不足时，新增操作会报错\n  2. 内存不足时，移除最近最少使用的key\n  3. 内存不足时，随机从所有的key中选一个移除\n  4. 内存不足时，移除设置了过期时间且最近最少使用的key\n  5. 内存不足时，随机从设置了过期时间的key中选一个移除\n  6. 内存不足时，移除设置了过期时间key中，过期时间更早的\n\n### LRU算法\n  \n  redis内存淘汰机制通常使用的是上述第二种，也就是LRU算法，移除最近最少使用的。\n\n### LRU实现逻辑\n\n  LRU的实现最关键的是记录key的使用顺序，那么先进先出队列就很契合。\n  每次调用进入队列，若队列已满则弹出尾部元素，但这里得考虑处理重复元素的情况。\n  所以更好的是使用双向链表，新调用的元素放在头节点，已在链表中的被调用也很容易被置换到头节点，链表满了就删除掉尾节点元素。\n\n  而reids中的LRU实现没有使用上述两个方法，他的实现逻辑如下：\n  1. 每个key对应的value都记录了调用对应的当前时间戳\n  2. 使用一个数组存放被调用的key，新增时如果满了就剔除时间戳最大的\n  3. 淘汰时就针对数组中的key选择\n\n\n  redis基于内存占用的考虑及数据结构的设计考虑没有引用队列或双向列表去做LRU。\n  其逻辑是仿照LRU的实现逻辑，使用时间戳比较key的使用顺序，并且并没有对所有的key进行计算操作，而是随机的选择一些进行LRU的淘汰。\n\n### 小结\n  \n      本章主要总结了redis过期淘汰涉及的相关概念，重点是redis的LRU逻辑，他是一种近似LRU算\n    法，基于对性能的考虑并没有对所有key进行计算，而是折中的选取一些，兼顾了淘汰的结果和执\n    行的性能。","source":"_posts/2020/06/redis2.md","raw":"---\ntitle: redis-过期策略及淘汰机制\ndate: 2020-06-27 10:07:50\ntags:\n- redis\ncategories:\n- redis\n---\n\n### 前言\n\n  之前有做过redis的一些知识点总结，本章主要针对redis中key的过期策略和淘汰机制内容做一下总结。\n<!-- more -->\n\n### 过期策略\n\n 1. 定期删除：属于主动删除策略，每隔一段时间随机选择一批key，删除其中过期的\n\n 2. 惰性删除：通过key获取值时，判断key是否已过期，是则删除\n\n### 内存淘汰机制\n  \n  redis的过期策略很明显存在过期key未被及时删除而占用内存的情况。如果极端情况下漏了大量key未被及时删除，就过于浪费内存空间了。\n\n  所以redis还提供了内存淘汰机制应对这种情况：\n  1. 内存不足时，新增操作会报错\n  2. 内存不足时，移除最近最少使用的key\n  3. 内存不足时，随机从所有的key中选一个移除\n  4. 内存不足时，移除设置了过期时间且最近最少使用的key\n  5. 内存不足时，随机从设置了过期时间的key中选一个移除\n  6. 内存不足时，移除设置了过期时间key中，过期时间更早的\n\n### LRU算法\n  \n  redis内存淘汰机制通常使用的是上述第二种，也就是LRU算法，移除最近最少使用的。\n\n### LRU实现逻辑\n\n  LRU的实现最关键的是记录key的使用顺序，那么先进先出队列就很契合。\n  每次调用进入队列，若队列已满则弹出尾部元素，但这里得考虑处理重复元素的情况。\n  所以更好的是使用双向链表，新调用的元素放在头节点，已在链表中的被调用也很容易被置换到头节点，链表满了就删除掉尾节点元素。\n\n  而reids中的LRU实现没有使用上述两个方法，他的实现逻辑如下：\n  1. 每个key对应的value都记录了调用对应的当前时间戳\n  2. 使用一个数组存放被调用的key，新增时如果满了就剔除时间戳最大的\n  3. 淘汰时就针对数组中的key选择\n\n\n  redis基于内存占用的考虑及数据结构的设计考虑没有引用队列或双向列表去做LRU。\n  其逻辑是仿照LRU的实现逻辑，使用时间戳比较key的使用顺序，并且并没有对所有的key进行计算操作，而是随机的选择一些进行LRU的淘汰。\n\n### 小结\n  \n      本章主要总结了redis过期淘汰涉及的相关概念，重点是redis的LRU逻辑，他是一种近似LRU算\n    法，基于对性能的考虑并没有对所有key进行计算，而是折中的选取一些，兼顾了淘汰的结果和执\n    行的性能。","slug":"redis2","published":1,"updated":"2020-08-15T12:34:05.004Z","_id":"ckdvmudyo001jnwb5e48jbgj9","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  之前有做过redis的一些知识点总结，本章主要针对redis中key的过期策略和淘汰机制内容做一下总结。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h3><ol>\n<li><p>定期删除：属于主动删除策略，每隔一段时间随机选择一批key，删除其中过期的</p>\n</li>\n<li><p>惰性删除：通过key获取值时，判断key是否已过期，是则删除</p>\n</li>\n</ol>\n<h3 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h3><p>  redis的过期策略很明显存在过期key未被及时删除而占用内存的情况。如果极端情况下漏了大量key未被及时删除，就过于浪费内存空间了。</p>\n<p>  所以redis还提供了内存淘汰机制应对这种情况：</p>\n<ol>\n<li>内存不足时，新增操作会报错</li>\n<li>内存不足时，移除最近最少使用的key</li>\n<li>内存不足时，随机从所有的key中选一个移除</li>\n<li>内存不足时，移除设置了过期时间且最近最少使用的key</li>\n<li>内存不足时，随机从设置了过期时间的key中选一个移除</li>\n<li>内存不足时，移除设置了过期时间key中，过期时间更早的</li>\n</ol>\n<h3 id=\"LRU算法\"><a href=\"#LRU算法\" class=\"headerlink\" title=\"LRU算法\"></a>LRU算法</h3><p>  redis内存淘汰机制通常使用的是上述第二种，也就是LRU算法，移除最近最少使用的。</p>\n<h3 id=\"LRU实现逻辑\"><a href=\"#LRU实现逻辑\" class=\"headerlink\" title=\"LRU实现逻辑\"></a>LRU实现逻辑</h3><p>  LRU的实现最关键的是记录key的使用顺序，那么先进先出队列就很契合。<br>  每次调用进入队列，若队列已满则弹出尾部元素，但这里得考虑处理重复元素的情况。<br>  所以更好的是使用双向链表，新调用的元素放在头节点，已在链表中的被调用也很容易被置换到头节点，链表满了就删除掉尾节点元素。</p>\n<p>  而reids中的LRU实现没有使用上述两个方法，他的实现逻辑如下：</p>\n<ol>\n<li>每个key对应的value都记录了调用对应的当前时间戳</li>\n<li>使用一个数组存放被调用的key，新增时如果满了就剔除时间戳最大的</li>\n<li>淘汰时就针对数组中的key选择</li>\n</ol>\n<p>  redis基于内存占用的考虑及数据结构的设计考虑没有引用队列或双向列表去做LRU。<br>  其逻辑是仿照LRU的实现逻辑，使用时间戳比较key的使用顺序，并且并没有对所有的key进行计算操作，而是随机的选择一些进行LRU的淘汰。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  本章主要总结了redis过期淘汰涉及的相关概念，重点是redis的LRU逻辑，他是一种近似LRU算\n法，基于对性能的考虑并没有对所有key进行计算，而是折中的选取一些，兼顾了淘汰的结果和执\n行的性能。</code></pre>","site":{"data":{}},"length":856,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  之前有做过redis的一些知识点总结，本章主要针对redis中key的过期策略和淘汰机制内容做一下总结。</p>","more":"<h3 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h3><ol>\n<li><p>定期删除：属于主动删除策略，每隔一段时间随机选择一批key，删除其中过期的</p>\n</li>\n<li><p>惰性删除：通过key获取值时，判断key是否已过期，是则删除</p>\n</li>\n</ol>\n<h3 id=\"内存淘汰机制\"><a href=\"#内存淘汰机制\" class=\"headerlink\" title=\"内存淘汰机制\"></a>内存淘汰机制</h3><p>  redis的过期策略很明显存在过期key未被及时删除而占用内存的情况。如果极端情况下漏了大量key未被及时删除，就过于浪费内存空间了。</p>\n<p>  所以redis还提供了内存淘汰机制应对这种情况：</p>\n<ol>\n<li>内存不足时，新增操作会报错</li>\n<li>内存不足时，移除最近最少使用的key</li>\n<li>内存不足时，随机从所有的key中选一个移除</li>\n<li>内存不足时，移除设置了过期时间且最近最少使用的key</li>\n<li>内存不足时，随机从设置了过期时间的key中选一个移除</li>\n<li>内存不足时，移除设置了过期时间key中，过期时间更早的</li>\n</ol>\n<h3 id=\"LRU算法\"><a href=\"#LRU算法\" class=\"headerlink\" title=\"LRU算法\"></a>LRU算法</h3><p>  redis内存淘汰机制通常使用的是上述第二种，也就是LRU算法，移除最近最少使用的。</p>\n<h3 id=\"LRU实现逻辑\"><a href=\"#LRU实现逻辑\" class=\"headerlink\" title=\"LRU实现逻辑\"></a>LRU实现逻辑</h3><p>  LRU的实现最关键的是记录key的使用顺序，那么先进先出队列就很契合。<br>  每次调用进入队列，若队列已满则弹出尾部元素，但这里得考虑处理重复元素的情况。<br>  所以更好的是使用双向链表，新调用的元素放在头节点，已在链表中的被调用也很容易被置换到头节点，链表满了就删除掉尾节点元素。</p>\n<p>  而reids中的LRU实现没有使用上述两个方法，他的实现逻辑如下：</p>\n<ol>\n<li>每个key对应的value都记录了调用对应的当前时间戳</li>\n<li>使用一个数组存放被调用的key，新增时如果满了就剔除时间戳最大的</li>\n<li>淘汰时就针对数组中的key选择</li>\n</ol>\n<p>  redis基于内存占用的考虑及数据结构的设计考虑没有引用队列或双向列表去做LRU。<br>  其逻辑是仿照LRU的实现逻辑，使用时间戳比较key的使用顺序，并且并没有对所有的key进行计算操作，而是随机的选择一些进行LRU的淘汰。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  本章主要总结了redis过期淘汰涉及的相关概念，重点是redis的LRU逻辑，他是一种近似LRU算\n法，基于对性能的考虑并没有对所有key进行计算，而是折中的选取一些，兼顾了淘汰的结果和执\n行的性能。</code></pre>"},{"title":"ThreadLocal(jdk1.8)","date":"2020-07-02T07:57:56.000Z","_content":"\n### 前言\n\n  ThreadLocal，也被称作线程本地变量，他为每一个线程创建了变量的副本，使得线程能够访问各自的变量副本，互不影响。\n<!-- more -->\n\n### 属性信息\n\n{% codeblock lang:java %}\n// 用于关联线程的线性哈希\nprivate final int threadLocalHashCode = nextHashCode();\n\n// 下一个哈希值，使用原子更新\nprivate static AtomicInteger nextHashCode = new AtomicInteger();\n\n// 连续hash计算的增长量\nprivate static final int HASH_INCREMENT = 0x61c88647;\n\n// 计算哈希的方法\nprivate static int nextHashCode() {\n    // 使用原子操作计算\n    return nextHashCode.getAndAdd(HASH_INCREMENT);\n}\n{% endcodeblock %}\n\n### 核心方法\n\n{% codeblock lang:java %}\n// 赋值方法\npublic void set(T value) {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    // 获取当前线程的ThreadLocalMap实例\n    ThreadLocalMap map = getMap(t);\n    // 判断非空 进行初始化及赋值操作\n    if (map != null)\n        // 这里的this是当前ThreadLocal实例\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\n// 取值方法\npublic T get() {\n    // 获取当前线程对象\n    Thread t = Thread.currentThread();\n    // 获取当前线程的ThreadLocalMap实例\n    ThreadLocalMap map = getMap(t);\n    // 判断map非空，取值\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    // map为空 进行初始化\n    return setInitialValue();\n}\n\n// 获取指定线程对象的ThreadLocalMap\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\n// ThreadLocalMap的初始化及赋值\nvoid createMap(Thread t, T firstValue) {\n    // 这里的this是当前ThreadLocal实例\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n\n// 删除\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        // 调用ThreadLocalMap的remove清理\n        m.remove(this);\n}\n{% endcodeblock %}\n\n  可以从set()看到，这里是将ThreadLocal实例作为map的key存储对应的值。因为ThreadLocalMap属于每个线程私有的变量，通过不同的ThreadLocal实例区分不同的变量。\n  \n### ThreadLocalMap\n  \n  ThreadLocalMap是ThreadLocal内部定义的一个key-value结构的内部类，用于存储线程内部的变量值。\n\n{% codeblock lang:java %}\n// 构造方法\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    table = new Entry[INITIAL_CAPACITY];\n    // 这里使用ThreadLocal的哈希值计算数组下标，与HashMap的逻辑相似\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    setThreshold(INITIAL_CAPACITY);\n}\n\n// 通过key(ThreadLocal)获取value\nprivate Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n\n// 清理value\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    // 手动置空要清除的项\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    // 数组长度修改了，重新计算下标\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n{% endcodeblock %}\n\n### 原理分析\n\n  从上述源码可以看出，每一个Thread都定义了一个ThreadLocalMap的属性用来存储自己的局部变量，map的key是ThreadLocal，通过其哈希值计算数组下标。\n  不同的变量可以通过定义新的ThreadLocal存储在Thread中。\n  而不同的Thread访问的永远是自己的map，互不影响。\n\n{% img  /image/ThreadLocal/ThreadLocal1.png  '\"ThreadLocal结构\"' %}\n\n\n### 内存溢出问题\n\n  ThreadLocalMap的key为弱引用，但value仍然是强引用。\n{% codeblock lang:java %}\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    Object value;\n    // 这里的k 用的弱引用\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n{% endcodeblock%}\n\n  Entry的key是弱引用指向ThreadLocal实例，这样做的目的是能够及时释放ThreadLocal防止内存溢\n  出。带来的问题是，value是强引用，需要手动清理，否则累积过多会导致内存溢出。\n  每次使用完后，需要记得调用ThreadLocal的remove()方法，这样就能避免内存溢出的问题。\n\n","source":"_posts/2020/07/ThreadLocal1.md","raw":"---\ntitle: ThreadLocal(jdk1.8)\ndate: 2020-07-02 15:57:56\ntags:\n- 多线程\ncategories:\n- Java\n- 多线程\n---\n\n### 前言\n\n  ThreadLocal，也被称作线程本地变量，他为每一个线程创建了变量的副本，使得线程能够访问各自的变量副本，互不影响。\n<!-- more -->\n\n### 属性信息\n\n{% codeblock lang:java %}\n// 用于关联线程的线性哈希\nprivate final int threadLocalHashCode = nextHashCode();\n\n// 下一个哈希值，使用原子更新\nprivate static AtomicInteger nextHashCode = new AtomicInteger();\n\n// 连续hash计算的增长量\nprivate static final int HASH_INCREMENT = 0x61c88647;\n\n// 计算哈希的方法\nprivate static int nextHashCode() {\n    // 使用原子操作计算\n    return nextHashCode.getAndAdd(HASH_INCREMENT);\n}\n{% endcodeblock %}\n\n### 核心方法\n\n{% codeblock lang:java %}\n// 赋值方法\npublic void set(T value) {\n    // 获取当前线程\n    Thread t = Thread.currentThread();\n    // 获取当前线程的ThreadLocalMap实例\n    ThreadLocalMap map = getMap(t);\n    // 判断非空 进行初始化及赋值操作\n    if (map != null)\n        // 这里的this是当前ThreadLocal实例\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\n// 取值方法\npublic T get() {\n    // 获取当前线程对象\n    Thread t = Thread.currentThread();\n    // 获取当前线程的ThreadLocalMap实例\n    ThreadLocalMap map = getMap(t);\n    // 判断map非空，取值\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    // map为空 进行初始化\n    return setInitialValue();\n}\n\n// 获取指定线程对象的ThreadLocalMap\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\n// ThreadLocalMap的初始化及赋值\nvoid createMap(Thread t, T firstValue) {\n    // 这里的this是当前ThreadLocal实例\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n\n// 删除\npublic void remove() {\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        // 调用ThreadLocalMap的remove清理\n        m.remove(this);\n}\n{% endcodeblock %}\n\n  可以从set()看到，这里是将ThreadLocal实例作为map的key存储对应的值。因为ThreadLocalMap属于每个线程私有的变量，通过不同的ThreadLocal实例区分不同的变量。\n  \n### ThreadLocalMap\n  \n  ThreadLocalMap是ThreadLocal内部定义的一个key-value结构的内部类，用于存储线程内部的变量值。\n\n{% codeblock lang:java %}\n// 构造方法\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    table = new Entry[INITIAL_CAPACITY];\n    // 这里使用ThreadLocal的哈希值计算数组下标，与HashMap的逻辑相似\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    setThreshold(INITIAL_CAPACITY);\n}\n\n// 通过key(ThreadLocal)获取value\nprivate Entry getEntry(ThreadLocal<?> key) {\n    int i = key.threadLocalHashCode & (table.length - 1);\n    Entry e = table[i];\n    if (e != null && e.get() == key)\n        return e;\n    else\n        return getEntryAfterMiss(key, i, e);\n}\n\n// 清理value\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    // 手动置空要清除的项\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    // 数组长度修改了，重新计算下标\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n{% endcodeblock %}\n\n### 原理分析\n\n  从上述源码可以看出，每一个Thread都定义了一个ThreadLocalMap的属性用来存储自己的局部变量，map的key是ThreadLocal，通过其哈希值计算数组下标。\n  不同的变量可以通过定义新的ThreadLocal存储在Thread中。\n  而不同的Thread访问的永远是自己的map，互不影响。\n\n{% img  /image/ThreadLocal/ThreadLocal1.png  '\"ThreadLocal结构\"' %}\n\n\n### 内存溢出问题\n\n  ThreadLocalMap的key为弱引用，但value仍然是强引用。\n{% codeblock lang:java %}\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    Object value;\n    // 这里的k 用的弱引用\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n{% endcodeblock%}\n\n  Entry的key是弱引用指向ThreadLocal实例，这样做的目的是能够及时释放ThreadLocal防止内存溢\n  出。带来的问题是，value是强引用，需要手动清理，否则累积过多会导致内存溢出。\n  每次使用完后，需要记得调用ThreadLocal的remove()方法，这样就能避免内存溢出的问题。\n\n","slug":"ThreadLocal1","published":1,"updated":"2020-08-15T12:34:05.005Z","_id":"ckdvmudyp001nnwb599jg4z4h","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  ThreadLocal，也被称作线程本地变量，他为每一个线程创建了变量的副本，使得线程能够访问各自的变量副本，互不影响。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于关联线程的线性哈希</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadLocalHashCode = nextHashCode();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下一个哈希值，使用原子更新</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger nextHashCode = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连续hash计算的增长量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> HASH_INCREMENT = <span class=\"number\">0x61c88647</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算哈希的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextHashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用原子操作计算</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 赋值方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的ThreadLocalMap实例</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"comment\">// 判断非空 进行初始化及赋值操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 这里的this是当前ThreadLocal实例</span></span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取值方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程对象</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的ThreadLocalMap实例</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"comment\">// 判断map非空，取值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// map为空 进行初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定线程对象的ThreadLocalMap</span></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ThreadLocalMap的初始化及赋值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的this是当前ThreadLocal实例</span></span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 调用ThreadLocalMap的remove清理</span></span><br><span class=\"line\">        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  可以从set()看到，这里是将ThreadLocal实例作为map的key存储对应的值。因为ThreadLocalMap属于每个线程私有的变量，通过不同的ThreadLocal实例区分不同的变量。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>  ThreadLocalMap是ThreadLocal内部定义的一个key-value结构的内部类，用于存储线程内部的变量值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[INITIAL_CAPACITY];</span><br><span class=\"line\">    <span class=\"comment\">// 这里使用ThreadLocal的哈希值计算数组下标，与HashMap的逻辑相似</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">    table[i] = <span class=\"keyword\">new</span> Entry(firstKey, firstValue);</span><br><span class=\"line\">    size = <span class=\"number\">1</span>;</span><br><span class=\"line\">    setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过key(ThreadLocal)获取value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    Entry e = table[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清理value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"comment\">// 手动置空要清除的项</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"comment\">// Rehash until we encounter null</span></span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"comment\">// 数组长度修改了，重新计算下标</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class=\"line\">                <span class=\"comment\">// null because multiple entries could have been stale.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, len);</span><br><span class=\"line\">                tab[h] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h3><p>  从上述源码可以看出，每一个Thread都定义了一个ThreadLocalMap的属性用来存储自己的局部变量，map的key是ThreadLocal，通过其哈希值计算数组下标。<br>  不同的变量可以通过定义新的ThreadLocal存储在Thread中。<br>  而不同的Thread访问的永远是自己的map，互不影响。</p>\n<img src=\"/image/ThreadLocal/ThreadLocal1.png\" class=\"\" title=\"ThreadLocal结构\">\n\n\n<h3 id=\"内存溢出问题\"><a href=\"#内存溢出问题\" class=\"headerlink\" title=\"内存溢出问题\"></a>内存溢出问题</h3><p>  ThreadLocalMap的key为弱引用，但value仍然是强引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    Object value;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的k 用的弱引用</span></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  Entry的key是弱引用指向ThreadLocal实例，这样做的目的是能够及时释放ThreadLocal防止内存溢<br>  出。带来的问题是，value是强引用，需要手动清理，否则累积过多会导致内存溢出。<br>  每次使用完后，需要记得调用ThreadLocal的remove()方法，这样就能避免内存溢出的问题。</p>\n","site":{"data":{}},"length":588,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  ThreadLocal，也被称作线程本地变量，他为每一个线程创建了变量的副本，使得线程能够访问各自的变量副本，互不影响。</p>","more":"<h3 id=\"属性信息\"><a href=\"#属性信息\" class=\"headerlink\" title=\"属性信息\"></a>属性信息</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于关联线程的线性哈希</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadLocalHashCode = nextHashCode();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下一个哈希值，使用原子更新</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> AtomicInteger nextHashCode = <span class=\"keyword\">new</span> AtomicInteger();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连续hash计算的增长量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> HASH_INCREMENT = <span class=\"number\">0x61c88647</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计算哈希的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextHashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用原子操作计算</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 赋值方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的ThreadLocalMap实例</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"comment\">// 判断非空 进行初始化及赋值操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 这里的this是当前ThreadLocal实例</span></span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取值方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程对象</span></span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前线程的ThreadLocalMap实例</span></span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"comment\">// 判断map非空，取值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">            T result = (T)e.value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// map为空 进行初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取指定线程对象的ThreadLocalMap</span></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ThreadLocalMap的初始化及赋值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的this是当前ThreadLocal实例</span></span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 调用ThreadLocalMap的remove清理</span></span><br><span class=\"line\">        m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  可以从set()看到，这里是将ThreadLocal实例作为map的key存储对应的值。因为ThreadLocalMap属于每个线程私有的变量，通过不同的ThreadLocal实例区分不同的变量。</p>\n<h3 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h3><p>  ThreadLocalMap是ThreadLocal内部定义的一个key-value结构的内部类，用于存储线程内部的变量值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Entry[INITIAL_CAPACITY];</span><br><span class=\"line\">    <span class=\"comment\">// 这里使用ThreadLocal的哈希值计算数组下标，与HashMap的逻辑相似</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class=\"number\">1</span>);</span><br><span class=\"line\">    table[i] = <span class=\"keyword\">new</span> Entry(firstKey, firstValue);</span><br><span class=\"line\">    size = <span class=\"number\">1</span>;</span><br><span class=\"line\">    setThreshold(INITIAL_CAPACITY);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过key(ThreadLocal)获取value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Entry <span class=\"title\">getEntry</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    Entry e = table[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span> &amp;&amp; e.get() == key)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getEntryAfterMiss(key, i, e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清理value</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"comment\">// 手动置空要清除的项</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"comment\">// Rehash until we encounter null</span></span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"comment\">// 数组长度修改了，重新计算下标</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class=\"line\">                <span class=\"comment\">// null because multiple entries could have been stale.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, len);</span><br><span class=\"line\">                tab[h] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h3><p>  从上述源码可以看出，每一个Thread都定义了一个ThreadLocalMap的属性用来存储自己的局部变量，map的key是ThreadLocal，通过其哈希值计算数组下标。<br>  不同的变量可以通过定义新的ThreadLocal存储在Thread中。<br>  而不同的Thread访问的永远是自己的map，互不影响。</p>\n<img src=\"/image/ThreadLocal/ThreadLocal1.png\" class=\"\" title=\"ThreadLocal结构\">\n\n\n<h3 id=\"内存溢出问题\"><a href=\"#内存溢出问题\" class=\"headerlink\" title=\"内存溢出问题\"></a>内存溢出问题</h3><p>  ThreadLocalMap的key为弱引用，但value仍然是强引用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">    Object value;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的k 用的弱引用</span></span><br><span class=\"line\">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">        value = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  Entry的key是弱引用指向ThreadLocal实例，这样做的目的是能够及时释放ThreadLocal防止内存溢<br>  出。带来的问题是，value是强引用，需要手动清理，否则累积过多会导致内存溢出。<br>  每次使用完后，需要记得调用ThreadLocal的remove()方法，这样就能避免内存溢出的问题。</p>"},{"title":"浅析AQS(jdk1.8)","date":"2020-07-14T08:52:35.000Z","_content":"\n### 前言\n\n  作为JUC并法包的核心组件，AQS是学习JUC必不可少的一步，本章就来看看AQS是怎样实现同步需求的。\n<!-- more -->\n\n### state\n  \n  state是一个计数值，用来表示同步状态，state>0表示占用了锁，等于0则释放锁，像CountDownLatch中就是用state的值来判断是否释放锁唤醒等待线程。\n{% codeblock lang:java %}\n// state属性\nprivate volatile int state;\n\n// 返回当前的state值，因为state是volatile修饰的，所以每次都是读的主存\nprotected final int getState() {\n    return state;\n}\n\n// 设置state值，同样基于volatile是直接写的主存\nprotected final void setState(int newState) {\n    state = newState;\n}\n\n// 使用CAS方式修改state\nprotected final boolean compareAndSetState(int expect, int update) {\n    // See below for intrinsics setup to support this\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n{% endcodeblock %}\n\n### FIFO队列\n\n  除了使用state表示同步状态，AQS还维护了一个FIFO队列来存储等待的线程信息。\n\n{% codeblock lang:java %}\n// 队列节点Node类\nstatic final class Node {\n    // 共享标记\n    static final Node SHARED = new Node();\n    // 独占标记\n    static final Node EXCLUSIVE = null;\n\n    // waitStatus值，表示取消状态，线程不会再参与竞争\n    static final int CANCELLED =  1;\n    // waitStatus值，表示后继线程需要出列\n    static final int SIGNAL    = -1;\n    // waitStatus值，当前线程正在等待\n    static final int CONDITION = -2;\n    // waitStatus值，表示下一次的共享式同步状态的获取应无条件传播\n    static final int PROPAGATE = -3;\n\n    // 等待状态\n    volatile int waitStatus;\n\n    // 上一节点\n    volatile Node prev;\n    // 下一节点\n    volatile Node next;\n\n    // 节点所属线程\n    volatile Thread thread;\n\n    // 维护条件队列的节点或者存独占/共享模式的标识\n    Node nextWaiter;\n\n    final boolean isShared() {\n        return nextWaiter == SHARED;\n    }\n\n    // 返回上一个节点，为空则抛出空指针\n    final Node predecessor() throws NullPointerException {\n        Node p = prev;\n        if (p == null)\n            throw new NullPointerException();\n        else\n            return p;\n    }\n\n    // Used to establish initial head or SHARED marker\n    Node() {   \n    }\n    Node(Thread thread, Node mode) {     // Used by addWaiter\n        // 独占/共享失败时调用addWaiter()，通过入参设置独占/共享标识\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n    Node(Thread thread, int waitStatus) { // Used by Condition\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n{% endcodeblock %}\n\n  从Node类可以看到，每一个节点都保存了对应线程信息并维护了一个waitStatus信息来判断如何操作。\n  并且每一个节点都指向了他的前一节点和后一节点，可以看出这个队列是一个双向队列。\n\n  下面再来看看AQS中是如何操作这个队列的：\n\n{% codeblock lang:java %}\n// 队列头节点 头节点如果存在，其waitStatus不会被设置为CANCELLED\nprivate transient volatile Node head;\n\n// 队列尾节点\nprivate transient volatile Node tail;\n\n// 节点插入队列\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        // 尾节点为空则初始化\n        if (t == null) { // Must initialize\n            // 使用CAS保证线程安全\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            // 尾部插入节点\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n\n// 设置头节点\nprivate void setHead(Node node) {\n    head = node;\n    node.thread = null;\n    node.prev = null;\n}\n\n// 当前线程加入队列尾部\nprivate Node addWaiter(Node mode) {\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);\n    return node;\n}\n{% endcodeblock %}\n\n  从节点的定义可以看到，这是一个双向队列，AQS维护了指向这个队列头尾的两个指针，每次新增的节点都是从尾部插入。\n\n### 获取释放操作\n\n  在看完了AQS队列结构后，接下来就来看看AQS为实现同步需求提供的一些操作方法。\n\n#### \"抽象\"方法\n\n  AQS中有几个方法并没有具体实现逻辑，这些方法都需要子类自己去实现，AQS只是定义了方法的含义。\n\n{% codeblock lang:java %}\n// 独占模式的获取\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n// 独占模式的释放\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n// 共享模式的获取\n// 返回结果：\n// 1. 负值表示失败\n// 2. 0表示成功，但无法再执行获取操作\n// 3. 整数表示成功，后续的获取操作也能成功，但需要检查可用性\nprotected int tryAcquireShared(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n// 共享模式的释放\nprotected boolean tryReleaseShared(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n// \nprotected boolean isHeldExclusively() {\n    throw new UnsupportedOperationException();\n}\n{% endcodeblock %}\n\n\n#### 模板方法\n\n  AQS还提供了一些实现了具体逻辑的获取释放操作的模板方法。\n\n##### 独占模式\n{% codeblock lang:java %}\n// 独占模式的获取\npublic final void acquire(int arg) {\n    // 1. 调用tryAcquire()进行独占模式的获取操作\n    // 2. tryAcquire() 失败，则调用addWaiter将节点加入队列\n    // 3. 调用acquireQueue() 自旋等待\n    // 4. 若acquireQueue() 返回结果中断过，中断当前线程\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n// 自旋等待资源释放\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        // 自旋不停的请求获取操作\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;// 返回是否中断过\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                // 方法中断，记录结果，节点依然在队列中等待\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            // 失败，取消正在尝试获取的操作\n            cancelAcquire(node);\n    }\n}\n\n// 响应中断的独占模式的获取\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    // 线程中断，直接抛异常\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        // 逻辑与acquireQueue()类似，但线程中断会抛异常\n        doAcquireInterruptibly(arg);\n}\n\n// 设置等待时间的独占模式的获取\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n        throws InterruptedException {\n    // 依然会对中断响应\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    return tryAcquire(arg) ||\n        doAcquireNanos(arg, nanosTimeout);\n}\n\n// 等待时间的独占模式获取\nprivate boolean doAcquireNanos(int arg, long nanosTimeout)\n        throws InterruptedException {\n    if (nanosTimeout <= 0L)\n        return false;\n    // 根据入参计算到期时间戳\n    final long deadline = System.nanoTime() + nanosTimeout;\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return true;\n            }\n            // 每一次自旋判断时间是否超时\n            nanosTimeout = deadline - System.nanoTime();\n            if (nanosTimeout <= 0L)\n                return false;\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                nanosTimeout > spinForTimeoutThreshold)\n                LockSupport.parkNanos(this, nanosTimeout);\n            if (Thread.interrupted())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n// 独占模式的释放\npublic final boolean release(int arg) {\n    // 调用子类实现的tryRelease()方法\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            // 唤醒头节点的下一节点\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n{% endcodeblock %}\n\n##### 共享模式\n\n{% codeblock lang:java %}\n// 共享模式的获取\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        // 获取失败，进入队列自旋等待\n        doAcquireShared(arg);\n}\n\n// 加入队列，自旋等待，不响应中断\nprivate void doAcquireShared(int arg) {\n    // 节点加入队列，设置为共享模式\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        // 自旋不断尝试获取\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n// 共享模式的释放\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n// 释放逻辑\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n{% endcodeblock %}\n\n  共享模式的获取同样有响应中断和超时等待两种，逻辑大致与独占式类似就不一一列举。\n\n### 条件队列\n\n  除了Node内部类，AQS中还有个ConditionObject内部类，其内部维护了针对条件队列的方法。\n  条件队列的元素同样是Node对象，但借助其nextWaiter属性维护。\n\n#### 类定义\n\n{% codeblock lang:java %}\n// 实现了Condition接口\npublic class ConditionObject implements Condition, java.io.Serializable\n{% endcodeblock %}\n\n#### 主要方法\n\n{% codeblock lang:java %}\n// 从条件队列移除，进入等待队列\npublic final void signal() {\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n\n// 条件等待\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 进入条件队列\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    // 判断是否处于同步队列中\n    while (!isOnSyncQueue(node)) {\n        // 阻塞当前线程\n        LockSupport.park(this);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n{% endcodeblock %}\n\n### 小结\n\n      AQS实现同步需求的基础就是依赖一个FIFO的队列。当获取操作失败时，就会将当前线程加入队\n    列，用自旋的方式不断尝试获取直到成功。\n      本章只是从AQS的数据结构及获取释放操作来了解他是如何实现同步需求的，其实还有许多底层\n    实现逻辑值得分析，这里因为篇幅原因就不一一分析了。\n      AQS的设计确实非常全面，考虑到了各种可能，不过也因此，单看他的源码会觉得难以联系具体\n    场景去深入理解。个人认为最好结合JUC中依赖AQS实现的各种工具类来理解会更透彻些。","source":"_posts/2020/07/AQS1.md","raw":"---\ntitle: 浅析AQS(jdk1.8)\ndate: 2020-07-14 16:52:35\ntags:\n- JUC\ncategories:\n- Java\n- JUC\n---\n\n### 前言\n\n  作为JUC并法包的核心组件，AQS是学习JUC必不可少的一步，本章就来看看AQS是怎样实现同步需求的。\n<!-- more -->\n\n### state\n  \n  state是一个计数值，用来表示同步状态，state>0表示占用了锁，等于0则释放锁，像CountDownLatch中就是用state的值来判断是否释放锁唤醒等待线程。\n{% codeblock lang:java %}\n// state属性\nprivate volatile int state;\n\n// 返回当前的state值，因为state是volatile修饰的，所以每次都是读的主存\nprotected final int getState() {\n    return state;\n}\n\n// 设置state值，同样基于volatile是直接写的主存\nprotected final void setState(int newState) {\n    state = newState;\n}\n\n// 使用CAS方式修改state\nprotected final boolean compareAndSetState(int expect, int update) {\n    // See below for intrinsics setup to support this\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n{% endcodeblock %}\n\n### FIFO队列\n\n  除了使用state表示同步状态，AQS还维护了一个FIFO队列来存储等待的线程信息。\n\n{% codeblock lang:java %}\n// 队列节点Node类\nstatic final class Node {\n    // 共享标记\n    static final Node SHARED = new Node();\n    // 独占标记\n    static final Node EXCLUSIVE = null;\n\n    // waitStatus值，表示取消状态，线程不会再参与竞争\n    static final int CANCELLED =  1;\n    // waitStatus值，表示后继线程需要出列\n    static final int SIGNAL    = -1;\n    // waitStatus值，当前线程正在等待\n    static final int CONDITION = -2;\n    // waitStatus值，表示下一次的共享式同步状态的获取应无条件传播\n    static final int PROPAGATE = -3;\n\n    // 等待状态\n    volatile int waitStatus;\n\n    // 上一节点\n    volatile Node prev;\n    // 下一节点\n    volatile Node next;\n\n    // 节点所属线程\n    volatile Thread thread;\n\n    // 维护条件队列的节点或者存独占/共享模式的标识\n    Node nextWaiter;\n\n    final boolean isShared() {\n        return nextWaiter == SHARED;\n    }\n\n    // 返回上一个节点，为空则抛出空指针\n    final Node predecessor() throws NullPointerException {\n        Node p = prev;\n        if (p == null)\n            throw new NullPointerException();\n        else\n            return p;\n    }\n\n    // Used to establish initial head or SHARED marker\n    Node() {   \n    }\n    Node(Thread thread, Node mode) {     // Used by addWaiter\n        // 独占/共享失败时调用addWaiter()，通过入参设置独占/共享标识\n        this.nextWaiter = mode;\n        this.thread = thread;\n    }\n    Node(Thread thread, int waitStatus) { // Used by Condition\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n{% endcodeblock %}\n\n  从Node类可以看到，每一个节点都保存了对应线程信息并维护了一个waitStatus信息来判断如何操作。\n  并且每一个节点都指向了他的前一节点和后一节点，可以看出这个队列是一个双向队列。\n\n  下面再来看看AQS中是如何操作这个队列的：\n\n{% codeblock lang:java %}\n// 队列头节点 头节点如果存在，其waitStatus不会被设置为CANCELLED\nprivate transient volatile Node head;\n\n// 队列尾节点\nprivate transient volatile Node tail;\n\n// 节点插入队列\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        // 尾节点为空则初始化\n        if (t == null) { // Must initialize\n            // 使用CAS保证线程安全\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            // 尾部插入节点\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n\n// 设置头节点\nprivate void setHead(Node node) {\n    head = node;\n    node.thread = null;\n    node.prev = null;\n}\n\n// 当前线程加入队列尾部\nprivate Node addWaiter(Node mode) {\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    if (pred != null) {\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);\n    return node;\n}\n{% endcodeblock %}\n\n  从节点的定义可以看到，这是一个双向队列，AQS维护了指向这个队列头尾的两个指针，每次新增的节点都是从尾部插入。\n\n### 获取释放操作\n\n  在看完了AQS队列结构后，接下来就来看看AQS为实现同步需求提供的一些操作方法。\n\n#### \"抽象\"方法\n\n  AQS中有几个方法并没有具体实现逻辑，这些方法都需要子类自己去实现，AQS只是定义了方法的含义。\n\n{% codeblock lang:java %}\n// 独占模式的获取\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n// 独占模式的释放\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n// 共享模式的获取\n// 返回结果：\n// 1. 负值表示失败\n// 2. 0表示成功，但无法再执行获取操作\n// 3. 整数表示成功，后续的获取操作也能成功，但需要检查可用性\nprotected int tryAcquireShared(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n// 共享模式的释放\nprotected boolean tryReleaseShared(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n// \nprotected boolean isHeldExclusively() {\n    throw new UnsupportedOperationException();\n}\n{% endcodeblock %}\n\n\n#### 模板方法\n\n  AQS还提供了一些实现了具体逻辑的获取释放操作的模板方法。\n\n##### 独占模式\n{% codeblock lang:java %}\n// 独占模式的获取\npublic final void acquire(int arg) {\n    // 1. 调用tryAcquire()进行独占模式的获取操作\n    // 2. tryAcquire() 失败，则调用addWaiter将节点加入队列\n    // 3. 调用acquireQueue() 自旋等待\n    // 4. 若acquireQueue() 返回结果中断过，中断当前线程\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n// 自旋等待资源释放\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        // 自旋不停的请求获取操作\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;// 返回是否中断过\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                // 方法中断，记录结果，节点依然在队列中等待\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            // 失败，取消正在尝试获取的操作\n            cancelAcquire(node);\n    }\n}\n\n// 响应中断的独占模式的获取\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    // 线程中断，直接抛异常\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        // 逻辑与acquireQueue()类似，但线程中断会抛异常\n        doAcquireInterruptibly(arg);\n}\n\n// 设置等待时间的独占模式的获取\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n        throws InterruptedException {\n    // 依然会对中断响应\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    return tryAcquire(arg) ||\n        doAcquireNanos(arg, nanosTimeout);\n}\n\n// 等待时间的独占模式获取\nprivate boolean doAcquireNanos(int arg, long nanosTimeout)\n        throws InterruptedException {\n    if (nanosTimeout <= 0L)\n        return false;\n    // 根据入参计算到期时间戳\n    final long deadline = System.nanoTime() + nanosTimeout;\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return true;\n            }\n            // 每一次自旋判断时间是否超时\n            nanosTimeout = deadline - System.nanoTime();\n            if (nanosTimeout <= 0L)\n                return false;\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                nanosTimeout > spinForTimeoutThreshold)\n                LockSupport.parkNanos(this, nanosTimeout);\n            if (Thread.interrupted())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n// 独占模式的释放\npublic final boolean release(int arg) {\n    // 调用子类实现的tryRelease()方法\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            // 唤醒头节点的下一节点\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n{% endcodeblock %}\n\n##### 共享模式\n\n{% codeblock lang:java %}\n// 共享模式的获取\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        // 获取失败，进入队列自旋等待\n        doAcquireShared(arg);\n}\n\n// 加入队列，自旋等待，不响应中断\nprivate void doAcquireShared(int arg) {\n    // 节点加入队列，设置为共享模式\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        // 自旋不断尝试获取\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n// 共享模式的释放\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n// 释放逻辑\nprivate void doReleaseShared() {\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n{% endcodeblock %}\n\n  共享模式的获取同样有响应中断和超时等待两种，逻辑大致与独占式类似就不一一列举。\n\n### 条件队列\n\n  除了Node内部类，AQS中还有个ConditionObject内部类，其内部维护了针对条件队列的方法。\n  条件队列的元素同样是Node对象，但借助其nextWaiter属性维护。\n\n#### 类定义\n\n{% codeblock lang:java %}\n// 实现了Condition接口\npublic class ConditionObject implements Condition, java.io.Serializable\n{% endcodeblock %}\n\n#### 主要方法\n\n{% codeblock lang:java %}\n// 从条件队列移除，进入等待队列\npublic final void signal() {\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n\n// 条件等待\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 进入条件队列\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    // 判断是否处于同步队列中\n    while (!isOnSyncQueue(node)) {\n        // 阻塞当前线程\n        LockSupport.park(this);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n{% endcodeblock %}\n\n### 小结\n\n      AQS实现同步需求的基础就是依赖一个FIFO的队列。当获取操作失败时，就会将当前线程加入队\n    列，用自旋的方式不断尝试获取直到成功。\n      本章只是从AQS的数据结构及获取释放操作来了解他是如何实现同步需求的，其实还有许多底层\n    实现逻辑值得分析，这里因为篇幅原因就不一一分析了。\n      AQS的设计确实非常全面，考虑到了各种可能，不过也因此，单看他的源码会觉得难以联系具体\n    场景去深入理解。个人认为最好结合JUC中依赖AQS实现的各种工具类来理解会更透彻些。","slug":"AQS1","published":1,"updated":"2021-05-10T13:16:10.471Z","_id":"ckdvmudyq001qnwb53cb33r2b","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  作为JUC并法包的核心组件，AQS是学习JUC必不可少的一步，本章就来看看AQS是怎样实现同步需求的。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p>  state是一个计数值，用来表示同步状态，state&gt;0表示占用了锁，等于0则释放锁，像CountDownLatch中就是用state的值来判断是否释放锁唤醒等待线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// state属性</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回当前的state值，因为state是volatile修饰的，所以每次都是读的主存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置state值，同样基于volatile是直接写的主存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span> </span>&#123;</span><br><span class=\"line\">    state = newState;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用CAS方式修改state</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetState</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// See below for intrinsics setup to support this</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h3><p>  除了使用state表示同步状态，AQS还维护了一个FIFO队列来存储等待的线程信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队列节点Node类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 共享标记</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">    <span class=\"comment\">// 独占标记</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// waitStatus值，表示取消状态，线程不会再参与竞争</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// waitStatus值，表示后继线程需要出列</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// waitStatus值，当前线程正在等待</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">// waitStatus值，表示下一次的共享式同步状态的获取应无条件传播</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待状态</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> waitStatus;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 上一节点</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node prev;</span><br><span class=\"line\">    <span class=\"comment\">// 下一节点</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点所属线程</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 维护条件队列的节点或者存独占/共享模式的标识</span></span><br><span class=\"line\">    Node nextWaiter;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextWaiter == SHARED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回上一个节点，为空则抛出空指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node <span class=\"title\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">        Node p = prev;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Used to establish initial head or SHARED marker</span></span><br><span class=\"line\">    Node() &#123;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node(Thread thread, Node mode) &#123;     <span class=\"comment\">// Used by addWaiter</span></span><br><span class=\"line\">        <span class=\"comment\">// 独占/共享失败时调用addWaiter()，通过入参设置独占/共享标识</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextWaiter = mode;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node(Thread thread, <span class=\"keyword\">int</span> waitStatus) &#123; <span class=\"comment\">// Used by Condition</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.waitStatus = waitStatus;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  从Node类可以看到，每一个节点都保存了对应线程信息并维护了一个waitStatus信息来判断如何操作。<br>  并且每一个节点都指向了他的前一节点和后一节点，可以看出这个队列是一个双向队列。</p>\n<p>  下面再来看看AQS中是如何操作这个队列的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队列头节点 头节点如果存在，其waitStatus不会被设置为CANCELLED</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node head;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 队列尾节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node tail;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 节点插入队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"comment\">// 尾节点为空则初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            <span class=\"comment\">// 使用CAS保证线程安全</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 尾部插入节点</span></span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置头节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHead</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    head = node;</span><br><span class=\"line\">    node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    node.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当前线程加入队列尾部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  从节点的定义可以看到，这是一个双向队列，AQS维护了指向这个队列头尾的两个指针，每次新增的节点都是从尾部插入。</p>\n<h3 id=\"获取释放操作\"><a href=\"#获取释放操作\" class=\"headerlink\" title=\"获取释放操作\"></a>获取释放操作</h3><p>  在看完了AQS队列结构后，接下来就来看看AQS为实现同步需求提供的一些操作方法。</p>\n<h4 id=\"“抽象”方法\"><a href=\"#“抽象”方法\" class=\"headerlink\" title=\"“抽象”方法\"></a>“抽象”方法</h4><p>  AQS中有几个方法并没有具体实现逻辑，这些方法都需要子类自己去实现，AQS只是定义了方法的含义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 独占模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 独占模式的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 共享模式的获取</span></span><br><span class=\"line\"><span class=\"comment\">// 返回结果：</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 负值表示失败</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 0表示成功，但无法再执行获取操作</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 整数表示成功，后续的获取操作也能成功，但需要检查可用性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 共享模式的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"模板方法\"><a href=\"#模板方法\" class=\"headerlink\" title=\"模板方法\"></a>模板方法</h4><p>  AQS还提供了一些实现了具体逻辑的获取释放操作的模板方法。</p>\n<h5 id=\"独占模式\"><a href=\"#独占模式\" class=\"headerlink\" title=\"独占模式\"></a>独占模式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 独占模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 调用tryAcquire()进行独占模式的获取操作</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. tryAcquire() 失败，则调用addWaiter将节点加入队列</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 调用acquireQueue() 自旋等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 4. 若acquireQueue() 返回结果中断过，中断当前线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自旋等待资源释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 自旋不停的请求获取操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;<span class=\"comment\">// 返回是否中断过</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                <span class=\"comment\">// 方法中断，记录结果，节点依然在队列中等待</span></span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            <span class=\"comment\">// 失败，取消正在尝试获取的操作</span></span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应中断的独占模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 线程中断，直接抛异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg))</span><br><span class=\"line\">        <span class=\"comment\">// 逻辑与acquireQueue()类似，但线程中断会抛异常</span></span><br><span class=\"line\">        doAcquireInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置等待时间的独占模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquireNanos</span><span class=\"params\">(<span class=\"keyword\">int</span> arg, <span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依然会对中断响应</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tryAcquire(arg) ||</span><br><span class=\"line\">        doAcquireNanos(arg, nanosTimeout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待时间的独占模式获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">doAcquireNanos</span><span class=\"params\">(<span class=\"keyword\">int</span> arg, <span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 根据入参计算到期时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 每一次自旋判断时间是否超时</span></span><br><span class=\"line\">            nanosTimeout = deadline - System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanosTimeout);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 独占模式的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用子类实现的tryRelease()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 唤醒头节点的下一节点</span></span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"共享模式\"><a href=\"#共享模式\" class=\"headerlink\" title=\"共享模式\"></a>共享模式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 共享模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 获取失败，进入队列自旋等待</span></span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加入队列，自旋等待，不响应中断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 节点加入队列，设置为共享模式</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 自旋不断尝试获取</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = tryAcquireShared(arg);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (interrupted)</span><br><span class=\"line\">                        selfInterrupt();</span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 共享模式的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head)                   <span class=\"comment\">// loop if head changed</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  共享模式的获取同样有响应中断和超时等待两种，逻辑大致与独占式类似就不一一列举。</p>\n<h3 id=\"条件队列\"><a href=\"#条件队列\" class=\"headerlink\" title=\"条件队列\"></a>条件队列</h3><p>  除了Node内部类，AQS中还有个ConditionObject内部类，其内部维护了针对条件队列的方法。<br>  条件队列的元素同样是Node对象，但借助其nextWaiter属性维护。</p>\n<h4 id=\"类定义\"><a href=\"#类定义\" class=\"headerlink\" title=\"类定义\"></a>类定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现了Condition接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConditionObject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从条件队列移除，进入等待队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignal(first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 条件等待</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">// 进入条件队列</span></span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否处于同步队列中</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞当前线程</span></span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  AQS实现同步需求的基础就是依赖一个FIFO的队列。当获取操作失败时，就会将当前线程加入队\n列，用自旋的方式不断尝试获取直到成功。\n  本章只是从AQS的数据结构及获取释放操作来了解他是如何实现同步需求的，其实还有许多底层\n实现逻辑值得分析，这里因为篇幅原因就不一一分析了。\n  AQS的设计确实非常全面，考虑到了各种可能，不过也因此，单看他的源码会觉得难以联系具体\n场景去深入理解。个人认为最好结合JUC中依赖AQS实现的各种工具类来理解会更透彻些。</code></pre>","site":{"data":{}},"length":858,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  作为JUC并法包的核心组件，AQS是学习JUC必不可少的一步，本章就来看看AQS是怎样实现同步需求的。</p>","more":"<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p>  state是一个计数值，用来表示同步状态，state&gt;0表示占用了锁，等于0则释放锁，像CountDownLatch中就是用state的值来判断是否释放锁唤醒等待线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// state属性</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回当前的state值，因为state是volatile修饰的，所以每次都是读的主存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置state值，同样基于volatile是直接写的主存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span> </span>&#123;</span><br><span class=\"line\">    state = newState;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用CAS方式修改state</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetState</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// See below for intrinsics setup to support this</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> unsafe.compareAndSwapInt(<span class=\"keyword\">this</span>, stateOffset, expect, update);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"FIFO队列\"><a href=\"#FIFO队列\" class=\"headerlink\" title=\"FIFO队列\"></a>FIFO队列</h3><p>  除了使用state表示同步状态，AQS还维护了一个FIFO队列来存储等待的线程信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队列节点Node类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 共享标记</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">    <span class=\"comment\">// 独占标记</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// waitStatus值，表示取消状态，线程不会再参与竞争</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// waitStatus值，表示后继线程需要出列</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// waitStatus值，当前线程正在等待</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"comment\">// waitStatus值，表示下一次的共享式同步状态的获取应无条件传播</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待状态</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> waitStatus;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 上一节点</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node prev;</span><br><span class=\"line\">    <span class=\"comment\">// 下一节点</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Node next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 节点所属线程</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 维护条件队列的节点或者存独占/共享模式的标识</span></span><br><span class=\"line\">    Node nextWaiter;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextWaiter == SHARED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回上一个节点，为空则抛出空指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Node <span class=\"title\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">        Node p = prev;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Used to establish initial head or SHARED marker</span></span><br><span class=\"line\">    Node() &#123;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node(Thread thread, Node mode) &#123;     <span class=\"comment\">// Used by addWaiter</span></span><br><span class=\"line\">        <span class=\"comment\">// 独占/共享失败时调用addWaiter()，通过入参设置独占/共享标识</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextWaiter = mode;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node(Thread thread, <span class=\"keyword\">int</span> waitStatus) &#123; <span class=\"comment\">// Used by Condition</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.waitStatus = waitStatus;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  从Node类可以看到，每一个节点都保存了对应线程信息并维护了一个waitStatus信息来判断如何操作。<br>  并且每一个节点都指向了他的前一节点和后一节点，可以看出这个队列是一个双向队列。</p>\n<p>  下面再来看看AQS中是如何操作这个队列的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队列头节点 头节点如果存在，其waitStatus不会被设置为CANCELLED</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node head;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 队列尾节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node tail;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 节点插入队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"comment\">// 尾节点为空则初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            <span class=\"comment\">// 使用CAS保证线程安全</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 尾部插入节点</span></span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置头节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">setHead</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    head = node;</span><br><span class=\"line\">    node.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    node.prev = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当前线程加入队列尾部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        node.prev = pred;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  从节点的定义可以看到，这是一个双向队列，AQS维护了指向这个队列头尾的两个指针，每次新增的节点都是从尾部插入。</p>\n<h3 id=\"获取释放操作\"><a href=\"#获取释放操作\" class=\"headerlink\" title=\"获取释放操作\"></a>获取释放操作</h3><p>  在看完了AQS队列结构后，接下来就来看看AQS为实现同步需求提供的一些操作方法。</p>\n<h4 id=\"“抽象”方法\"><a href=\"#“抽象”方法\" class=\"headerlink\" title=\"“抽象”方法\"></a>“抽象”方法</h4><p>  AQS中有几个方法并没有具体实现逻辑，这些方法都需要子类自己去实现，AQS只是定义了方法的含义。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 独占模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 独占模式的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 共享模式的获取</span></span><br><span class=\"line\"><span class=\"comment\">// 返回结果：</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 负值表示失败</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 0表示成功，但无法再执行获取操作</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 整数表示成功，后续的获取操作也能成功，但需要检查可用性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 共享模式的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"模板方法\"><a href=\"#模板方法\" class=\"headerlink\" title=\"模板方法\"></a>模板方法</h4><p>  AQS还提供了一些实现了具体逻辑的获取释放操作的模板方法。</p>\n<h5 id=\"独占模式\"><a href=\"#独占模式\" class=\"headerlink\" title=\"独占模式\"></a>独占模式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 独占模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 调用tryAcquire()进行独占模式的获取操作</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. tryAcquire() 失败，则调用addWaiter将节点加入队列</span></span><br><span class=\"line\">    <span class=\"comment\">// 3. 调用acquireQueue() 自旋等待</span></span><br><span class=\"line\">    <span class=\"comment\">// 4. 若acquireQueue() 返回结果中断过，中断当前线程</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 自旋等待资源释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 自旋不停的请求获取操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interrupted;<span class=\"comment\">// 返回是否中断过</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                <span class=\"comment\">// 方法中断，记录结果，节点依然在队列中等待</span></span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            <span class=\"comment\">// 失败，取消正在尝试获取的操作</span></span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 响应中断的独占模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 线程中断，直接抛异常</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg))</span><br><span class=\"line\">        <span class=\"comment\">// 逻辑与acquireQueue()类似，但线程中断会抛异常</span></span><br><span class=\"line\">        doAcquireInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置等待时间的独占模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquireNanos</span><span class=\"params\">(<span class=\"keyword\">int</span> arg, <span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依然会对中断响应</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tryAcquire(arg) ||</span><br><span class=\"line\">        doAcquireNanos(arg, nanosTimeout);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待时间的独占模式获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">doAcquireNanos</span><span class=\"params\">(<span class=\"keyword\">int</span> arg, <span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 根据入参计算到期时间戳</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 每一次自旋判断时间是否超时</span></span><br><span class=\"line\">            nanosTimeout = deadline - System.nanoTime();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nanosTimeout &lt;= <span class=\"number\">0L</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"keyword\">this</span>, nanosTimeout);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 独占模式的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用子类实现的tryRelease()方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 唤醒头节点的下一节点</span></span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"共享模式\"><a href=\"#共享模式\" class=\"headerlink\" title=\"共享模式\"></a>共享模式</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 共享模式的获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 获取失败，进入队列自旋等待</span></span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加入队列，自旋等待，不响应中断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 节点加入队列，设置为共享模式</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 自旋不断尝试获取</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> r = tryAcquireShared(arg);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (r &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (interrupted)</span><br><span class=\"line\">                        selfInterrupt();</span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 共享模式的释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doReleaseShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> ws = h.waitStatus;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class=\"number\">0</span>))</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;            <span class=\"comment\">// loop to recheck cases</span></span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ws == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, <span class=\"number\">0</span>, Node.PROPAGATE))</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;                <span class=\"comment\">// loop on failed CAS</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == head)                   <span class=\"comment\">// loop if head changed</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  共享模式的获取同样有响应中断和超时等待两种，逻辑大致与独占式类似就不一一列举。</p>\n<h3 id=\"条件队列\"><a href=\"#条件队列\" class=\"headerlink\" title=\"条件队列\"></a>条件队列</h3><p>  除了Node内部类，AQS中还有个ConditionObject内部类，其内部维护了针对条件队列的方法。<br>  条件队列的元素同样是Node对象，但借助其nextWaiter属性维护。</p>\n<h4 id=\"类定义\"><a href=\"#类定义\" class=\"headerlink\" title=\"类定义\"></a>类定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现了Condition接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConditionObject</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"主要方法\"><a href=\"#主要方法\" class=\"headerlink\" title=\"主要方法\"></a>主要方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从条件队列移除，进入等待队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignal(first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 条件等待</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">// 进入条件队列</span></span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否处于同步队列中</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 阻塞当前线程</span></span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  AQS实现同步需求的基础就是依赖一个FIFO的队列。当获取操作失败时，就会将当前线程加入队\n列，用自旋的方式不断尝试获取直到成功。\n  本章只是从AQS的数据结构及获取释放操作来了解他是如何实现同步需求的，其实还有许多底层\n实现逻辑值得分析，这里因为篇幅原因就不一一分析了。\n  AQS的设计确实非常全面，考虑到了各种可能，不过也因此，单看他的源码会觉得难以联系具体\n场景去深入理解。个人认为最好结合JUC中依赖AQS实现的各种工具类来理解会更透彻些。</code></pre>"},{"title":"CountDownLatch(jdk1.8)","date":"2020-07-13T14:09:40.000Z","_content":"\n### 前言\n\n  本章对CountDownLatch的原理及应用场景总结一下。\n<!-- more -->\n\n### 源码解读\n\n#### 内部类Sync\n\n{% codeblock lang:java %}\n// 继承了AQS的内部类，使用AQS的state作为计数\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 4982264981922014374L;\n    Sync(int count) {\n        setState(count);\n    }\n    int getCount() {\n        return getState();\n    }\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n    // countDown操作\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            // 使用CAS更新state\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n{% endcodeblock %}\n\n#### 操作方法\n\n{% codeblock lang:java %}\n// 构造方法，初始化count，可以调用await()使之休眠直到count归零\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException(\"count < 0\");\n    this.sync = new Sync(count);\n}\n\n// 使当前线程等待，直到计数count归零才会唤醒\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n// 使当前线程等待，直到计数count归零 或 等待时间==timeout\npublic boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n}\n\n// 计数器递减\n// count>0 -1 若-1操作的结果为零则唤醒所有等待线程\n// count==0 不做操作\npublic void countDown() {\n    sync.releaseShared(1);\n}\n{% endcodeblock %}\n\n#### 调用的AQS方法\n{% codeblock lang:java %}\n// 等待阻塞\npublic final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // tryAcquireShared(arg)走Sync重写的逻辑判断计数\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n\n// 释放\npublic final boolean releaseShared(int arg) {\n    // 这里的tryReleaseShared(arg)走的使Sync重写的逻辑\n    if (tryReleaseShared(arg)) {\n        // 确认释放，走AQS的释放方法\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n{% endcodeblock %}\n\n  从源码中可以看到，CountDownLatch的实现依赖于继承了AQS的内部类Sync。\n  他的操作方法不错，主要就是初始化定义计数阈值，然后通过await()方法阻塞线程直到计数归零，同归countDown()递减控制计数。\n\n### 使用示例\n\n{% codeblock lang:java %}\npublic void mian(String[] args){\n    CountDownLatch masterFlag = new CountDownLatch(1);\n    CountDownLatch slaveFlag = new CountDownLatch(3);\n    new Thread(() -> {\n        try {\n            masterFlag.await(1, TimeUnit.MILLISECONDS);\n            logger.info(\"thread run not waiting：{}\", Thread.currentThread().getName());\n            slaveFlag.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }).start();\n    for (int i = 0; i < 2; i++) {\n        new Thread(() -> {\n            try {\n                masterFlag.await();\n                logger.info(\"start sleep:{}\", Thread.currentThread().getName());\n                Thread.sleep(10000);\n                logger.info(\"thread run：{}\", Thread.currentThread().getName());\n                slaveFlag.countDown();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n    Thread.sleep(10000);\n    masterFlag.countDown();\n    logger.info(\"master countDown\");\n    slaveFlag.await();\n    logger.info(\"slave countDown finish\");\n}\n{% endcodeblock %}\n\n  输出结果\n\n{% img /image/CountDownLatch/CountDownLatch1.png '\"示例结果\"'%}\n\n  从结果可以看到，Thread-4因为使用的是*await(long, timeUnit)* 方法，其等待时间比较短，所以在主线程休眠时就会被唤醒。\n  而其他线程都是等到主线程休眠计数将*masterFlag* 计数归零后才被唤醒。\n\n### 小结\n\n      总的来看CountDownLatch其实很好理解，借助AQS实现一个计数器，以达到控制线程等待唤醒的目\n    的。不过想要理解他的底层实现原理就得了解AQS的实现了，关于AQS的内容就不在本章赘述。\n      在实际应用中，CountDownLatch应该是控制一批线程相互等待并让其同时被唤醒这种场景。例如批\n    量下载，要求全部下载完之后发送一个成功的提醒。\n\n> [浅析AQS(jdk1.8)](https://rel-fly.com/2020/07/14/AQS1/)","source":"_posts/2020/07/CountDownLatch1.md","raw":"---\ntitle: CountDownLatch(jdk1.8)\ndate: 2020-07-13 22:09:40\ntags:\n- JUC\ncategories:\n- Java\n- JUC\n---\n\n### 前言\n\n  本章对CountDownLatch的原理及应用场景总结一下。\n<!-- more -->\n\n### 源码解读\n\n#### 内部类Sync\n\n{% codeblock lang:java %}\n// 继承了AQS的内部类，使用AQS的state作为计数\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 4982264981922014374L;\n    Sync(int count) {\n        setState(count);\n    }\n    int getCount() {\n        return getState();\n    }\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n    // countDown操作\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            // 使用CAS更新state\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n{% endcodeblock %}\n\n#### 操作方法\n\n{% codeblock lang:java %}\n// 构造方法，初始化count，可以调用await()使之休眠直到count归零\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException(\"count < 0\");\n    this.sync = new Sync(count);\n}\n\n// 使当前线程等待，直到计数count归零才会唤醒\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n// 使当前线程等待，直到计数count归零 或 等待时间==timeout\npublic boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException {\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n}\n\n// 计数器递减\n// count>0 -1 若-1操作的结果为零则唤醒所有等待线程\n// count==0 不做操作\npublic void countDown() {\n    sync.releaseShared(1);\n}\n{% endcodeblock %}\n\n#### 调用的AQS方法\n{% codeblock lang:java %}\n// 等待阻塞\npublic final void acquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // tryAcquireShared(arg)走Sync重写的逻辑判断计数\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n\n// 释放\npublic final boolean releaseShared(int arg) {\n    // 这里的tryReleaseShared(arg)走的使Sync重写的逻辑\n    if (tryReleaseShared(arg)) {\n        // 确认释放，走AQS的释放方法\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n{% endcodeblock %}\n\n  从源码中可以看到，CountDownLatch的实现依赖于继承了AQS的内部类Sync。\n  他的操作方法不错，主要就是初始化定义计数阈值，然后通过await()方法阻塞线程直到计数归零，同归countDown()递减控制计数。\n\n### 使用示例\n\n{% codeblock lang:java %}\npublic void mian(String[] args){\n    CountDownLatch masterFlag = new CountDownLatch(1);\n    CountDownLatch slaveFlag = new CountDownLatch(3);\n    new Thread(() -> {\n        try {\n            masterFlag.await(1, TimeUnit.MILLISECONDS);\n            logger.info(\"thread run not waiting：{}\", Thread.currentThread().getName());\n            slaveFlag.countDown();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }).start();\n    for (int i = 0; i < 2; i++) {\n        new Thread(() -> {\n            try {\n                masterFlag.await();\n                logger.info(\"start sleep:{}\", Thread.currentThread().getName());\n                Thread.sleep(10000);\n                logger.info(\"thread run：{}\", Thread.currentThread().getName());\n                slaveFlag.countDown();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n    }\n    Thread.sleep(10000);\n    masterFlag.countDown();\n    logger.info(\"master countDown\");\n    slaveFlag.await();\n    logger.info(\"slave countDown finish\");\n}\n{% endcodeblock %}\n\n  输出结果\n\n{% img /image/CountDownLatch/CountDownLatch1.png '\"示例结果\"'%}\n\n  从结果可以看到，Thread-4因为使用的是*await(long, timeUnit)* 方法，其等待时间比较短，所以在主线程休眠时就会被唤醒。\n  而其他线程都是等到主线程休眠计数将*masterFlag* 计数归零后才被唤醒。\n\n### 小结\n\n      总的来看CountDownLatch其实很好理解，借助AQS实现一个计数器，以达到控制线程等待唤醒的目\n    的。不过想要理解他的底层实现原理就得了解AQS的实现了，关于AQS的内容就不在本章赘述。\n      在实际应用中，CountDownLatch应该是控制一批线程相互等待并让其同时被唤醒这种场景。例如批\n    量下载，要求全部下载完之后发送一个成功的提醒。\n\n> [浅析AQS(jdk1.8)](https://rel-fly.com/2020/07/14/AQS1/)","slug":"CountDownLatch1","published":1,"updated":"2020-08-15T12:34:05.005Z","_id":"ckdvmudyr001vnwb510h44ul6","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章对CountDownLatch的原理及应用场景总结一下。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"源码解读\"><a href=\"#源码解读\" class=\"headerlink\" title=\"源码解读\"></a>源码解读</h3><h4 id=\"内部类Sync\"><a href=\"#内部类Sync\" class=\"headerlink\" title=\"内部类Sync\"></a>内部类Sync</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承了AQS的内部类，使用AQS的state作为计数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">4982264981922014374L</span>;</span><br><span class=\"line\">    Sync(<span class=\"keyword\">int</span> count) &#123;</span><br><span class=\"line\">        setState(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getState() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// countDown操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Decrement count; signal when transition to zero</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 使用CAS更新state</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextc == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造方法，初始化count，可以调用await()使之休眠直到count归零</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"count &lt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sync = <span class=\"keyword\">new</span> Sync(count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使当前线程等待，直到计数count归零才会唤醒</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使当前线程等待，直到计数count归零 或 等待时间==timeout</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.tryAcquireSharedNanos(<span class=\"number\">1</span>, unit.toNanos(timeout));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计数器递减</span></span><br><span class=\"line\"><span class=\"comment\">// count&gt;0 -1 若-1操作的结果为零则唤醒所有等待线程</span></span><br><span class=\"line\"><span class=\"comment\">// count==0 不做操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调用的AQS方法\"><a href=\"#调用的AQS方法\" class=\"headerlink\" title=\"调用的AQS方法\"></a>调用的AQS方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 等待阻塞</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireSharedInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">// tryAcquireShared(arg)走Sync重写的逻辑判断计数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的tryReleaseShared(arg)走的使Sync重写的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 确认释放，走AQS的释放方法</span></span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  从源码中可以看到，CountDownLatch的实现依赖于继承了AQS的内部类Sync。<br>  他的操作方法不错，主要就是初始化定义计数阈值，然后通过await()方法阻塞线程直到计数归零，同归countDown()递减控制计数。</p>\n<h3 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mian</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    CountDownLatch masterFlag = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    CountDownLatch slaveFlag = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            masterFlag.await(<span class=\"number\">1</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"thread run not waiting：&#123;&#125;\"</span>, Thread.currentThread().getName());</span><br><span class=\"line\">            slaveFlag.countDown();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                masterFlag.await();</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"start sleep:&#123;&#125;\"</span>, Thread.currentThread().getName());</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"thread run：&#123;&#125;\"</span>, Thread.currentThread().getName());</span><br><span class=\"line\">                slaveFlag.countDown();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">    masterFlag.countDown();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"master countDown\"</span>);</span><br><span class=\"line\">    slaveFlag.await();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"slave countDown finish\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  输出结果</p>\n<img src=\"/image/CountDownLatch/CountDownLatch1.png\" class=\"\" title=\"示例结果\">\n\n<p>  从结果可以看到，Thread-4因为使用的是<em>await(long, timeUnit)</em> 方法，其等待时间比较短，所以在主线程休眠时就会被唤醒。<br>  而其他线程都是等到主线程休眠计数将<em>masterFlag</em> 计数归零后才被唤醒。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  总的来看CountDownLatch其实很好理解，借助AQS实现一个计数器，以达到控制线程等待唤醒的目\n的。不过想要理解他的底层实现原理就得了解AQS的实现了，关于AQS的内容就不在本章赘述。\n  在实际应用中，CountDownLatch应该是控制一批线程相互等待并让其同时被唤醒这种场景。例如批\n量下载，要求全部下载完之后发送一个成功的提醒。</code></pre><blockquote>\n<p><a href=\"https://rel-fly.com/2020/07/14/AQS1/\">浅析AQS(jdk1.8)</a></p>\n</blockquote>\n","site":{"data":{}},"length":463,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章对CountDownLatch的原理及应用场景总结一下。</p>","more":"<h3 id=\"源码解读\"><a href=\"#源码解读\" class=\"headerlink\" title=\"源码解读\"></a>源码解读</h3><h4 id=\"内部类Sync\"><a href=\"#内部类Sync\" class=\"headerlink\" title=\"内部类Sync\"></a>内部类Sync</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 继承了AQS的内部类，使用AQS的state作为计数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">4982264981922014374L</span>;</span><br><span class=\"line\">    Sync(<span class=\"keyword\">int</span> count) &#123;</span><br><span class=\"line\">        setState(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getState() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// countDown操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Decrement count; signal when transition to zero</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 使用CAS更新state</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextc == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造方法，初始化count，可以调用await()使之休眠直到count归零</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"count &lt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sync = <span class=\"keyword\">new</span> Sync(count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使当前线程等待，直到计数count归零才会唤醒</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使当前线程等待，直到计数count归零 或 等待时间==timeout</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">await</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.tryAcquireSharedNanos(<span class=\"number\">1</span>, unit.toNanos(timeout));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 计数器递减</span></span><br><span class=\"line\"><span class=\"comment\">// count&gt;0 -1 若-1操作的结果为零则唤醒所有等待线程</span></span><br><span class=\"line\"><span class=\"comment\">// count==0 不做操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"调用的AQS方法\"><a href=\"#调用的AQS方法\" class=\"headerlink\" title=\"调用的AQS方法\"></a>调用的AQS方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 等待阻塞</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireSharedInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">// tryAcquireShared(arg)走Sync重写的逻辑判断计数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里的tryReleaseShared(arg)走的使Sync重写的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 确认释放，走AQS的释放方法</span></span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  从源码中可以看到，CountDownLatch的实现依赖于继承了AQS的内部类Sync。<br>  他的操作方法不错，主要就是初始化定义计数阈值，然后通过await()方法阻塞线程直到计数归零，同归countDown()递减控制计数。</p>\n<h3 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">mian</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    CountDownLatch masterFlag = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">1</span>);</span><br><span class=\"line\">    CountDownLatch slaveFlag = <span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            masterFlag.await(<span class=\"number\">1</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"thread run not waiting：&#123;&#125;\"</span>, Thread.currentThread().getName());</span><br><span class=\"line\">            slaveFlag.countDown();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;).start();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                masterFlag.await();</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"start sleep:&#123;&#125;\"</span>, Thread.currentThread().getName());</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"thread run：&#123;&#125;\"</span>, Thread.currentThread().getName());</span><br><span class=\"line\">                slaveFlag.countDown();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">    masterFlag.countDown();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"master countDown\"</span>);</span><br><span class=\"line\">    slaveFlag.await();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"slave countDown finish\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  输出结果</p>\n<img src=\"/image/CountDownLatch/CountDownLatch1.png\" class=\"\" title=\"示例结果\">\n\n<p>  从结果可以看到，Thread-4因为使用的是<em>await(long, timeUnit)</em> 方法，其等待时间比较短，所以在主线程休眠时就会被唤醒。<br>  而其他线程都是等到主线程休眠计数将<em>masterFlag</em> 计数归零后才被唤醒。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  总的来看CountDownLatch其实很好理解，借助AQS实现一个计数器，以达到控制线程等待唤醒的目\n的。不过想要理解他的底层实现原理就得了解AQS的实现了，关于AQS的内容就不在本章赘述。\n  在实际应用中，CountDownLatch应该是控制一批线程相互等待并让其同时被唤醒这种场景。例如批\n量下载，要求全部下载完之后发送一个成功的提醒。</code></pre><blockquote>\n<p><a href=\"https://rel-fly.com/2020/07/14/AQS1/\">浅析AQS(jdk1.8)</a></p>\n</blockquote>"},{"title":"跳跃链表","date":"2020-07-21T06:14:55.000Z","_content":"\n### 前言\n\n  最近有被问到redis中zset类型的数据结构--跳表，所以本章就跳表的原理及redis中的实现做一个总结。\n<!-- more -->\n\n### 跳表原理\n\n  跳表的结构很简单，就是在一个链表的基础上，建立n层索引层。\n{% img  /image/skiplist/skiplist1.png  '\"跳表结构\"' %}\n\n  如上图所示，借助索引层，可以使得查询按照类似二分查找的方式更快定位目标节点的位置，而不必遍历整个链表。\n  也因此，跳表中是不允许重复的值的。\n\n\n### 实现方式\n\n  跳表可以理解为几层链表，只不过一层比一层\"稀疏\"。实现跳表一个关键点在于确定节点的层数。\n\n{% codeblock lang:java %}\n// 采用随机的方式确定每一个节点的层数\npublic int randomLevel() {\n    int level = 1;\n    int p = 5;\n    while (r.nextInt(10) < p && level < MAX_LEVEL) {\n        level++;\n    }\n    return level;\n}\n{% endcodeblock %}\n\n#### 类定义\n\n{% codeblock lang:java %}\n// 跳表节点类\npublic class SkipListNode {\n    // 下一个节点\n    private SkipListNode next;\n    // 下一层节点\n    private SkipListNode down;\n    // 节点所在层数\n    private int level;\n    // 值\n    private Integer value;\n\n    public SkipListNode(int level, Integer value) {\n        this.level = level;\n        this.value = value;\n    }\n\n    public SkipListNode(Integer value) {\n        this.value = value;\n    }\n}\n{% endcodeblock %}\n\n   这里实现跳表是定义了每一个节点(相同值不同层当作不同节点)，通过节点的next指针和down指针操作。\n\n{% codeblock lang:java %}\n// 跳表定义\npublic class SkipList {\n    // 最大层数，对层数随机的限制\n    private static final int MAX_LEVEL = 16;\n    // 头节点，是一个虚节点，无实际值\n    private SkipListNode head;\n    // 跳表长度，实际值的数量，不包括索引节点\n    private int size;\n    // 当前跳表最大的层数\n    private int maxLevel;\n    // 用来随机层数\n    private Random r = new Random();\n\n    // 构造方法，初始化头节点\n    public SkipList() {\n        this.head = new SkipListNode(1, 0);\n        this.head.setNext(null);\n        this.head.setDown(null);\n        this.size = 0;\n        this.maxLevel = 1;\n    }\n{% endcodeblock %}\n\n#### 基本操作\n\n{% codeblock lang:java %}\n// 新增操作\npublic void insert(Integer value) {\n    // 校验，不让插重复值\n    if (find(value)) {\n        System.out.println(\"值已存在\");\n        return;\n    }\n    // 1. 随机计算新节点层次\n    int currentMaxLevel = randomLevel();\n    // 2. 遍历每一层插入节点\n    // 2.1 判断当前最大层次是否满足\n    if (currentMaxLevel > maxLevel) {\n        for (; maxLevel < currentMaxLevel; maxLevel++) {\n            SkipListNode newHead = new SkipListNode(maxLevel + 1, null);\n            newHead.setDown(head);\n            head = newHead;\n        }\n    }\n    // 2.2 取头节点作为游标\n    SkipListNode cursorHeadNode = head;\n    // 2.3 新建节点\n    SkipListNode newNode = new SkipListNode(maxLevel, value);\n    // 2.4 循环处理\n    for (int i = maxLevel; i > 0; i--) {\n        SkipListNode cursorNode = cursorHeadNode.getNext();\n        // 当前层次大于新建节点最大层次，下降一层并跳过\n        if (i > currentMaxLevel) {\n            cursorHeadNode = cursorHeadNode.getDown();\n            continue;\n        }\n        // 当前层次遍历\n        while (true) {\n            // 头节点的下一节点为空\n            if (cursorNode == null) {\n                cursorHeadNode.setNext(newNode);\n                break;\n            }\n            // 第一个节点值比新增值大\n            if (cursorNode.getValue() > value) {\n                cursorHeadNode.setNext(newNode);\n                newNode.setNext(cursorNode);\n                break;\n            }\n            if (cursorNode.getValue() < value) {\n                if (cursorNode.getNext() == null) {\n                    // 跟在最后一个节点后面\n                    cursorNode.setNext(newNode);\n                    break;\n                }\n                if (cursorNode.getNext().getValue() > value) {\n                    // 插入两者中间\n                    newNode.setNext(cursorNode.getNext());\n                    cursorNode.setNext(newNode);\n                    break;\n                }\n            }\n            // 移动到下一节点\n            if (cursorNode.getNext().getValue() < value) {\n                cursorNode = cursorNode.getNext();\n            }\n        }\n        cursorHeadNode = cursorHeadNode.getDown();\n        // 设置新节点的下一节点\n        SkipListNode nextNewNode = new SkipListNode(i - 1, value);\n        newNode.setDown(nextNewNode);\n        newNode = nextNewNode;\n        if (i == 1) {\n            size++;\n        }\n    }\n}\n\n// 查询\npublic boolean find(Integer value) {\n    // 游标节点\n    SkipListNode cursorNode = head;\n    while (true) {\n        // 游标为null，终止遍历\n        if (cursorNode == null) {\n            return false;\n        }\n        // 头节点为虚节点，所以取下一节点为当前节点与入参做比较\n        // 或 已经比较过的节点作为游标，所以也是取他的下一节点做比较\n        SkipListNode currentNode = cursorNode.getNext();\n        if (currentNode == null) {\n            cursorNode = cursorNode.getDown();\n            continue;\n        }\n        // 比较当前节点与入参的值\n        if (currentNode.getValue().equals(value)) {\n            return true;\n        }\n        if (currentNode.getValue() > value) {\n            // 当前节点大，游标移动到下一层\n            cursorNode = cursorNode.getDown();\n            continue;\n        }\n        if (currentNode.getValue() < value) {\n            // 当前节点小，下一节点为空，则移动到下一层\n            if (currentNode.getNext() == null) {\n                cursorNode = currentNode.getDown();\n                continue;\n            }\n            // 当前节点小，下一节点不为空但比入参大，移动到下一层\n            if (currentNode.getNext().getValue() > value) {\n                cursorNode = currentNode.getDown();\n                continue;\n            }\n            // 当前节点小，下一节点不为空且也比入参小，游标移动到下一节点\n            if (currentNode.getNext().getValue() < value) {\n                cursorNode = currentNode.getNext();\n                continue;\n            }\n        }\n    }\n}\n{% endcodeblock %}\n\n  以一个个节点实现跳表逻辑的时候发现相比用数组维护同一值的结构，操作要复杂一些。因为会涉及节点的比较及右移，下移。\n\n#### 测试\n{% codeblock lang:java %}\n public void skipListTest() {\n    SkipList list = new SkipList();\n    list.insert(1);\n    list.insert(5);\n    list.insert(9);\n    list.insert(12);\n    list.insert(3);\n    list.insert(34);\n    list.insert(20);\n    list.insert(11);\n    list.insert(6);\n    list.insert(8);\n    list.insert(2);\n    list.insert(4);\n    list.insert(33);\n    list.insert(21);\n    list.insert(19);\n    list.insert(25);\n    list.insert(72);\n    list.insert(13);\n    list.insert(15);\n    list.insert(7);\n    list.insert(32);\n    logger.info(\"size;{}\", list.getSize());\n    list.showData();\n}\n{% endcodeblock%}\n\n{% img  /image/skiplist/skiplist2.png  '\"测试结果\"' %}\n\n  测试发现，因为每个新节点的层数都是按照随机的方式决定，那么有可能会导致索引层的不合理。\n\n\n### redis实现\n\n  先来看看redis的节点定义\n\n{% codeblock lang:java %}\ntypedef struct zskiplistNode {\n    // 成员对象\n    robj *obj;\n    // 分值\n    double score;\n    // 后退指针\n    struct zskiplistNode *backward;\n    // 层\n    struct zskiplistLevel {\n        // 前进指针\n        struct zskiplistNode *forward;\n        // 跨度\n        unsigned int span;\n    } level[];\n} zskiplistNode;\n{% endcodeblock %}\n  redis的节点定义与上述例子不同，他是在节点内用数组维护了对应层的下一节点。\n  借用这种思想用Java实现的话：\n{% codeblock lang:java %}\n// 节点类\npublic class SkipListNode2 {\n\n    private Integer value;\n\n    private Integer level;\n    /**\n     * 对应每一层的下一节点\n     */\n    private SkipListNode2[] nextNodes;\n\n    public SkipListNode2(int level) {\n        this.value = -1;\n        this.level = level;\n        this.nextNodes = new SkipListNode2[level];\n    }\n\n    public Integer getValue() {\n        return value;\n    }\n\n    public void setValue(Integer value) {\n        this.value = value;\n    }\n\n    public Integer getLevel() {\n        return level;\n    }\n\n    public void setLevel(Integer level) {\n        this.level = level;\n    }\n\n    public SkipListNode2[] getNextNodes() {\n        return nextNodes;\n    }\n\n    public void setNextNodes(SkipListNode2[] nextNodes) {\n        this.nextNodes = nextNodes;\n    }\n}\n{% endcodeblock %}\n  \n{% codeblock lang:java %}\n// 跳表类\npublic class SkipList2 {\n    private static final Logger logger = LoggerFactory.getLogger(SkipList2.class);\n\n    private static final int MAX_LEVEL = 16;\n\n    private Random r = new Random();\n\n    private int levelCount;\n\n    /**\n     * 头节点\n     */\n    private SkipListNode2 head;\n\n    public SkipList2() {\n        this.levelCount = 1;\n        this.head = new SkipListNode2(MAX_LEVEL);\n    }\n\n    /**\n     * 插入节点\n     *\n     * @param value\n     */\n    public void insert(Integer value) {\n        if (find(value) != null) {\n            logger.info(\"值已存在\");\n            return;\n        }\n        int level = randomLevel();\n        SkipListNode2 newNode = new SkipListNode2(level);\n        newNode.setLevel(level);\n        newNode.setValue(value);\n        SkipListNode2[] newNextNodes = new SkipListNode2[level];\n        newNode.setNextNodes(newNextNodes);\n        // 游标节点\n        SkipListNode2 cursorNode = head;\n        for (int i = level - 1; i >= 0; i--) {\n            // 比较下一节点与入参值，若小于入参值则向后移动\n            while (cursorNode.getNextNodes()[i] != null\n                    && cursorNode.getNextNodes()[i].getValue() < value) {\n                cursorNode = cursorNode.getNextNodes()[i];\n            }\n            // 遍历到大于入参值的节点，置为新节点当前层的下一节点\n            newNextNodes[i] = cursorNode.getNextNodes()[i];\n            cursorNode.getNextNodes()[i] = newNode;\n        }\n        if (level > levelCount) {\n            levelCount = level;\n        }\n    }\n\n    /**\n     * 搜索\n     *\n     * @param value\n     * @return\n     */\n    private SkipListNode2 find(Integer value) {\n        // 游标节点\n        SkipListNode2 cursorNode = head;\n        for (int i = levelCount - 1; i >= 0; i--) {\n            // 比较下一节点与入参值，若小于入参值则向后移动\n            while (cursorNode.getNextNodes()[i] != null\n                    && cursorNode.getNextNodes()[i].getValue() < value) {\n                cursorNode = cursorNode.getNextNodes()[i];\n            }\n        }\n        if (cursorNode.getNextNodes()[0] != null\n                && cursorNode.getNextNodes()[0].getValue().equals(value)) {\n            return cursorNode;\n        } else {\n            return null;\n        }\n    }\n\n    public void showData() {\n        SkipListNode2 cursorNode = head;\n        for (int i = levelCount - 1; i >= 0; i--) {\n            // 比较下一节点与入参值，若小于入参值则向后移动\n            while (cursorNode.getNextNodes()[i] != null) {\n                System.out.print(cursorNode.getNextNodes()[i].getValue() + \",\");\n                cursorNode = cursorNode.getNextNodes()[i];\n            }\n            cursorNode = head;\n            System.out.println();\n        }\n    }\n\n    /**\n     * 随机计算节点最大层次\n     *\n     * @return\n     */\n    public int randomLevel() {\n        int level = 1;\n        int p = 5;\n        while (r.nextInt(10) < p && level < MAX_LEVEL) {\n            level++;\n        }\n        return level;\n    }\n}\n{% endcodeblock %}\n\n  这种思路明显要比单一节点的实现更加方便，数组存放了下一节点指针，而不同的下标又表示了不同层的下一节点指针，替代了next和down指针的作用。\n\n### 小结\n\n      redis用跳表实现zset类型要比上面实现的例子考虑的更多(像节点维护的跨度信息，及zset权重分数\n    的维护等)，不过本章只探讨跳表的实现思路，所以就不详细探讨这方面了。\n      关于跳表的实现我一开始想的是用一个一个节点去描述跳表结构，看了redis的节点定义及网上的一些\n    示例，才理解用数组去描述的思路。用数组实现的代码看起来有点绕，但是理解了就会觉得很简单，不用\n    像节点那样频繁的转移。数组使得遍历操作变得更加直接。\n","source":"_posts/2020/07/skipList1.md","raw":"---\ntitle: 跳跃链表\ndate: 2020-07-21 14:14:55\ntags:\n- 数据结构\ncategories:\n- 数据结构\n- 链表\n---\n\n### 前言\n\n  最近有被问到redis中zset类型的数据结构--跳表，所以本章就跳表的原理及redis中的实现做一个总结。\n<!-- more -->\n\n### 跳表原理\n\n  跳表的结构很简单，就是在一个链表的基础上，建立n层索引层。\n{% img  /image/skiplist/skiplist1.png  '\"跳表结构\"' %}\n\n  如上图所示，借助索引层，可以使得查询按照类似二分查找的方式更快定位目标节点的位置，而不必遍历整个链表。\n  也因此，跳表中是不允许重复的值的。\n\n\n### 实现方式\n\n  跳表可以理解为几层链表，只不过一层比一层\"稀疏\"。实现跳表一个关键点在于确定节点的层数。\n\n{% codeblock lang:java %}\n// 采用随机的方式确定每一个节点的层数\npublic int randomLevel() {\n    int level = 1;\n    int p = 5;\n    while (r.nextInt(10) < p && level < MAX_LEVEL) {\n        level++;\n    }\n    return level;\n}\n{% endcodeblock %}\n\n#### 类定义\n\n{% codeblock lang:java %}\n// 跳表节点类\npublic class SkipListNode {\n    // 下一个节点\n    private SkipListNode next;\n    // 下一层节点\n    private SkipListNode down;\n    // 节点所在层数\n    private int level;\n    // 值\n    private Integer value;\n\n    public SkipListNode(int level, Integer value) {\n        this.level = level;\n        this.value = value;\n    }\n\n    public SkipListNode(Integer value) {\n        this.value = value;\n    }\n}\n{% endcodeblock %}\n\n   这里实现跳表是定义了每一个节点(相同值不同层当作不同节点)，通过节点的next指针和down指针操作。\n\n{% codeblock lang:java %}\n// 跳表定义\npublic class SkipList {\n    // 最大层数，对层数随机的限制\n    private static final int MAX_LEVEL = 16;\n    // 头节点，是一个虚节点，无实际值\n    private SkipListNode head;\n    // 跳表长度，实际值的数量，不包括索引节点\n    private int size;\n    // 当前跳表最大的层数\n    private int maxLevel;\n    // 用来随机层数\n    private Random r = new Random();\n\n    // 构造方法，初始化头节点\n    public SkipList() {\n        this.head = new SkipListNode(1, 0);\n        this.head.setNext(null);\n        this.head.setDown(null);\n        this.size = 0;\n        this.maxLevel = 1;\n    }\n{% endcodeblock %}\n\n#### 基本操作\n\n{% codeblock lang:java %}\n// 新增操作\npublic void insert(Integer value) {\n    // 校验，不让插重复值\n    if (find(value)) {\n        System.out.println(\"值已存在\");\n        return;\n    }\n    // 1. 随机计算新节点层次\n    int currentMaxLevel = randomLevel();\n    // 2. 遍历每一层插入节点\n    // 2.1 判断当前最大层次是否满足\n    if (currentMaxLevel > maxLevel) {\n        for (; maxLevel < currentMaxLevel; maxLevel++) {\n            SkipListNode newHead = new SkipListNode(maxLevel + 1, null);\n            newHead.setDown(head);\n            head = newHead;\n        }\n    }\n    // 2.2 取头节点作为游标\n    SkipListNode cursorHeadNode = head;\n    // 2.3 新建节点\n    SkipListNode newNode = new SkipListNode(maxLevel, value);\n    // 2.4 循环处理\n    for (int i = maxLevel; i > 0; i--) {\n        SkipListNode cursorNode = cursorHeadNode.getNext();\n        // 当前层次大于新建节点最大层次，下降一层并跳过\n        if (i > currentMaxLevel) {\n            cursorHeadNode = cursorHeadNode.getDown();\n            continue;\n        }\n        // 当前层次遍历\n        while (true) {\n            // 头节点的下一节点为空\n            if (cursorNode == null) {\n                cursorHeadNode.setNext(newNode);\n                break;\n            }\n            // 第一个节点值比新增值大\n            if (cursorNode.getValue() > value) {\n                cursorHeadNode.setNext(newNode);\n                newNode.setNext(cursorNode);\n                break;\n            }\n            if (cursorNode.getValue() < value) {\n                if (cursorNode.getNext() == null) {\n                    // 跟在最后一个节点后面\n                    cursorNode.setNext(newNode);\n                    break;\n                }\n                if (cursorNode.getNext().getValue() > value) {\n                    // 插入两者中间\n                    newNode.setNext(cursorNode.getNext());\n                    cursorNode.setNext(newNode);\n                    break;\n                }\n            }\n            // 移动到下一节点\n            if (cursorNode.getNext().getValue() < value) {\n                cursorNode = cursorNode.getNext();\n            }\n        }\n        cursorHeadNode = cursorHeadNode.getDown();\n        // 设置新节点的下一节点\n        SkipListNode nextNewNode = new SkipListNode(i - 1, value);\n        newNode.setDown(nextNewNode);\n        newNode = nextNewNode;\n        if (i == 1) {\n            size++;\n        }\n    }\n}\n\n// 查询\npublic boolean find(Integer value) {\n    // 游标节点\n    SkipListNode cursorNode = head;\n    while (true) {\n        // 游标为null，终止遍历\n        if (cursorNode == null) {\n            return false;\n        }\n        // 头节点为虚节点，所以取下一节点为当前节点与入参做比较\n        // 或 已经比较过的节点作为游标，所以也是取他的下一节点做比较\n        SkipListNode currentNode = cursorNode.getNext();\n        if (currentNode == null) {\n            cursorNode = cursorNode.getDown();\n            continue;\n        }\n        // 比较当前节点与入参的值\n        if (currentNode.getValue().equals(value)) {\n            return true;\n        }\n        if (currentNode.getValue() > value) {\n            // 当前节点大，游标移动到下一层\n            cursorNode = cursorNode.getDown();\n            continue;\n        }\n        if (currentNode.getValue() < value) {\n            // 当前节点小，下一节点为空，则移动到下一层\n            if (currentNode.getNext() == null) {\n                cursorNode = currentNode.getDown();\n                continue;\n            }\n            // 当前节点小，下一节点不为空但比入参大，移动到下一层\n            if (currentNode.getNext().getValue() > value) {\n                cursorNode = currentNode.getDown();\n                continue;\n            }\n            // 当前节点小，下一节点不为空且也比入参小，游标移动到下一节点\n            if (currentNode.getNext().getValue() < value) {\n                cursorNode = currentNode.getNext();\n                continue;\n            }\n        }\n    }\n}\n{% endcodeblock %}\n\n  以一个个节点实现跳表逻辑的时候发现相比用数组维护同一值的结构，操作要复杂一些。因为会涉及节点的比较及右移，下移。\n\n#### 测试\n{% codeblock lang:java %}\n public void skipListTest() {\n    SkipList list = new SkipList();\n    list.insert(1);\n    list.insert(5);\n    list.insert(9);\n    list.insert(12);\n    list.insert(3);\n    list.insert(34);\n    list.insert(20);\n    list.insert(11);\n    list.insert(6);\n    list.insert(8);\n    list.insert(2);\n    list.insert(4);\n    list.insert(33);\n    list.insert(21);\n    list.insert(19);\n    list.insert(25);\n    list.insert(72);\n    list.insert(13);\n    list.insert(15);\n    list.insert(7);\n    list.insert(32);\n    logger.info(\"size;{}\", list.getSize());\n    list.showData();\n}\n{% endcodeblock%}\n\n{% img  /image/skiplist/skiplist2.png  '\"测试结果\"' %}\n\n  测试发现，因为每个新节点的层数都是按照随机的方式决定，那么有可能会导致索引层的不合理。\n\n\n### redis实现\n\n  先来看看redis的节点定义\n\n{% codeblock lang:java %}\ntypedef struct zskiplistNode {\n    // 成员对象\n    robj *obj;\n    // 分值\n    double score;\n    // 后退指针\n    struct zskiplistNode *backward;\n    // 层\n    struct zskiplistLevel {\n        // 前进指针\n        struct zskiplistNode *forward;\n        // 跨度\n        unsigned int span;\n    } level[];\n} zskiplistNode;\n{% endcodeblock %}\n  redis的节点定义与上述例子不同，他是在节点内用数组维护了对应层的下一节点。\n  借用这种思想用Java实现的话：\n{% codeblock lang:java %}\n// 节点类\npublic class SkipListNode2 {\n\n    private Integer value;\n\n    private Integer level;\n    /**\n     * 对应每一层的下一节点\n     */\n    private SkipListNode2[] nextNodes;\n\n    public SkipListNode2(int level) {\n        this.value = -1;\n        this.level = level;\n        this.nextNodes = new SkipListNode2[level];\n    }\n\n    public Integer getValue() {\n        return value;\n    }\n\n    public void setValue(Integer value) {\n        this.value = value;\n    }\n\n    public Integer getLevel() {\n        return level;\n    }\n\n    public void setLevel(Integer level) {\n        this.level = level;\n    }\n\n    public SkipListNode2[] getNextNodes() {\n        return nextNodes;\n    }\n\n    public void setNextNodes(SkipListNode2[] nextNodes) {\n        this.nextNodes = nextNodes;\n    }\n}\n{% endcodeblock %}\n  \n{% codeblock lang:java %}\n// 跳表类\npublic class SkipList2 {\n    private static final Logger logger = LoggerFactory.getLogger(SkipList2.class);\n\n    private static final int MAX_LEVEL = 16;\n\n    private Random r = new Random();\n\n    private int levelCount;\n\n    /**\n     * 头节点\n     */\n    private SkipListNode2 head;\n\n    public SkipList2() {\n        this.levelCount = 1;\n        this.head = new SkipListNode2(MAX_LEVEL);\n    }\n\n    /**\n     * 插入节点\n     *\n     * @param value\n     */\n    public void insert(Integer value) {\n        if (find(value) != null) {\n            logger.info(\"值已存在\");\n            return;\n        }\n        int level = randomLevel();\n        SkipListNode2 newNode = new SkipListNode2(level);\n        newNode.setLevel(level);\n        newNode.setValue(value);\n        SkipListNode2[] newNextNodes = new SkipListNode2[level];\n        newNode.setNextNodes(newNextNodes);\n        // 游标节点\n        SkipListNode2 cursorNode = head;\n        for (int i = level - 1; i >= 0; i--) {\n            // 比较下一节点与入参值，若小于入参值则向后移动\n            while (cursorNode.getNextNodes()[i] != null\n                    && cursorNode.getNextNodes()[i].getValue() < value) {\n                cursorNode = cursorNode.getNextNodes()[i];\n            }\n            // 遍历到大于入参值的节点，置为新节点当前层的下一节点\n            newNextNodes[i] = cursorNode.getNextNodes()[i];\n            cursorNode.getNextNodes()[i] = newNode;\n        }\n        if (level > levelCount) {\n            levelCount = level;\n        }\n    }\n\n    /**\n     * 搜索\n     *\n     * @param value\n     * @return\n     */\n    private SkipListNode2 find(Integer value) {\n        // 游标节点\n        SkipListNode2 cursorNode = head;\n        for (int i = levelCount - 1; i >= 0; i--) {\n            // 比较下一节点与入参值，若小于入参值则向后移动\n            while (cursorNode.getNextNodes()[i] != null\n                    && cursorNode.getNextNodes()[i].getValue() < value) {\n                cursorNode = cursorNode.getNextNodes()[i];\n            }\n        }\n        if (cursorNode.getNextNodes()[0] != null\n                && cursorNode.getNextNodes()[0].getValue().equals(value)) {\n            return cursorNode;\n        } else {\n            return null;\n        }\n    }\n\n    public void showData() {\n        SkipListNode2 cursorNode = head;\n        for (int i = levelCount - 1; i >= 0; i--) {\n            // 比较下一节点与入参值，若小于入参值则向后移动\n            while (cursorNode.getNextNodes()[i] != null) {\n                System.out.print(cursorNode.getNextNodes()[i].getValue() + \",\");\n                cursorNode = cursorNode.getNextNodes()[i];\n            }\n            cursorNode = head;\n            System.out.println();\n        }\n    }\n\n    /**\n     * 随机计算节点最大层次\n     *\n     * @return\n     */\n    public int randomLevel() {\n        int level = 1;\n        int p = 5;\n        while (r.nextInt(10) < p && level < MAX_LEVEL) {\n            level++;\n        }\n        return level;\n    }\n}\n{% endcodeblock %}\n\n  这种思路明显要比单一节点的实现更加方便，数组存放了下一节点指针，而不同的下标又表示了不同层的下一节点指针，替代了next和down指针的作用。\n\n### 小结\n\n      redis用跳表实现zset类型要比上面实现的例子考虑的更多(像节点维护的跨度信息，及zset权重分数\n    的维护等)，不过本章只探讨跳表的实现思路，所以就不详细探讨这方面了。\n      关于跳表的实现我一开始想的是用一个一个节点去描述跳表结构，看了redis的节点定义及网上的一些\n    示例，才理解用数组去描述的思路。用数组实现的代码看起来有点绕，但是理解了就会觉得很简单，不用\n    像节点那样频繁的转移。数组使得遍历操作变得更加直接。\n","slug":"skipList1","published":1,"updated":"2021-05-05T05:55:28.019Z","_id":"ckdvmudys001ynwb57oj59j7u","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  最近有被问到redis中zset类型的数据结构–跳表，所以本章就跳表的原理及redis中的实现做一个总结。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"跳表原理\"><a href=\"#跳表原理\" class=\"headerlink\" title=\"跳表原理\"></a>跳表原理</h3><p>  跳表的结构很简单，就是在一个链表的基础上，建立n层索引层。</p>\n<img src=\"/image/skiplist/skiplist1.png\" class=\"\" title=\"跳表结构\">\n\n<p>  如上图所示，借助索引层，可以使得查询按照类似二分查找的方式更快定位目标节点的位置，而不必遍历整个链表。<br>  也因此，跳表中是不允许重复的值的。</p>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><p>  跳表可以理解为几层链表，只不过一层比一层”稀疏”。实现跳表一个关键点在于确定节点的层数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用随机的方式确定每一个节点的层数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">randomLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (r.nextInt(<span class=\"number\">10</span>) &lt; p &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class=\"line\">        level++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"类定义\"><a href=\"#类定义\" class=\"headerlink\" title=\"类定义\"></a>类定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 跳表节点类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SkipListNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode next;</span><br><span class=\"line\">    <span class=\"comment\">// 下一层节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode down;</span><br><span class=\"line\">    <span class=\"comment\">// 节点所在层数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipListNode</span><span class=\"params\">(<span class=\"keyword\">int</span> level, Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipListNode</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   这里实现跳表是定义了每一个节点(相同值不同层当作不同节点)，通过节点的next指针和down指针操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 跳表定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SkipList</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最大层数，对层数随机的限制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_LEVEL = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 头节点，是一个虚节点，无实际值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode head;</span><br><span class=\"line\">    <span class=\"comment\">// 跳表长度，实际值的数量，不包括索引节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 当前跳表最大的层数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxLevel;</span><br><span class=\"line\">    <span class=\"comment\">// 用来随机层数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造方法，初始化头节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head = <span class=\"keyword\">new</span> SkipListNode(<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head.setNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head.setDown(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxLevel = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新增操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 校验，不让插重复值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (find(value)) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"值已存在\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 随机计算新节点层次</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> currentMaxLevel = randomLevel();</span><br><span class=\"line\">    <span class=\"comment\">// 2. 遍历每一层插入节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.1 判断当前最大层次是否满足</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentMaxLevel &gt; maxLevel) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; maxLevel &lt; currentMaxLevel; maxLevel++) &#123;</span><br><span class=\"line\">            SkipListNode newHead = <span class=\"keyword\">new</span> SkipListNode(maxLevel + <span class=\"number\">1</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            newHead.setDown(head);</span><br><span class=\"line\">            head = newHead;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.2 取头节点作为游标</span></span><br><span class=\"line\">    SkipListNode cursorHeadNode = head;</span><br><span class=\"line\">    <span class=\"comment\">// 2.3 新建节点</span></span><br><span class=\"line\">    SkipListNode newNode = <span class=\"keyword\">new</span> SkipListNode(maxLevel, value);</span><br><span class=\"line\">    <span class=\"comment\">// 2.4 循环处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = maxLevel; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        SkipListNode cursorNode = cursorHeadNode.getNext();</span><br><span class=\"line\">        <span class=\"comment\">// 当前层次大于新建节点最大层次，下降一层并跳过</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; currentMaxLevel) &#123;</span><br><span class=\"line\">            cursorHeadNode = cursorHeadNode.getDown();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前层次遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 头节点的下一节点为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursorNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cursorHeadNode.setNext(newNode);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 第一个节点值比新增值大</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursorNode.getValue() &gt; value) &#123;</span><br><span class=\"line\">                cursorHeadNode.setNext(newNode);</span><br><span class=\"line\">                newNode.setNext(cursorNode);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursorNode.getValue() &lt; value) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cursorNode.getNext() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 跟在最后一个节点后面</span></span><br><span class=\"line\">                    cursorNode.setNext(newNode);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cursorNode.getNext().getValue() &gt; value) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 插入两者中间</span></span><br><span class=\"line\">                    newNode.setNext(cursorNode.getNext());</span><br><span class=\"line\">                    cursorNode.setNext(newNode);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 移动到下一节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursorNode.getNext().getValue() &lt; value) &#123;</span><br><span class=\"line\">                cursorNode = cursorNode.getNext();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cursorHeadNode = cursorHeadNode.getDown();</span><br><span class=\"line\">        <span class=\"comment\">// 设置新节点的下一节点</span></span><br><span class=\"line\">        SkipListNode nextNewNode = <span class=\"keyword\">new</span> SkipListNode(i - <span class=\"number\">1</span>, value);</span><br><span class=\"line\">        newNode.setDown(nextNewNode);</span><br><span class=\"line\">        newNode = nextNewNode;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">find</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 游标节点</span></span><br><span class=\"line\">    SkipListNode cursorNode = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 游标为null，终止遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursorNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 头节点为虚节点，所以取下一节点为当前节点与入参做比较</span></span><br><span class=\"line\">        <span class=\"comment\">// 或 已经比较过的节点作为游标，所以也是取他的下一节点做比较</span></span><br><span class=\"line\">        SkipListNode currentNode = cursorNode.getNext();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            cursorNode = cursorNode.getDown();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 比较当前节点与入参的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.getValue().equals(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.getValue() &gt; value) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点大，游标移动到下一层</span></span><br><span class=\"line\">            cursorNode = cursorNode.getDown();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.getValue() &lt; value) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点小，下一节点为空，则移动到下一层</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode.getNext() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cursorNode = currentNode.getDown();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点小，下一节点不为空但比入参大，移动到下一层</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode.getNext().getValue() &gt; value) &#123;</span><br><span class=\"line\">                cursorNode = currentNode.getDown();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点小，下一节点不为空且也比入参小，游标移动到下一节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode.getNext().getValue() &lt; value) &#123;</span><br><span class=\"line\">                cursorNode = currentNode.getNext();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  以一个个节点实现跳表逻辑的时候发现相比用数组维护同一值的结构，操作要复杂一些。因为会涉及节点的比较及右移，下移。</p>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">skipListTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    SkipList list = <span class=\"keyword\">new</span> SkipList();</span><br><span class=\"line\">    list.insert(<span class=\"number\">1</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">5</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">9</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">12</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">3</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">34</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">20</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">11</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">6</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">8</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">2</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">4</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">33</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">21</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">19</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">25</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">72</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">13</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">15</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">7</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">32</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"size;&#123;&#125;\"</span>, list.getSize());</span><br><span class=\"line\">    list.showData();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/skiplist/skiplist2.png\" class=\"\" title=\"测试结果\">\n\n<p>  测试发现，因为每个新节点的层数都是按照随机的方式决定，那么有可能会导致索引层的不合理。</p>\n<h3 id=\"redis实现\"><a href=\"#redis实现\" class=\"headerlink\" title=\"redis实现\"></a>redis实现</h3><p>  先来看看redis的节点定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct zskiplistNode &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\">    <span class=\"comment\">// 分值</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">    <span class=\"comment\">// 后退指针</span></span><br><span class=\"line\">    struct zskiplistNode *backward;</span><br><span class=\"line\">    <span class=\"comment\">// 层</span></span><br><span class=\"line\">    struct zskiplistLevel &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前进指针</span></span><br><span class=\"line\">        struct zskiplistNode *forward;</span><br><span class=\"line\">        <span class=\"comment\">// 跨度</span></span><br><span class=\"line\">        unsigned <span class=\"keyword\">int</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n<p>  redis的节点定义与上述例子不同，他是在节点内用数组维护了对应层的下一节点。<br>  借用这种思想用Java实现的话：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节点类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SkipListNode2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer level;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 对应每一层的下一节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode2[] nextNodes;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipListNode2</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextNodes = <span class=\"keyword\">new</span> SkipListNode2[level];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLevel</span><span class=\"params\">(Integer level)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> SkipListNode2[] getNextNodes() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextNodes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextNodes</span><span class=\"params\">(SkipListNode2[] nextNodes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextNodes = nextNodes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 跳表类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SkipList2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(SkipList2<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_LEVEL = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> levelCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 头节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode2 head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipList2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.levelCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head = <span class=\"keyword\">new</span> SkipListNode2(MAX_LEVEL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 插入节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (find(value) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"值已存在\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = randomLevel();</span><br><span class=\"line\">        SkipListNode2 newNode = <span class=\"keyword\">new</span> SkipListNode2(level);</span><br><span class=\"line\">        newNode.setLevel(level);</span><br><span class=\"line\">        newNode.setValue(value);</span><br><span class=\"line\">        SkipListNode2[] newNextNodes = <span class=\"keyword\">new</span> SkipListNode2[level];</span><br><span class=\"line\">        newNode.setNextNodes(newNextNodes);</span><br><span class=\"line\">        <span class=\"comment\">// 游标节点</span></span><br><span class=\"line\">        SkipListNode2 cursorNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = level - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 比较下一节点与入参值，若小于入参值则向后移动</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cursorNode.getNextNodes()[i] != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; cursorNode.getNextNodes()[i].getValue() &lt; value) &#123;</span><br><span class=\"line\">                cursorNode = cursorNode.getNextNodes()[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历到大于入参值的节点，置为新节点当前层的下一节点</span></span><br><span class=\"line\">            newNextNodes[i] = cursorNode.getNextNodes()[i];</span><br><span class=\"line\">            cursorNode.getNextNodes()[i] = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level &gt; levelCount) &#123;</span><br><span class=\"line\">            levelCount = level;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 搜索</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> SkipListNode2 <span class=\"title\">find</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 游标节点</span></span><br><span class=\"line\">        SkipListNode2 cursorNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = levelCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 比较下一节点与入参值，若小于入参值则向后移动</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cursorNode.getNextNodes()[i] != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; cursorNode.getNextNodes()[i].getValue() &lt; value) &#123;</span><br><span class=\"line\">                cursorNode = cursorNode.getNextNodes()[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursorNode.getNextNodes()[<span class=\"number\">0</span>] != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; cursorNode.getNextNodes()[<span class=\"number\">0</span>].getValue().equals(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cursorNode;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SkipListNode2 cursorNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = levelCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 比较下一节点与入参值，若小于入参值则向后移动</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cursorNode.getNextNodes()[i] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                System.out.print(cursorNode.getNextNodes()[i].getValue() + <span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                cursorNode = cursorNode.getNextNodes()[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cursorNode = head;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 随机计算节点最大层次</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">randomLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r.nextInt(<span class=\"number\">10</span>) &lt; p &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class=\"line\">            level++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  这种思路明显要比单一节点的实现更加方便，数组存放了下一节点指针，而不同的下标又表示了不同层的下一节点指针，替代了next和down指针的作用。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  redis用跳表实现zset类型要比上面实现的例子考虑的更多(像节点维护的跨度信息，及zset权重分数\n的维护等)，不过本章只探讨跳表的实现思路，所以就不详细探讨这方面了。\n  关于跳表的实现我一开始想的是用一个一个节点去描述跳表结构，看了redis的节点定义及网上的一些\n示例，才理解用数组去描述的思路。用数组实现的代码看起来有点绕，但是理解了就会觉得很简单，不用\n像节点那样频繁的转移。数组使得遍历操作变得更加直接。</code></pre>","site":{"data":{}},"length":716,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  最近有被问到redis中zset类型的数据结构–跳表，所以本章就跳表的原理及redis中的实现做一个总结。</p>","more":"<h3 id=\"跳表原理\"><a href=\"#跳表原理\" class=\"headerlink\" title=\"跳表原理\"></a>跳表原理</h3><p>  跳表的结构很简单，就是在一个链表的基础上，建立n层索引层。</p>\n<img src=\"/image/skiplist/skiplist1.png\" class=\"\" title=\"跳表结构\">\n\n<p>  如上图所示，借助索引层，可以使得查询按照类似二分查找的方式更快定位目标节点的位置，而不必遍历整个链表。<br>  也因此，跳表中是不允许重复的值的。</p>\n<h3 id=\"实现方式\"><a href=\"#实现方式\" class=\"headerlink\" title=\"实现方式\"></a>实现方式</h3><p>  跳表可以理解为几层链表，只不过一层比一层”稀疏”。实现跳表一个关键点在于确定节点的层数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用随机的方式确定每一个节点的层数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">randomLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> level = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (r.nextInt(<span class=\"number\">10</span>) &lt; p &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class=\"line\">        level++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"类定义\"><a href=\"#类定义\" class=\"headerlink\" title=\"类定义\"></a>类定义</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 跳表节点类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SkipListNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode next;</span><br><span class=\"line\">    <span class=\"comment\">// 下一层节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode down;</span><br><span class=\"line\">    <span class=\"comment\">// 节点所在层数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> level;</span><br><span class=\"line\">    <span class=\"comment\">// 值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipListNode</span><span class=\"params\">(<span class=\"keyword\">int</span> level, Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipListNode</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   这里实现跳表是定义了每一个节点(相同值不同层当作不同节点)，通过节点的next指针和down指针操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 跳表定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SkipList</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 最大层数，对层数随机的限制</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_LEVEL = <span class=\"number\">16</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 头节点，是一个虚节点，无实际值</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode head;</span><br><span class=\"line\">    <span class=\"comment\">// 跳表长度，实际值的数量，不包括索引节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 当前跳表最大的层数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxLevel;</span><br><span class=\"line\">    <span class=\"comment\">// 用来随机层数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造方法，初始化头节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head = <span class=\"keyword\">new</span> SkipListNode(<span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head.setNext(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head.setDown(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.maxLevel = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 新增操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 校验，不让插重复值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (find(value)) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"值已存在\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1. 随机计算新节点层次</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> currentMaxLevel = randomLevel();</span><br><span class=\"line\">    <span class=\"comment\">// 2. 遍历每一层插入节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 2.1 判断当前最大层次是否满足</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentMaxLevel &gt; maxLevel) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; maxLevel &lt; currentMaxLevel; maxLevel++) &#123;</span><br><span class=\"line\">            SkipListNode newHead = <span class=\"keyword\">new</span> SkipListNode(maxLevel + <span class=\"number\">1</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            newHead.setDown(head);</span><br><span class=\"line\">            head = newHead;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 2.2 取头节点作为游标</span></span><br><span class=\"line\">    SkipListNode cursorHeadNode = head;</span><br><span class=\"line\">    <span class=\"comment\">// 2.3 新建节点</span></span><br><span class=\"line\">    SkipListNode newNode = <span class=\"keyword\">new</span> SkipListNode(maxLevel, value);</span><br><span class=\"line\">    <span class=\"comment\">// 2.4 循环处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = maxLevel; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        SkipListNode cursorNode = cursorHeadNode.getNext();</span><br><span class=\"line\">        <span class=\"comment\">// 当前层次大于新建节点最大层次，下降一层并跳过</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt; currentMaxLevel) &#123;</span><br><span class=\"line\">            cursorHeadNode = cursorHeadNode.getDown();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 当前层次遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 头节点的下一节点为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursorNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cursorHeadNode.setNext(newNode);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 第一个节点值比新增值大</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursorNode.getValue() &gt; value) &#123;</span><br><span class=\"line\">                cursorHeadNode.setNext(newNode);</span><br><span class=\"line\">                newNode.setNext(cursorNode);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursorNode.getValue() &lt; value) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cursorNode.getNext() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 跟在最后一个节点后面</span></span><br><span class=\"line\">                    cursorNode.setNext(newNode);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cursorNode.getNext().getValue() &gt; value) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 插入两者中间</span></span><br><span class=\"line\">                    newNode.setNext(cursorNode.getNext());</span><br><span class=\"line\">                    cursorNode.setNext(newNode);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 移动到下一节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursorNode.getNext().getValue() &lt; value) &#123;</span><br><span class=\"line\">                cursorNode = cursorNode.getNext();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cursorHeadNode = cursorHeadNode.getDown();</span><br><span class=\"line\">        <span class=\"comment\">// 设置新节点的下一节点</span></span><br><span class=\"line\">        SkipListNode nextNewNode = <span class=\"keyword\">new</span> SkipListNode(i - <span class=\"number\">1</span>, value);</span><br><span class=\"line\">        newNode.setDown(nextNewNode);</span><br><span class=\"line\">        newNode = nextNewNode;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">find</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 游标节点</span></span><br><span class=\"line\">    SkipListNode cursorNode = head;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 游标为null，终止遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursorNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 头节点为虚节点，所以取下一节点为当前节点与入参做比较</span></span><br><span class=\"line\">        <span class=\"comment\">// 或 已经比较过的节点作为游标，所以也是取他的下一节点做比较</span></span><br><span class=\"line\">        SkipListNode currentNode = cursorNode.getNext();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            cursorNode = cursorNode.getDown();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 比较当前节点与入参的值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.getValue().equals(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.getValue() &gt; value) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点大，游标移动到下一层</span></span><br><span class=\"line\">            cursorNode = cursorNode.getDown();</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode.getValue() &lt; value) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点小，下一节点为空，则移动到下一层</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode.getNext() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                cursorNode = currentNode.getDown();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点小，下一节点不为空但比入参大，移动到下一层</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode.getNext().getValue() &gt; value) &#123;</span><br><span class=\"line\">                cursorNode = currentNode.getDown();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 当前节点小，下一节点不为空且也比入参小，游标移动到下一节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentNode.getNext().getValue() &lt; value) &#123;</span><br><span class=\"line\">                cursorNode = currentNode.getNext();</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  以一个个节点实现跳表逻辑的时候发现相比用数组维护同一值的结构，操作要复杂一些。因为会涉及节点的比较及右移，下移。</p>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">skipListTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    SkipList list = <span class=\"keyword\">new</span> SkipList();</span><br><span class=\"line\">    list.insert(<span class=\"number\">1</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">5</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">9</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">12</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">3</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">34</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">20</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">11</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">6</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">8</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">2</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">4</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">33</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">21</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">19</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">25</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">72</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">13</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">15</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">7</span>);</span><br><span class=\"line\">    list.insert(<span class=\"number\">32</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"size;&#123;&#125;\"</span>, list.getSize());</span><br><span class=\"line\">    list.showData();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/skiplist/skiplist2.png\" class=\"\" title=\"测试结果\">\n\n<p>  测试发现，因为每个新节点的层数都是按照随机的方式决定，那么有可能会导致索引层的不合理。</p>\n<h3 id=\"redis实现\"><a href=\"#redis实现\" class=\"headerlink\" title=\"redis实现\"></a>redis实现</h3><p>  先来看看redis的节点定义</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct zskiplistNode &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 成员对象</span></span><br><span class=\"line\">    robj *obj;</span><br><span class=\"line\">    <span class=\"comment\">// 分值</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> score;</span><br><span class=\"line\">    <span class=\"comment\">// 后退指针</span></span><br><span class=\"line\">    struct zskiplistNode *backward;</span><br><span class=\"line\">    <span class=\"comment\">// 层</span></span><br><span class=\"line\">    struct zskiplistLevel &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 前进指针</span></span><br><span class=\"line\">        struct zskiplistNode *forward;</span><br><span class=\"line\">        <span class=\"comment\">// 跨度</span></span><br><span class=\"line\">        unsigned <span class=\"keyword\">int</span> span;</span><br><span class=\"line\">    &#125; level[];</span><br><span class=\"line\">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>\n<p>  redis的节点定义与上述例子不同，他是在节点内用数组维护了对应层的下一节点。<br>  借用这种思想用Java实现的话：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节点类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SkipListNode2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer level;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 对应每一层的下一节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode2[] nextNodes;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipListNode2</span><span class=\"params\">(<span class=\"keyword\">int</span> level)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextNodes = <span class=\"keyword\">new</span> SkipListNode2[level];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setValue</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">getLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLevel</span><span class=\"params\">(Integer level)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> SkipListNode2[] getNextNodes() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextNodes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNextNodes</span><span class=\"params\">(SkipListNode2[] nextNodes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.nextNodes = nextNodes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 跳表类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SkipList2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(SkipList2<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_LEVEL = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Random r = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> levelCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 头节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SkipListNode2 head;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SkipList2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.levelCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.head = <span class=\"keyword\">new</span> SkipListNode2(MAX_LEVEL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 插入节点</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (find(value) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"值已存在\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = randomLevel();</span><br><span class=\"line\">        SkipListNode2 newNode = <span class=\"keyword\">new</span> SkipListNode2(level);</span><br><span class=\"line\">        newNode.setLevel(level);</span><br><span class=\"line\">        newNode.setValue(value);</span><br><span class=\"line\">        SkipListNode2[] newNextNodes = <span class=\"keyword\">new</span> SkipListNode2[level];</span><br><span class=\"line\">        newNode.setNextNodes(newNextNodes);</span><br><span class=\"line\">        <span class=\"comment\">// 游标节点</span></span><br><span class=\"line\">        SkipListNode2 cursorNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = level - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 比较下一节点与入参值，若小于入参值则向后移动</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cursorNode.getNextNodes()[i] != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; cursorNode.getNextNodes()[i].getValue() &lt; value) &#123;</span><br><span class=\"line\">                cursorNode = cursorNode.getNextNodes()[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 遍历到大于入参值的节点，置为新节点当前层的下一节点</span></span><br><span class=\"line\">            newNextNodes[i] = cursorNode.getNextNodes()[i];</span><br><span class=\"line\">            cursorNode.getNextNodes()[i] = newNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level &gt; levelCount) &#123;</span><br><span class=\"line\">            levelCount = level;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 搜索</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> SkipListNode2 <span class=\"title\">find</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 游标节点</span></span><br><span class=\"line\">        SkipListNode2 cursorNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = levelCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 比较下一节点与入参值，若小于入参值则向后移动</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cursorNode.getNextNodes()[i] != <span class=\"keyword\">null</span></span><br><span class=\"line\">                    &amp;&amp; cursorNode.getNextNodes()[i].getValue() &lt; value) &#123;</span><br><span class=\"line\">                cursorNode = cursorNode.getNextNodes()[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursorNode.getNextNodes()[<span class=\"number\">0</span>] != <span class=\"keyword\">null</span></span><br><span class=\"line\">                &amp;&amp; cursorNode.getNextNodes()[<span class=\"number\">0</span>].getValue().equals(value)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cursorNode;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showData</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SkipListNode2 cursorNode = head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = levelCount - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 比较下一节点与入参值，若小于入参值则向后移动</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (cursorNode.getNextNodes()[i] != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                System.out.print(cursorNode.getNextNodes()[i].getValue() + <span class=\"string\">\",\"</span>);</span><br><span class=\"line\">                cursorNode = cursorNode.getNextNodes()[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cursorNode = head;</span><br><span class=\"line\">            System.out.println();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 随机计算节点最大层次</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">randomLevel</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> level = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (r.nextInt(<span class=\"number\">10</span>) &lt; p &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class=\"line\">            level++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  这种思路明显要比单一节点的实现更加方便，数组存放了下一节点指针，而不同的下标又表示了不同层的下一节点指针，替代了next和down指针的作用。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  redis用跳表实现zset类型要比上面实现的例子考虑的更多(像节点维护的跨度信息，及zset权重分数\n的维护等)，不过本章只探讨跳表的实现思路，所以就不详细探讨这方面了。\n  关于跳表的实现我一开始想的是用一个一个节点去描述跳表结构，看了redis的节点定义及网上的一些\n示例，才理解用数组去描述的思路。用数组实现的代码看起来有点绕，但是理解了就会觉得很简单，不用\n像节点那样频繁的转移。数组使得遍历操作变得更加直接。</code></pre>"},{"title":"AOP","date":"2020-07-12T02:35:59.000Z","_content":"\n### 前言\n\n  本章主要总结下AOP的原理及实现。\n<!-- more -->\n\n### 代理模式\n\n  AOP基于代理模式的设计思想，先来看看什么是代理模式\n\n{% img  /image/aop/aop1.png  '\"代理模式的结构\"' %}\n\n{% codeblock lang:java %}\n/**\n * 服务接口\n *\n * @author RF\n * @date 2020/7/13\n */\npublic interface ServiceInterface {\n    void show(String msg);\n}\n\n/**\n * 真实服务\n *\n * @author RF\n * @date 2020/7/13\n */\npublic class RealService implements ServiceInterface {\n    private static final Logger logger = LoggerFactory.getLogger(RealService.class);\n\n    @Override\n    public void show(String msg) {\n        logger.info(\"realService info:{}\", msg);\n    }\n}\n\n/**\n * 代理服务\n *\n * @author RF\n * @date 2020/7/13\n */\npublic class ProxyService implements ServiceInterface {\n    private final Logger logger = LoggerFactory.getLogger(ProxyService.class);\n\n    private RealService realService;\n\n    @Override\n    public void show(String msg) {\n        logger.info(\"proxy service：{}\", msg);\n        realService.show(msg);\n    }\n}\n{% endcodeblock%}\n\n  代理类与被代理类实现相同的接口，这样保证两者的结构一致性。同时两者又是组合关系，代理类中包含被代理类的实例。\n\n  代理模式可以在不修改原有代码的前提下，对其进行扩展，符合开放封闭原则，但其缺点是要新建许多代理类。\n  \n### 动态代理\n\n  上述实现代理模式的方法也被称为静态代理，其缺点显而易见，所以就有了动态代理的这种方式去实现。\n\n#### 基于JDK的动态代理\n\n{% codeblock lang:java %}\n/**\n * 实现InvocationHandler的代理类\n *\n * @author RF\n * @date 2020/7/13\n */\npublic class JdkProxy<T> implements InvocationHandler {\n    private static final Logger logger = LoggerFactory.getLogger(JdkProxy.class);\n    private T realService;\n\n    public JdkProxy(T realService) {\n        this.realService = realService;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        logger.info(\"parameter：{}\", method);\n        logger.info(\"args:{}\", args[0]);\n        method.invoke(realService, args[0]);\n        return null;\n    }\n}\n\npublic void main(String[] args){\n    RealService realService = new RealService();\n    JdkProxy<RealService> handler = new JdkProxy<>(realService);\n    ServiceInterface serviceInterface = (ServiceInterface) Proxy.newProxyInstance(\n            ServiceInterface.class.getClassLoader(),\n            new Class[]{ServiceInterface.class},\n            handler);\n    serviceInterface.show(\"hello world\");\n}\n\n// output:\n// parameter：public abstract void com.example.demo.proxy.ServiceInterface.show(java.lang.String)\n// args:hello world\n// realService info:hello world\n{% endcodeblock %}\n\n  这种方式的好处是针对接口的某种扩展只需新建一个实现了*InvocationHandler* 的代理类，然后调用Proxy的方法就能实现。而不需要像静态代理一样对每一个接口的实例新建一个对应的代理类。\n\n#### 基于CGLIB的动态代理\n  \n  待补充\n\n\n### 注解方式实现AOP\n\n  在spring boot中，我们可以更加方便的使用注解的形式实现AOP。\n\n{% codeblock lang:java %}\n// 切面类\n@Aspect\n@Component\npublic class MyAspect {\n    private static final Logger logger = LoggerFactory.getLogger(MyAspect.class);\n\n    @Pointcut(\"@annotation(com.example.demo.aop.MyLogger)\")\n    public void myPointCut() {\n    }\n\n    @Before(\"myPointCut()\")\n    public void beforeMethod(JoinPoint joinPoint) {\n        logger.info(\"before time:{}\", LocalDateTime.now());\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        logger.info(\"method name:{}\", method.getName());\n        MyLogger myAnnotation = method.getAnnotation(MyLogger.class);\n        if (null != myAnnotation) {\n            logger.info(\"annotation name:{}\", myAnnotation.name());\n        }\n        //获取接口入参\n        Object[] args = joinPoint.getArgs();\n        StringBuilder sb = new StringBuilder();\n        if (null != args) {\n            for (Object o : args) {\n                sb.append(o).append(\",\");\n            }\n        }\n        // 输出接口入参\n        logger.info(\"parameter:{}\", sb);\n    }\n\n    @After(\"myPointCut()\")\n    public void afterMethod() {\n        logger.info(\"after time:{}\", LocalDateTime.now());\n    }\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\npublic @interface MyLogger {\n\n    String name() default \"\";\n}\n\n// 使用注解标记目标接口\n@GetMapping(value = \"/test/send\")\n@MyLogger(name = \"hello world\")\npublic void send(@RequestParam(\"message\") String message,\n                 @RequestParam(\"userId\") Integer userId) {\n    logger.info(\"do something·······:{},{}\", message, userId);\n}\n{% endcodeblock %}\n\n{% img /image/aop/aop2.png '\"调用结果\"' %}\n\n### 小结\n\n      AOP是一种面向切面编程的思想，他的目的是将不影响业务逻辑的共同操作给提出来，将其与主逻辑分\n    离，一方面能够简化代码，一方面达到解耦的目的。\n      这些分离出来的操作又按照需求插入到主逻辑的代码间隙中，所以被形象的成为面向切面编程。\n      其应用场景很多，最常见的就是类似上述例子中接口入参的日志输出，这样可以不用在每个接口开头去写\n    一行日志输出的代码了。\n      而动态代理的实现原理可以理解为对字节码的增强，其会在运行时对目标类的字节码进行修改，增加指定\n    的切面操作的内容。\n\n### 参考\n\n>  [代理设计模式](https://refactoringguru.cn/design-patterns/proxy)\n>  [动态代理-廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984#0)\n>  [java动态代理实现与原理详细分析](https://www.cnblogs.com/gonjan-blog/p/6685611.html)\n","source":"_posts/2020/07/aop1.md","raw":"---\ntitle: AOP\ndate: 2020-07-12 10:35:59\ntags:\n- AOP\ncategories:\n- Spring\n- AOP\n---\n\n### 前言\n\n  本章主要总结下AOP的原理及实现。\n<!-- more -->\n\n### 代理模式\n\n  AOP基于代理模式的设计思想，先来看看什么是代理模式\n\n{% img  /image/aop/aop1.png  '\"代理模式的结构\"' %}\n\n{% codeblock lang:java %}\n/**\n * 服务接口\n *\n * @author RF\n * @date 2020/7/13\n */\npublic interface ServiceInterface {\n    void show(String msg);\n}\n\n/**\n * 真实服务\n *\n * @author RF\n * @date 2020/7/13\n */\npublic class RealService implements ServiceInterface {\n    private static final Logger logger = LoggerFactory.getLogger(RealService.class);\n\n    @Override\n    public void show(String msg) {\n        logger.info(\"realService info:{}\", msg);\n    }\n}\n\n/**\n * 代理服务\n *\n * @author RF\n * @date 2020/7/13\n */\npublic class ProxyService implements ServiceInterface {\n    private final Logger logger = LoggerFactory.getLogger(ProxyService.class);\n\n    private RealService realService;\n\n    @Override\n    public void show(String msg) {\n        logger.info(\"proxy service：{}\", msg);\n        realService.show(msg);\n    }\n}\n{% endcodeblock%}\n\n  代理类与被代理类实现相同的接口，这样保证两者的结构一致性。同时两者又是组合关系，代理类中包含被代理类的实例。\n\n  代理模式可以在不修改原有代码的前提下，对其进行扩展，符合开放封闭原则，但其缺点是要新建许多代理类。\n  \n### 动态代理\n\n  上述实现代理模式的方法也被称为静态代理，其缺点显而易见，所以就有了动态代理的这种方式去实现。\n\n#### 基于JDK的动态代理\n\n{% codeblock lang:java %}\n/**\n * 实现InvocationHandler的代理类\n *\n * @author RF\n * @date 2020/7/13\n */\npublic class JdkProxy<T> implements InvocationHandler {\n    private static final Logger logger = LoggerFactory.getLogger(JdkProxy.class);\n    private T realService;\n\n    public JdkProxy(T realService) {\n        this.realService = realService;\n    }\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        logger.info(\"parameter：{}\", method);\n        logger.info(\"args:{}\", args[0]);\n        method.invoke(realService, args[0]);\n        return null;\n    }\n}\n\npublic void main(String[] args){\n    RealService realService = new RealService();\n    JdkProxy<RealService> handler = new JdkProxy<>(realService);\n    ServiceInterface serviceInterface = (ServiceInterface) Proxy.newProxyInstance(\n            ServiceInterface.class.getClassLoader(),\n            new Class[]{ServiceInterface.class},\n            handler);\n    serviceInterface.show(\"hello world\");\n}\n\n// output:\n// parameter：public abstract void com.example.demo.proxy.ServiceInterface.show(java.lang.String)\n// args:hello world\n// realService info:hello world\n{% endcodeblock %}\n\n  这种方式的好处是针对接口的某种扩展只需新建一个实现了*InvocationHandler* 的代理类，然后调用Proxy的方法就能实现。而不需要像静态代理一样对每一个接口的实例新建一个对应的代理类。\n\n#### 基于CGLIB的动态代理\n  \n  待补充\n\n\n### 注解方式实现AOP\n\n  在spring boot中，我们可以更加方便的使用注解的形式实现AOP。\n\n{% codeblock lang:java %}\n// 切面类\n@Aspect\n@Component\npublic class MyAspect {\n    private static final Logger logger = LoggerFactory.getLogger(MyAspect.class);\n\n    @Pointcut(\"@annotation(com.example.demo.aop.MyLogger)\")\n    public void myPointCut() {\n    }\n\n    @Before(\"myPointCut()\")\n    public void beforeMethod(JoinPoint joinPoint) {\n        logger.info(\"before time:{}\", LocalDateTime.now());\n        MethodSignature signature = (MethodSignature) joinPoint.getSignature();\n        Method method = signature.getMethod();\n        logger.info(\"method name:{}\", method.getName());\n        MyLogger myAnnotation = method.getAnnotation(MyLogger.class);\n        if (null != myAnnotation) {\n            logger.info(\"annotation name:{}\", myAnnotation.name());\n        }\n        //获取接口入参\n        Object[] args = joinPoint.getArgs();\n        StringBuilder sb = new StringBuilder();\n        if (null != args) {\n            for (Object o : args) {\n                sb.append(o).append(\",\");\n            }\n        }\n        // 输出接口入参\n        logger.info(\"parameter:{}\", sb);\n    }\n\n    @After(\"myPointCut()\")\n    public void afterMethod() {\n        logger.info(\"after time:{}\", LocalDateTime.now());\n    }\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.METHOD})\npublic @interface MyLogger {\n\n    String name() default \"\";\n}\n\n// 使用注解标记目标接口\n@GetMapping(value = \"/test/send\")\n@MyLogger(name = \"hello world\")\npublic void send(@RequestParam(\"message\") String message,\n                 @RequestParam(\"userId\") Integer userId) {\n    logger.info(\"do something·······:{},{}\", message, userId);\n}\n{% endcodeblock %}\n\n{% img /image/aop/aop2.png '\"调用结果\"' %}\n\n### 小结\n\n      AOP是一种面向切面编程的思想，他的目的是将不影响业务逻辑的共同操作给提出来，将其与主逻辑分\n    离，一方面能够简化代码，一方面达到解耦的目的。\n      这些分离出来的操作又按照需求插入到主逻辑的代码间隙中，所以被形象的成为面向切面编程。\n      其应用场景很多，最常见的就是类似上述例子中接口入参的日志输出，这样可以不用在每个接口开头去写\n    一行日志输出的代码了。\n      而动态代理的实现原理可以理解为对字节码的增强，其会在运行时对目标类的字节码进行修改，增加指定\n    的切面操作的内容。\n\n### 参考\n\n>  [代理设计模式](https://refactoringguru.cn/design-patterns/proxy)\n>  [动态代理-廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984#0)\n>  [java动态代理实现与原理详细分析](https://www.cnblogs.com/gonjan-blog/p/6685611.html)\n","slug":"aop1","published":1,"updated":"2020-11-09T14:29:32.543Z","_id":"ckdvmudyt0021nwb5b3xq6960","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章主要总结下AOP的原理及实现。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p>  AOP基于代理模式的设计思想，先来看看什么是代理模式</p>\n<img src=\"/image/aop/aop1.png\" class=\"\" title=\"代理模式的结构\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 服务接口</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> RF</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2020/7/13</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ServiceInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 真实服务</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> RF</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2020/7/13</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealService</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServiceInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(RealService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"realService info:&#123;&#125;\"</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 代理服务</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> RF</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2020/7/13</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyService</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServiceInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(ProxyService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealService realService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"proxy service：&#123;&#125;\"</span>, msg);</span><br><span class=\"line\">        realService.show(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  代理类与被代理类实现相同的接口，这样保证两者的结构一致性。同时两者又是组合关系，代理类中包含被代理类的实例。</p>\n<p>  代理模式可以在不修改原有代码的前提下，对其进行扩展，符合开放封闭原则，但其缺点是要新建许多代理类。</p>\n<h3 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h3><p>  上述实现代理模式的方法也被称为静态代理，其缺点显而易见，所以就有了动态代理的这种方式去实现。</p>\n<h4 id=\"基于JDK的动态代理\"><a href=\"#基于JDK的动态代理\" class=\"headerlink\" title=\"基于JDK的动态代理\"></a>基于JDK的动态代理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现InvocationHandler的代理类</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> RF</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2020/7/13</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdkProxy</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(JdkProxy<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T realService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JdkProxy</span><span class=\"params\">(T realService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.realService = realService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"parameter：&#123;&#125;\"</span>, method);</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"args:&#123;&#125;\"</span>, args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        method.invoke(realService, args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    RealService realService = <span class=\"keyword\">new</span> RealService();</span><br><span class=\"line\">    JdkProxy&lt;RealService&gt; handler = <span class=\"keyword\">new</span> JdkProxy&lt;&gt;(realService);</span><br><span class=\"line\">    ServiceInterface serviceInterface = (ServiceInterface) Proxy.newProxyInstance(</span><br><span class=\"line\">            ServiceInterface<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">getClassLoader</span>(),</span></span><br><span class=\"line\">            new Class[]&#123;ServiceInterface.class&#125;,</span><br><span class=\"line\">            handler);</span><br><span class=\"line\">    serviceInterface.show(<span class=\"string\">\"hello world\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// parameter：public abstract void com.example.demo.proxy.ServiceInterface.show(java.lang.String)</span></span><br><span class=\"line\"><span class=\"comment\">// args:hello world</span></span><br><span class=\"line\"><span class=\"comment\">// realService info:hello world</span></span><br></pre></td></tr></table></figure>\n\n<p>  这种方式的好处是针对接口的某种扩展只需新建一个实现了<em>InvocationHandler</em> 的代理类，然后调用Proxy的方法就能实现。而不需要像静态代理一样对每一个接口的实例新建一个对应的代理类。</p>\n<h4 id=\"基于CGLIB的动态代理\"><a href=\"#基于CGLIB的动态代理\" class=\"headerlink\" title=\"基于CGLIB的动态代理\"></a>基于CGLIB的动态代理</h4><p>  待补充</p>\n<h3 id=\"注解方式实现AOP\"><a href=\"#注解方式实现AOP\" class=\"headerlink\" title=\"注解方式实现AOP\"></a>注解方式实现AOP</h3><p>  在spring boot中，我们可以更加方便的使用注解的形式实现AOP。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 切面类</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(MyAspect<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.demo.aop.MyLogger)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">myPointCut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"myPointCut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeMethod</span><span class=\"params\">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"before time:&#123;&#125;\"</span>, LocalDateTime.now());</span><br><span class=\"line\">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        Method method = signature.getMethod();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"method name:&#123;&#125;\"</span>, method.getName());</span><br><span class=\"line\">        MyLogger myAnnotation = method.getAnnotation(MyLogger<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != myAnnotation) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"annotation name:&#123;&#125;\"</span>, myAnnotation.name());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取接口入参</span></span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != args) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Object o : args) &#123;</span><br><span class=\"line\">                sb.append(o).append(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 输出接口入参</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">\"parameter:&#123;&#125;\"</span>, sb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(<span class=\"string\">\"myPointCut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"after time:&#123;&#125;\"</span>, LocalDateTime.now());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MyLogger &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用注解标记目标接口</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(value = <span class=\"string\">\"/test/send\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@MyLogger</span>(name = <span class=\"string\">\"hello world\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(@RequestParam(<span class=\"string\">\"message\"</span>)</span> String message,</span></span><br><span class=\"line\"><span class=\"function\">                 @<span class=\"title\">RequestParam</span><span class=\"params\">(<span class=\"string\">\"userId\"</span>)</span> Integer userId) </span>&#123;</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"do something·······:&#123;&#125;,&#123;&#125;\"</span>, message, userId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/aop/aop2.png\" class=\"\" title=\"调用结果\">\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  AOP是一种面向切面编程的思想，他的目的是将不影响业务逻辑的共同操作给提出来，将其与主逻辑分\n离，一方面能够简化代码，一方面达到解耦的目的。\n  这些分离出来的操作又按照需求插入到主逻辑的代码间隙中，所以被形象的成为面向切面编程。\n  其应用场景很多，最常见的就是类似上述例子中接口入参的日志输出，这样可以不用在每个接口开头去写\n一行日志输出的代码了。\n  而动态代理的实现原理可以理解为对字节码的增强，其会在运行时对目标类的字节码进行修改，增加指定\n的切面操作的内容。</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p> <a href=\"https://refactoringguru.cn/design-patterns/proxy\" target=\"_blank\" rel=\"noopener\">代理设计模式</a><br> <a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984#0\" target=\"_blank\" rel=\"noopener\">动态代理-廖雪峰的官方网站</a><br> <a href=\"https://www.cnblogs.com/gonjan-blog/p/6685611.html\" target=\"_blank\" rel=\"noopener\">java动态代理实现与原理详细分析</a></p>\n</blockquote>\n","site":{"data":{}},"length":630,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章主要总结下AOP的原理及实现。</p>","more":"<h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><p>  AOP基于代理模式的设计思想，先来看看什么是代理模式</p>\n<img src=\"/image/aop/aop1.png\" class=\"\" title=\"代理模式的结构\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 服务接口</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> RF</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2020/7/13</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ServiceInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">(String msg)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 真实服务</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> RF</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2020/7/13</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RealService</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServiceInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(RealService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"realService info:&#123;&#125;\"</span>, msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 代理服务</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> RF</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2020/7/13</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProxyService</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServiceInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(ProxyService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RealService realService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"proxy service：&#123;&#125;\"</span>, msg);</span><br><span class=\"line\">        realService.show(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  代理类与被代理类实现相同的接口，这样保证两者的结构一致性。同时两者又是组合关系，代理类中包含被代理类的实例。</p>\n<p>  代理模式可以在不修改原有代码的前提下，对其进行扩展，符合开放封闭原则，但其缺点是要新建许多代理类。</p>\n<h3 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h3><p>  上述实现代理模式的方法也被称为静态代理，其缺点显而易见，所以就有了动态代理的这种方式去实现。</p>\n<h4 id=\"基于JDK的动态代理\"><a href=\"#基于JDK的动态代理\" class=\"headerlink\" title=\"基于JDK的动态代理\"></a>基于JDK的动态代理</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现InvocationHandler的代理类</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> RF</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2020/7/13</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdkProxy</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(JdkProxy<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T realService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JdkProxy</span><span class=\"params\">(T realService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.realService = realService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"parameter：&#123;&#125;\"</span>, method);</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"args:&#123;&#125;\"</span>, args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        method.invoke(realService, args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    RealService realService = <span class=\"keyword\">new</span> RealService();</span><br><span class=\"line\">    JdkProxy&lt;RealService&gt; handler = <span class=\"keyword\">new</span> JdkProxy&lt;&gt;(realService);</span><br><span class=\"line\">    ServiceInterface serviceInterface = (ServiceInterface) Proxy.newProxyInstance(</span><br><span class=\"line\">            ServiceInterface<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">getClassLoader</span>(),</span></span><br><span class=\"line\">            new Class[]&#123;ServiceInterface.class&#125;,</span><br><span class=\"line\">            handler);</span><br><span class=\"line\">    serviceInterface.show(<span class=\"string\">\"hello world\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output:</span></span><br><span class=\"line\"><span class=\"comment\">// parameter：public abstract void com.example.demo.proxy.ServiceInterface.show(java.lang.String)</span></span><br><span class=\"line\"><span class=\"comment\">// args:hello world</span></span><br><span class=\"line\"><span class=\"comment\">// realService info:hello world</span></span><br></pre></td></tr></table></figure>\n\n<p>  这种方式的好处是针对接口的某种扩展只需新建一个实现了<em>InvocationHandler</em> 的代理类，然后调用Proxy的方法就能实现。而不需要像静态代理一样对每一个接口的实例新建一个对应的代理类。</p>\n<h4 id=\"基于CGLIB的动态代理\"><a href=\"#基于CGLIB的动态代理\" class=\"headerlink\" title=\"基于CGLIB的动态代理\"></a>基于CGLIB的动态代理</h4><p>  待补充</p>\n<h3 id=\"注解方式实现AOP\"><a href=\"#注解方式实现AOP\" class=\"headerlink\" title=\"注解方式实现AOP\"></a>注解方式实现AOP</h3><p>  在spring boot中，我们可以更加方便的使用注解的形式实现AOP。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 切面类</span></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(MyAspect<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"@annotation(com.example.demo.aop.MyLogger)\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">myPointCut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"myPointCut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">beforeMethod</span><span class=\"params\">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"before time:&#123;&#125;\"</span>, LocalDateTime.now());</span><br><span class=\"line\">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class=\"line\">        Method method = signature.getMethod();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"method name:&#123;&#125;\"</span>, method.getName());</span><br><span class=\"line\">        MyLogger myAnnotation = method.getAnnotation(MyLogger<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != myAnnotation) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"annotation name:&#123;&#125;\"</span>, myAnnotation.name());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取接口入参</span></span><br><span class=\"line\">        Object[] args = joinPoint.getArgs();</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != args) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Object o : args) &#123;</span><br><span class=\"line\">                sb.append(o).append(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 输出接口入参</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">\"parameter:&#123;&#125;\"</span>, sb);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@After</span>(<span class=\"string\">\"myPointCut()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"after time:&#123;&#125;\"</span>, LocalDateTime.now());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> MyLogger &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">name</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用注解标记目标接口</span></span><br><span class=\"line\"><span class=\"meta\">@GetMapping</span>(value = <span class=\"string\">\"/test/send\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@MyLogger</span>(name = <span class=\"string\">\"hello world\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">send</span><span class=\"params\">(@RequestParam(<span class=\"string\">\"message\"</span>)</span> String message,</span></span><br><span class=\"line\"><span class=\"function\">                 @<span class=\"title\">RequestParam</span><span class=\"params\">(<span class=\"string\">\"userId\"</span>)</span> Integer userId) </span>&#123;</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"do something·······:&#123;&#125;,&#123;&#125;\"</span>, message, userId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/aop/aop2.png\" class=\"\" title=\"调用结果\">\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  AOP是一种面向切面编程的思想，他的目的是将不影响业务逻辑的共同操作给提出来，将其与主逻辑分\n离，一方面能够简化代码，一方面达到解耦的目的。\n  这些分离出来的操作又按照需求插入到主逻辑的代码间隙中，所以被形象的成为面向切面编程。\n  其应用场景很多，最常见的就是类似上述例子中接口入参的日志输出，这样可以不用在每个接口开头去写\n一行日志输出的代码了。\n  而动态代理的实现原理可以理解为对字节码的增强，其会在运行时对目标类的字节码进行修改，增加指定\n的切面操作的内容。</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p> <a href=\"https://refactoringguru.cn/design-patterns/proxy\" target=\"_blank\" rel=\"noopener\">代理设计模式</a><br> <a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984#0\" target=\"_blank\" rel=\"noopener\">动态代理-廖雪峰的官方网站</a><br> <a href=\"https://www.cnblogs.com/gonjan-blog/p/6685611.html\" target=\"_blank\" rel=\"noopener\">java动态代理实现与原理详细分析</a></p>\n</blockquote>"},{"title":"synchronized相关-对象头&锁机制","date":"2020-08-15T12:49:14.000Z","_content":"\n### 前言\n  \n  之前面试中有被问到synchronized及Java锁机制相关的问题，所以总结一下相关知识点。\n<!-- more -->\n\n### 对象头\n\n#### 对象头的结构\n  synchronized锁住的目标是Java中的对象，那么他到底依赖于什么控制的呢？\n  答案就是---对象头，他是对象在内存中的存储结构之一。\n  所以先来了解下对象头是啥样的：\n> 一般对象的对象头由两部分组成\n> 1.klass pointer(指针，指向其类元数据的信息),\n> 2.Mark word(存储对象的运行时数据，包括哈希码，锁状态等)\n> 如果是数组对象则还存有array length信息\n\n#### Mark word\n  对象头的三个结构中，与synchronized关联紧密的就是第二部分 Mark word。\n  因为他维护着对象的锁标记信息。\n\n{% img  /image/synchronized/synchronized2.png  '\"64位 Mark word结构\"' %}\n\n1.identity_hashcode：对象的Hash值，这里注意如果对象的identity_hashcode不为空，那么他是没法进入偏向锁状态的，因为内存空间被占用了\n2.age：GC分代年龄\n3.biased_lock：偏向锁标志\n4.lock：锁状态标志\n5.thread：偏向锁状态偏向的线程标识\n6.epoch：偏向时间戳\n7.pointer_to_lock_record：指向线程栈中Lock Record的指针\n8.pointer_to_heavyweight_monitor：指向堆中的monitor对象的指针\n\n  其中biased_block和lock即锁标识的信息:\n{% img  /image/synchronized/synchronized1.png  '\"锁状态标记\"' %}\n\n### 锁升级\n\n  对象头中记录了对象不同的锁状态，当触发了对应条件时就会引起其状态的变化，这个过程被称作锁升级。\n\n#### 偏向锁\n\n  当有线程获取到锁资源时就会升级为偏向锁，并在对象头中记录偏向的线程标识，也就是获取到锁资源的线程。\n  >引入偏向锁是因为在一个线程多次获取同一个锁的场景下，如果每次都按照竞争锁的方式去操作未免会造成平白的消耗。\n  >而偏向锁记录了当前拥有锁的线程的标识信息，当同一线程多次去获取该锁时可以直接依据该标识判断，从而减小获取锁的消耗。\n\n#### 轻量级锁\n\n  偏向锁是无竞争场景下的，假设这样一种情况：\n  thread1先获取到了某个对象的锁，thread2慢了一步，获取失败。\n  那么此时如何处理thread2？\n  这里的设计是按照乐观的设想，thread1会很快释放锁资源，所以将偏向锁升级为轻量级锁，让thread2自旋不断尝试获取锁资源。\n\n#### 重量级锁\n\n  轻量级锁是在乐观设想的前提下让获取失败的线程自旋等待。\n  但考虑到最坏的情况，thread1因为某些原因占用时间超出了可接受的范围，如果让thread2一直自旋，甚至后面又来了N个线程也在自旋，这样就浪费了大量的CPU资源，显然是不合理的。\n  所以当线程自旋一定次数还未获得锁资源时，轻量级锁就会升级为重量级锁，让这些尝试获取锁资源的线程通通阻塞，等待锁被释放后再唤醒他们。\n  >重量级锁是jdk1.6之前使用的锁机制，因为其底层依赖于互斥锁，涉及用户态和内核态的转换，进程的上下文切换等，性能影响较大，所以才引入偏向锁和轻量级锁来改善\n\n  关于偏向锁需要注意几点：\n  1). 因为无锁的内存结构中identity_hashcode与偏向锁中的thread的内存空间是冲突的，也就是两者只能存一个，当identity_hashcode不为空的时候，是无法偏向的，这时候会直接升级为轻量级锁\n  2). 有时候会发现状态是偏向锁，biased_lock也显示是1标识偏向锁，但其实thread是空的，这时候表示处于可以偏向的状态\n\n### 小结\n\n      为了写本篇文章着实找了许多博客参考，不过大部分都是一些概念，底层实现逻辑的描述较少。不过还\n    是对synchronized及锁机制有了更清晰的理解，这里照常做一下总结：\n    1.本文只介绍了对象头及synchronized相关的锁机制，如果想了解更多建议阅读参考中强烈推荐的那篇文章\n    2.关于synchronized的使用及理解，我认为主要把握住一点，他锁住的是对象(类对象或者实例对象)\n    3.偏向锁，轻量级锁，重量级锁的加锁释放锁的过程本来想写一下的但是反复写了几次都觉得说的不够清楚，\n      所以就暂时不写出来误导人了，主要还有些细节没有验证清楚\n    4.验证锁的切换可以借用jol输出对象头信息观察锁标志的变化\n\n### 参考\n> [盘一盘 synchronized （一）—— 从打印Java对象头说起](https://www.cnblogs.com/LemonFive/p/11246086.html)\n> [深入理解synchronized底层源码](https://zhuanlan.zhihu.com/p/150791816)\n> 强烈推荐-》[死磕Synchronized底层实现--概论](https://github.com/farmerjohngit/myblog/issues/12)","source":"_posts/2020/08/synchronized1.md","raw":"---\ntitle: synchronized相关-对象头&锁机制\ndate: 2020-08-15 20:49:14\ntags: \n- 多线程\ncategories:\n- Java\n- 多线程\n---\n\n### 前言\n  \n  之前面试中有被问到synchronized及Java锁机制相关的问题，所以总结一下相关知识点。\n<!-- more -->\n\n### 对象头\n\n#### 对象头的结构\n  synchronized锁住的目标是Java中的对象，那么他到底依赖于什么控制的呢？\n  答案就是---对象头，他是对象在内存中的存储结构之一。\n  所以先来了解下对象头是啥样的：\n> 一般对象的对象头由两部分组成\n> 1.klass pointer(指针，指向其类元数据的信息),\n> 2.Mark word(存储对象的运行时数据，包括哈希码，锁状态等)\n> 如果是数组对象则还存有array length信息\n\n#### Mark word\n  对象头的三个结构中，与synchronized关联紧密的就是第二部分 Mark word。\n  因为他维护着对象的锁标记信息。\n\n{% img  /image/synchronized/synchronized2.png  '\"64位 Mark word结构\"' %}\n\n1.identity_hashcode：对象的Hash值，这里注意如果对象的identity_hashcode不为空，那么他是没法进入偏向锁状态的，因为内存空间被占用了\n2.age：GC分代年龄\n3.biased_lock：偏向锁标志\n4.lock：锁状态标志\n5.thread：偏向锁状态偏向的线程标识\n6.epoch：偏向时间戳\n7.pointer_to_lock_record：指向线程栈中Lock Record的指针\n8.pointer_to_heavyweight_monitor：指向堆中的monitor对象的指针\n\n  其中biased_block和lock即锁标识的信息:\n{% img  /image/synchronized/synchronized1.png  '\"锁状态标记\"' %}\n\n### 锁升级\n\n  对象头中记录了对象不同的锁状态，当触发了对应条件时就会引起其状态的变化，这个过程被称作锁升级。\n\n#### 偏向锁\n\n  当有线程获取到锁资源时就会升级为偏向锁，并在对象头中记录偏向的线程标识，也就是获取到锁资源的线程。\n  >引入偏向锁是因为在一个线程多次获取同一个锁的场景下，如果每次都按照竞争锁的方式去操作未免会造成平白的消耗。\n  >而偏向锁记录了当前拥有锁的线程的标识信息，当同一线程多次去获取该锁时可以直接依据该标识判断，从而减小获取锁的消耗。\n\n#### 轻量级锁\n\n  偏向锁是无竞争场景下的，假设这样一种情况：\n  thread1先获取到了某个对象的锁，thread2慢了一步，获取失败。\n  那么此时如何处理thread2？\n  这里的设计是按照乐观的设想，thread1会很快释放锁资源，所以将偏向锁升级为轻量级锁，让thread2自旋不断尝试获取锁资源。\n\n#### 重量级锁\n\n  轻量级锁是在乐观设想的前提下让获取失败的线程自旋等待。\n  但考虑到最坏的情况，thread1因为某些原因占用时间超出了可接受的范围，如果让thread2一直自旋，甚至后面又来了N个线程也在自旋，这样就浪费了大量的CPU资源，显然是不合理的。\n  所以当线程自旋一定次数还未获得锁资源时，轻量级锁就会升级为重量级锁，让这些尝试获取锁资源的线程通通阻塞，等待锁被释放后再唤醒他们。\n  >重量级锁是jdk1.6之前使用的锁机制，因为其底层依赖于互斥锁，涉及用户态和内核态的转换，进程的上下文切换等，性能影响较大，所以才引入偏向锁和轻量级锁来改善\n\n  关于偏向锁需要注意几点：\n  1). 因为无锁的内存结构中identity_hashcode与偏向锁中的thread的内存空间是冲突的，也就是两者只能存一个，当identity_hashcode不为空的时候，是无法偏向的，这时候会直接升级为轻量级锁\n  2). 有时候会发现状态是偏向锁，biased_lock也显示是1标识偏向锁，但其实thread是空的，这时候表示处于可以偏向的状态\n\n### 小结\n\n      为了写本篇文章着实找了许多博客参考，不过大部分都是一些概念，底层实现逻辑的描述较少。不过还\n    是对synchronized及锁机制有了更清晰的理解，这里照常做一下总结：\n    1.本文只介绍了对象头及synchronized相关的锁机制，如果想了解更多建议阅读参考中强烈推荐的那篇文章\n    2.关于synchronized的使用及理解，我认为主要把握住一点，他锁住的是对象(类对象或者实例对象)\n    3.偏向锁，轻量级锁，重量级锁的加锁释放锁的过程本来想写一下的但是反复写了几次都觉得说的不够清楚，\n      所以就暂时不写出来误导人了，主要还有些细节没有验证清楚\n    4.验证锁的切换可以借用jol输出对象头信息观察锁标志的变化\n\n### 参考\n> [盘一盘 synchronized （一）—— 从打印Java对象头说起](https://www.cnblogs.com/LemonFive/p/11246086.html)\n> [深入理解synchronized底层源码](https://zhuanlan.zhihu.com/p/150791816)\n> 强烈推荐-》[死磕Synchronized底层实现--概论](https://github.com/farmerjohngit/myblog/issues/12)","slug":"synchronized1","published":1,"updated":"2020-08-22T13:19:06.238Z","_id":"ckdvnrwaa0000sgb53izt5wer","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  之前面试中有被问到synchronized及Java锁机制相关的问题，所以总结一下相关知识点。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h3><h4 id=\"对象头的结构\"><a href=\"#对象头的结构\" class=\"headerlink\" title=\"对象头的结构\"></a>对象头的结构</h4><p>  synchronized锁住的目标是Java中的对象，那么他到底依赖于什么控制的呢？<br>  答案就是—对象头，他是对象在内存中的存储结构之一。<br>  所以先来了解下对象头是啥样的：</p>\n<blockquote>\n<p>一般对象的对象头由两部分组成<br>1.klass pointer(指针，指向其类元数据的信息),<br>2.Mark word(存储对象的运行时数据，包括哈希码，锁状态等)<br>如果是数组对象则还存有array length信息</p>\n</blockquote>\n<h4 id=\"Mark-word\"><a href=\"#Mark-word\" class=\"headerlink\" title=\"Mark word\"></a>Mark word</h4><p>  对象头的三个结构中，与synchronized关联紧密的就是第二部分 Mark word。<br>  因为他维护着对象的锁标记信息。</p>\n<img src=\"/image/synchronized/synchronized2.png\" class=\"\" title=\"64位 Mark word结构\">\n\n<p>1.identity_hashcode：对象的Hash值，这里注意如果对象的identity_hashcode不为空，那么他是没法进入偏向锁状态的，因为内存空间被占用了<br>2.age：GC分代年龄<br>3.biased_lock：偏向锁标志<br>4.lock：锁状态标志<br>5.thread：偏向锁状态偏向的线程标识<br>6.epoch：偏向时间戳<br>7.pointer_to_lock_record：指向线程栈中Lock Record的指针<br>8.pointer_to_heavyweight_monitor：指向堆中的monitor对象的指针</p>\n<p>  其中biased_block和lock即锁标识的信息:</p>\n<img src=\"/image/synchronized/synchronized1.png\" class=\"\" title=\"锁状态标记\">\n\n<h3 id=\"锁升级\"><a href=\"#锁升级\" class=\"headerlink\" title=\"锁升级\"></a>锁升级</h3><p>  对象头中记录了对象不同的锁状态，当触发了对应条件时就会引起其状态的变化，这个过程被称作锁升级。</p>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p>  当有线程获取到锁资源时就会升级为偏向锁，并在对象头中记录偏向的线程标识，也就是获取到锁资源的线程。</p>\n<blockquote>\n<p>引入偏向锁是因为在一个线程多次获取同一个锁的场景下，如果每次都按照竞争锁的方式去操作未免会造成平白的消耗。<br>而偏向锁记录了当前拥有锁的线程的标识信息，当同一线程多次去获取该锁时可以直接依据该标识判断，从而减小获取锁的消耗。</p>\n</blockquote>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><p>  偏向锁是无竞争场景下的，假设这样一种情况：<br>  thread1先获取到了某个对象的锁，thread2慢了一步，获取失败。<br>  那么此时如何处理thread2？<br>  这里的设计是按照乐观的设想，thread1会很快释放锁资源，所以将偏向锁升级为轻量级锁，让thread2自旋不断尝试获取锁资源。</p>\n<h4 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h4><p>  轻量级锁是在乐观设想的前提下让获取失败的线程自旋等待。<br>  但考虑到最坏的情况，thread1因为某些原因占用时间超出了可接受的范围，如果让thread2一直自旋，甚至后面又来了N个线程也在自旋，这样就浪费了大量的CPU资源，显然是不合理的。<br>  所以当线程自旋一定次数还未获得锁资源时，轻量级锁就会升级为重量级锁，让这些尝试获取锁资源的线程通通阻塞，等待锁被释放后再唤醒他们。</p>\n<blockquote>\n<p>重量级锁是jdk1.6之前使用的锁机制，因为其底层依赖于互斥锁，涉及用户态和内核态的转换，进程的上下文切换等，性能影响较大，所以才引入偏向锁和轻量级锁来改善</p>\n</blockquote>\n<p>  关于偏向锁需要注意几点：<br>  1). 因为无锁的内存结构中identity_hashcode与偏向锁中的thread的内存空间是冲突的，也就是两者只能存一个，当identity_hashcode不为空的时候，是无法偏向的，这时候会直接升级为轻量级锁<br>  2). 有时候会发现状态是偏向锁，biased_lock也显示是1标识偏向锁，但其实thread是空的，这时候表示处于可以偏向的状态</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  为了写本篇文章着实找了许多博客参考，不过大部分都是一些概念，底层实现逻辑的描述较少。不过还\n是对synchronized及锁机制有了更清晰的理解，这里照常做一下总结：\n1.本文只介绍了对象头及synchronized相关的锁机制，如果想了解更多建议阅读参考中强烈推荐的那篇文章\n2.关于synchronized的使用及理解，我认为主要把握住一点，他锁住的是对象(类对象或者实例对象)\n3.偏向锁，轻量级锁，重量级锁的加锁释放锁的过程本来想写一下的但是反复写了几次都觉得说的不够清楚，\n  所以就暂时不写出来误导人了，主要还有些细节没有验证清楚\n4.验证锁的切换可以借用jol输出对象头信息观察锁标志的变化</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://www.cnblogs.com/LemonFive/p/11246086.html\" target=\"_blank\" rel=\"noopener\">盘一盘 synchronized （一）—— 从打印Java对象头说起</a><br><a href=\"https://zhuanlan.zhihu.com/p/150791816\" target=\"_blank\" rel=\"noopener\">深入理解synchronized底层源码</a><br>强烈推荐-》<a href=\"https://github.com/farmerjohngit/myblog/issues/12\" target=\"_blank\" rel=\"noopener\">死磕Synchronized底层实现–概论</a></p>\n</blockquote>\n","site":{"data":{}},"length":1769,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  之前面试中有被问到synchronized及Java锁机制相关的问题，所以总结一下相关知识点。</p>","more":"<h3 id=\"对象头\"><a href=\"#对象头\" class=\"headerlink\" title=\"对象头\"></a>对象头</h3><h4 id=\"对象头的结构\"><a href=\"#对象头的结构\" class=\"headerlink\" title=\"对象头的结构\"></a>对象头的结构</h4><p>  synchronized锁住的目标是Java中的对象，那么他到底依赖于什么控制的呢？<br>  答案就是—对象头，他是对象在内存中的存储结构之一。<br>  所以先来了解下对象头是啥样的：</p>\n<blockquote>\n<p>一般对象的对象头由两部分组成<br>1.klass pointer(指针，指向其类元数据的信息),<br>2.Mark word(存储对象的运行时数据，包括哈希码，锁状态等)<br>如果是数组对象则还存有array length信息</p>\n</blockquote>\n<h4 id=\"Mark-word\"><a href=\"#Mark-word\" class=\"headerlink\" title=\"Mark word\"></a>Mark word</h4><p>  对象头的三个结构中，与synchronized关联紧密的就是第二部分 Mark word。<br>  因为他维护着对象的锁标记信息。</p>\n<img src=\"/image/synchronized/synchronized2.png\" class=\"\" title=\"64位 Mark word结构\">\n\n<p>1.identity_hashcode：对象的Hash值，这里注意如果对象的identity_hashcode不为空，那么他是没法进入偏向锁状态的，因为内存空间被占用了<br>2.age：GC分代年龄<br>3.biased_lock：偏向锁标志<br>4.lock：锁状态标志<br>5.thread：偏向锁状态偏向的线程标识<br>6.epoch：偏向时间戳<br>7.pointer_to_lock_record：指向线程栈中Lock Record的指针<br>8.pointer_to_heavyweight_monitor：指向堆中的monitor对象的指针</p>\n<p>  其中biased_block和lock即锁标识的信息:</p>\n<img src=\"/image/synchronized/synchronized1.png\" class=\"\" title=\"锁状态标记\">\n\n<h3 id=\"锁升级\"><a href=\"#锁升级\" class=\"headerlink\" title=\"锁升级\"></a>锁升级</h3><p>  对象头中记录了对象不同的锁状态，当触发了对应条件时就会引起其状态的变化，这个过程被称作锁升级。</p>\n<h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><p>  当有线程获取到锁资源时就会升级为偏向锁，并在对象头中记录偏向的线程标识，也就是获取到锁资源的线程。</p>\n<blockquote>\n<p>引入偏向锁是因为在一个线程多次获取同一个锁的场景下，如果每次都按照竞争锁的方式去操作未免会造成平白的消耗。<br>而偏向锁记录了当前拥有锁的线程的标识信息，当同一线程多次去获取该锁时可以直接依据该标识判断，从而减小获取锁的消耗。</p>\n</blockquote>\n<h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><p>  偏向锁是无竞争场景下的，假设这样一种情况：<br>  thread1先获取到了某个对象的锁，thread2慢了一步，获取失败。<br>  那么此时如何处理thread2？<br>  这里的设计是按照乐观的设想，thread1会很快释放锁资源，所以将偏向锁升级为轻量级锁，让thread2自旋不断尝试获取锁资源。</p>\n<h4 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h4><p>  轻量级锁是在乐观设想的前提下让获取失败的线程自旋等待。<br>  但考虑到最坏的情况，thread1因为某些原因占用时间超出了可接受的范围，如果让thread2一直自旋，甚至后面又来了N个线程也在自旋，这样就浪费了大量的CPU资源，显然是不合理的。<br>  所以当线程自旋一定次数还未获得锁资源时，轻量级锁就会升级为重量级锁，让这些尝试获取锁资源的线程通通阻塞，等待锁被释放后再唤醒他们。</p>\n<blockquote>\n<p>重量级锁是jdk1.6之前使用的锁机制，因为其底层依赖于互斥锁，涉及用户态和内核态的转换，进程的上下文切换等，性能影响较大，所以才引入偏向锁和轻量级锁来改善</p>\n</blockquote>\n<p>  关于偏向锁需要注意几点：<br>  1). 因为无锁的内存结构中identity_hashcode与偏向锁中的thread的内存空间是冲突的，也就是两者只能存一个，当identity_hashcode不为空的时候，是无法偏向的，这时候会直接升级为轻量级锁<br>  2). 有时候会发现状态是偏向锁，biased_lock也显示是1标识偏向锁，但其实thread是空的，这时候表示处于可以偏向的状态</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><pre><code>  为了写本篇文章着实找了许多博客参考，不过大部分都是一些概念，底层实现逻辑的描述较少。不过还\n是对synchronized及锁机制有了更清晰的理解，这里照常做一下总结：\n1.本文只介绍了对象头及synchronized相关的锁机制，如果想了解更多建议阅读参考中强烈推荐的那篇文章\n2.关于synchronized的使用及理解，我认为主要把握住一点，他锁住的是对象(类对象或者实例对象)\n3.偏向锁，轻量级锁，重量级锁的加锁释放锁的过程本来想写一下的但是反复写了几次都觉得说的不够清楚，\n  所以就暂时不写出来误导人了，主要还有些细节没有验证清楚\n4.验证锁的切换可以借用jol输出对象头信息观察锁标志的变化</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://www.cnblogs.com/LemonFive/p/11246086.html\" target=\"_blank\" rel=\"noopener\">盘一盘 synchronized （一）—— 从打印Java对象头说起</a><br><a href=\"https://zhuanlan.zhihu.com/p/150791816\" target=\"_blank\" rel=\"noopener\">深入理解synchronized底层源码</a><br>强烈推荐-》<a href=\"https://github.com/farmerjohngit/myblog/issues/12\" target=\"_blank\" rel=\"noopener\">死磕Synchronized底层实现–概论</a></p>\n</blockquote>"},{"title":"synchronized相关-加锁过程解析","date":"2020-08-27T13:17:19.000Z","_content":"\n### 前言\n\n  [上一章](https://rel-fly.com/2020/08/15/synchronized1/)总结了synchronized相关的对象头和锁机制，这一章就锁的加锁及升级过程总结一下。\n<!-- more -->\n\n### 偏向锁\n  \n  首先看一下偏向锁的几个例子：\n{% codeblock lang:java %}\n// 未偏向线程，可偏向状态\npublic void testOne() throws InterruptedException {\n    String object = \"ob\";\n    System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized3.png  '\"testOne()输出结果\"' %}\n\n  上例虽然并没有使用synchronized，但输出结果可以看到，锁标志仍然是'101'，不过表示偏向线程标识的位都是零说明此时并未偏向任何线程。\n  这种情况可以理解为此时锁处于“可偏向但还未偏向”的状态。\n\n{% codeblock lang:java %}\n// 偏向锁偏向占用线程\npublic void testTwo() throws InterruptedException {\n    String object = \"hello\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized4.png  '\"testTwo()输出结果\"' %}\n\n  testTwo()就展示了一个常见的单一线程占用锁资源的场景，可以看到开始锁标识是“可偏向但还未偏向”的状态。\n  而当进入同步代码块后，锁就偏向了当前线程。\n\n#### 加锁过程\n\n  1. 首次占用\n    首先，线程会在自己栈帧中存储一份对象头信息，作为CAS操作的期望值，这块空间被称为*Lock Word* 。如果CAS执行成功，即当前对象是无锁状态，则直接偏向。\n  2. 重入\n    当尝试占用时，发现偏向线程即为当前线程，则会在线程栈帧中再添加一个*Lock Word* ，但其存的对象头信息为空，与首次存的*Lock Word* 区分开。\n    这个新增的*Lock Word* 会作为重入的统计标识，每当退出一次则会清空一个*Lock Word* 表示一次释放。\n  3. 竞争\n    如果请求占用的锁已偏向且偏向的不是的当前线程，则会判断被偏向的线程是否存活或已释放锁：\n    a)线程存活且还在占用，则进行轻量级锁的升级\n    b)线程未存活或不再占用，则会先修改对象头为无锁状态，然后做轻量级锁的升级\n  \n\n  偏向锁不会主动释放，当偏向后，对象头就会一直处于偏向的状态，直到下一个来竞争的线程使其升级。\n{% codeblock lang:java %}\npublic void test() throws InterruptedException {\n    String object = \"hello\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(1000);\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread2:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(1000);\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized8.png  '\"thread1占用及结束后的对象头信息\"' %}\n\n{% img  /image/synchronized/synchronized9.png  '\"thread2占用及结束后的对象头信息\"' %}\n\n### 轻量级锁\n\n  出现轻量级锁会有两种情况，一种是正常的抢占偏向锁导致的升级，第二种就是从无锁状态直接到轻量级锁状态。\n{% codeblock lang:java %}\npublic void testThree() throws InterruptedException {\n    String object = \"123\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    // thread1先抢占到锁\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(100);\n    // thread2去竞争锁，此时导致偏向锁升级\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread2:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized5.png  '\"testThree()输出结果\"' %}\n\n{% codeblock lang:java %}\n// 无锁直接升级到轻量级锁\npublic void testFour() throws InterruptedException {\n    String object = \"Object\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized6.png  '\"testFour()输出结果\"' %}\n\n#### 加锁过程\n  \n  轻量级锁的加锁过程与偏向锁有点类似，也是基于*Lock Word* 去做CAS操作。\n  1. 首先在*Lock Word* 中存储一个空的*Mark Word* 对象，其中会存储指向锁对象的指针\n     然后将这个空的对象头作为期望值去做CAS操作\n\n  2. CAS成功：表示此时是无锁状态，直接占用，对象头中存储指向*Lock Word* 的指针，此时两者互相指向\n     \n  3. CAS失败：会先判断是否重入，是则在栈帧中增加一个*Lock Word* 表示重入，否则进行锁升级\n\n\n### 重量级锁\n\n{% codeblock lang:java %}\npublic void testFive() throws InterruptedException {\n    String object = \"hello\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread2:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized7.png  '\"testFive()输出结果\"' %}\n\n#### 重量级锁结构\n  \n  重量级锁与偏向锁，轻量级锁就有很大的差别了，当升级为重量级锁后，未占用的线程是处于阻塞状态的，他的实现是基于*Monitor* 的结构。\n\n  *Monitor* 中维护了一个阻塞队列用来存储被阻塞的线程信息，还有一个等待队列，当线程调用wait()方法后，就会释放锁进入等待队列。\n  {% img  /image/synchronized/synchronized10.png  '\"重量级锁结构\"' %}\n\n### 总结\n\n      为了清楚的理解synchronized中锁升级及加锁流程，也很是看了很久博客和文档。算是大概理出了\n    加锁流程，不过还有很多细节没有弄清楚。\n    1. 测试时，定义的String对象内容如果是Object类似的关键字，就会跳过偏向锁，直接升级为轻量\n       级锁。(这种情况我了解的是当对象头的HashCode有值导致偏向锁偏向标识的空间被占用无法偏向\n       才会出现)\n    2. 偏向锁与轻量级锁都会在线程栈帧中Lock Word存储对象头信息用作CAS操作，这里我理解的是\n       用无锁状态的对象头当作期望值去尝试CAS，这样当对象头被释放时就能CAS成功\n    3. 理解synchronized的使用其实只要抓住他锁定的是对象就够了，关于锁升级主要是了解什么操作\n       会导致重量级锁出现，以尽量避免重量级锁\n\n> [synchronized相关-对象头&锁机制](https://rel-fly.com/2020/08/15/synchronized1/)\n","source":"_posts/2020/08/synchronized2.md","raw":"---\ntitle: synchronized相关-加锁过程解析\ndate: 2020-08-27 21:17:19\ntags:\n- 多线程\ncategories:\n- Java\n- 多线程\n---\n\n### 前言\n\n  [上一章](https://rel-fly.com/2020/08/15/synchronized1/)总结了synchronized相关的对象头和锁机制，这一章就锁的加锁及升级过程总结一下。\n<!-- more -->\n\n### 偏向锁\n  \n  首先看一下偏向锁的几个例子：\n{% codeblock lang:java %}\n// 未偏向线程，可偏向状态\npublic void testOne() throws InterruptedException {\n    String object = \"ob\";\n    System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized3.png  '\"testOne()输出结果\"' %}\n\n  上例虽然并没有使用synchronized，但输出结果可以看到，锁标志仍然是'101'，不过表示偏向线程标识的位都是零说明此时并未偏向任何线程。\n  这种情况可以理解为此时锁处于“可偏向但还未偏向”的状态。\n\n{% codeblock lang:java %}\n// 偏向锁偏向占用线程\npublic void testTwo() throws InterruptedException {\n    String object = \"hello\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized4.png  '\"testTwo()输出结果\"' %}\n\n  testTwo()就展示了一个常见的单一线程占用锁资源的场景，可以看到开始锁标识是“可偏向但还未偏向”的状态。\n  而当进入同步代码块后，锁就偏向了当前线程。\n\n#### 加锁过程\n\n  1. 首次占用\n    首先，线程会在自己栈帧中存储一份对象头信息，作为CAS操作的期望值，这块空间被称为*Lock Word* 。如果CAS执行成功，即当前对象是无锁状态，则直接偏向。\n  2. 重入\n    当尝试占用时，发现偏向线程即为当前线程，则会在线程栈帧中再添加一个*Lock Word* ，但其存的对象头信息为空，与首次存的*Lock Word* 区分开。\n    这个新增的*Lock Word* 会作为重入的统计标识，每当退出一次则会清空一个*Lock Word* 表示一次释放。\n  3. 竞争\n    如果请求占用的锁已偏向且偏向的不是的当前线程，则会判断被偏向的线程是否存活或已释放锁：\n    a)线程存活且还在占用，则进行轻量级锁的升级\n    b)线程未存活或不再占用，则会先修改对象头为无锁状态，然后做轻量级锁的升级\n  \n\n  偏向锁不会主动释放，当偏向后，对象头就会一直处于偏向的状态，直到下一个来竞争的线程使其升级。\n{% codeblock lang:java %}\npublic void test() throws InterruptedException {\n    String object = \"hello\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(1000);\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread2:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(1000);\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized8.png  '\"thread1占用及结束后的对象头信息\"' %}\n\n{% img  /image/synchronized/synchronized9.png  '\"thread2占用及结束后的对象头信息\"' %}\n\n### 轻量级锁\n\n  出现轻量级锁会有两种情况，一种是正常的抢占偏向锁导致的升级，第二种就是从无锁状态直接到轻量级锁状态。\n{% codeblock lang:java %}\npublic void testThree() throws InterruptedException {\n    String object = \"123\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    // thread1先抢占到锁\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(100);\n    // thread2去竞争锁，此时导致偏向锁升级\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread2:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized5.png  '\"testThree()输出结果\"' %}\n\n{% codeblock lang:java %}\n// 无锁直接升级到轻量级锁\npublic void testFour() throws InterruptedException {\n    String object = \"Object\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized6.png  '\"testFour()输出结果\"' %}\n\n#### 加锁过程\n  \n  轻量级锁的加锁过程与偏向锁有点类似，也是基于*Lock Word* 去做CAS操作。\n  1. 首先在*Lock Word* 中存储一个空的*Mark Word* 对象，其中会存储指向锁对象的指针\n     然后将这个空的对象头作为期望值去做CAS操作\n\n  2. CAS成功：表示此时是无锁状态，直接占用，对象头中存储指向*Lock Word* 的指针，此时两者互相指向\n     \n  3. CAS失败：会先判断是否重入，是则在栈帧中增加一个*Lock Word* 表示重入，否则进行锁升级\n\n\n### 重量级锁\n\n{% codeblock lang:java %}\npublic void testFive() throws InterruptedException {\n    String object = \"hello\";\n    System.out.println(\"master:\" + ClassLayout.parseInstance(object).toPrintable());\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread1:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    threadPoolExecutor.execute(() -> {\n        synchronized (object) {\n            System.out.println(\"thread2:\" + ClassLayout.parseInstance(object).toPrintable());\n        }\n    });\n    Thread.sleep(10000);\n}\n{% endcodeblock %}\n\n{% img  /image/synchronized/synchronized7.png  '\"testFive()输出结果\"' %}\n\n#### 重量级锁结构\n  \n  重量级锁与偏向锁，轻量级锁就有很大的差别了，当升级为重量级锁后，未占用的线程是处于阻塞状态的，他的实现是基于*Monitor* 的结构。\n\n  *Monitor* 中维护了一个阻塞队列用来存储被阻塞的线程信息，还有一个等待队列，当线程调用wait()方法后，就会释放锁进入等待队列。\n  {% img  /image/synchronized/synchronized10.png  '\"重量级锁结构\"' %}\n\n### 总结\n\n      为了清楚的理解synchronized中锁升级及加锁流程，也很是看了很久博客和文档。算是大概理出了\n    加锁流程，不过还有很多细节没有弄清楚。\n    1. 测试时，定义的String对象内容如果是Object类似的关键字，就会跳过偏向锁，直接升级为轻量\n       级锁。(这种情况我了解的是当对象头的HashCode有值导致偏向锁偏向标识的空间被占用无法偏向\n       才会出现)\n    2. 偏向锁与轻量级锁都会在线程栈帧中Lock Word存储对象头信息用作CAS操作，这里我理解的是\n       用无锁状态的对象头当作期望值去尝试CAS，这样当对象头被释放时就能CAS成功\n    3. 理解synchronized的使用其实只要抓住他锁定的是对象就够了，关于锁升级主要是了解什么操作\n       会导致重量级锁出现，以尽量避免重量级锁\n\n> [synchronized相关-对象头&锁机制](https://rel-fly.com/2020/08/15/synchronized1/)\n","slug":"synchronized2","published":1,"updated":"2020-11-09T14:26:38.397Z","_id":"ckecwk71s0000b4b5h2dh4rbw","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  <a href=\"https://rel-fly.com/2020/08/15/synchronized1/\">上一章</a>总结了synchronized相关的对象头和锁机制，这一章就锁的加锁及升级过程总结一下。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><p>  首先看一下偏向锁的几个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未偏向线程，可偏向状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOne</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"ob\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized3.png\" class=\"\" title=\"testOne()输出结果\">\n\n<p>  上例虽然并没有使用synchronized，但输出结果可以看到，锁标志仍然是’101’，不过表示偏向线程标识的位都是零说明此时并未偏向任何线程。<br>  这种情况可以理解为此时锁处于“可偏向但还未偏向”的状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 偏向锁偏向占用线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTwo</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized4.png\" class=\"\" title=\"testTwo()输出结果\">\n\n<p>  testTwo()就展示了一个常见的单一线程占用锁资源的场景，可以看到开始锁标识是“可偏向但还未偏向”的状态。<br>  而当进入同步代码块后，锁就偏向了当前线程。</p>\n<h4 id=\"加锁过程\"><a href=\"#加锁过程\" class=\"headerlink\" title=\"加锁过程\"></a>加锁过程</h4><ol>\n<li>首次占用<br>首先，线程会在自己栈帧中存储一份对象头信息，作为CAS操作的期望值，这块空间被称为<em>Lock Word</em> 。如果CAS执行成功，即当前对象是无锁状态，则直接偏向。</li>\n<li>重入<br>当尝试占用时，发现偏向线程即为当前线程，则会在线程栈帧中再添加一个<em>Lock Word</em> ，但其存的对象头信息为空，与首次存的<em>Lock Word</em> 区分开。<br>这个新增的<em>Lock Word</em> 会作为重入的统计标识，每当退出一次则会清空一个<em>Lock Word</em> 表示一次释放。</li>\n<li>竞争<br>如果请求占用的锁已偏向且偏向的不是的当前线程，则会判断被偏向的线程是否存活或已释放锁：<br>a)线程存活且还在占用，则进行轻量级锁的升级<br>b)线程未存活或不再占用，则会先修改对象头为无锁状态，然后做轻量级锁的升级</li>\n</ol>\n<p>  偏向锁不会主动释放，当偏向后，对象头就会一直处于偏向的状态，直到下一个来竞争的线程使其升级。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread2:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized8.png\" class=\"\" title=\"thread1占用及结束后的对象头信息\">\n\n<img src=\"/image/synchronized/synchronized9.png\" class=\"\" title=\"thread2占用及结束后的对象头信息\">\n\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><p>  出现轻量级锁会有两种情况，一种是正常的抢占偏向锁导致的升级，第二种就是从无锁状态直接到轻量级锁状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testThree</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    <span class=\"comment\">// thread1先抢占到锁</span></span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"comment\">// thread2去竞争锁，此时导致偏向锁升级</span></span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread2:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized5.png\" class=\"\" title=\"testThree()输出结果\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无锁直接升级到轻量级锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testFour</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"Object\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized6.png\" class=\"\" title=\"testFour()输出结果\">\n\n<h4 id=\"加锁过程-1\"><a href=\"#加锁过程-1\" class=\"headerlink\" title=\"加锁过程\"></a>加锁过程</h4><p>  轻量级锁的加锁过程与偏向锁有点类似，也是基于<em>Lock Word</em> 去做CAS操作。</p>\n<ol>\n<li><p>首先在<em>Lock Word</em> 中存储一个空的<em>Mark Word</em> 对象，其中会存储指向锁对象的指针<br>然后将这个空的对象头作为期望值去做CAS操作</p>\n</li>\n<li><p>CAS成功：表示此时是无锁状态，直接占用，对象头中存储指向<em>Lock Word</em> 的指针，此时两者互相指向</p>\n</li>\n<li><p>CAS失败：会先判断是否重入，是则在栈帧中增加一个<em>Lock Word</em> 表示重入，否则进行锁升级</p>\n</li>\n</ol>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testFive</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread2:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized7.png\" class=\"\" title=\"testFive()输出结果\">\n\n<h4 id=\"重量级锁结构\"><a href=\"#重量级锁结构\" class=\"headerlink\" title=\"重量级锁结构\"></a>重量级锁结构</h4><p>  重量级锁与偏向锁，轻量级锁就有很大的差别了，当升级为重量级锁后，未占用的线程是处于阻塞状态的，他的实现是基于<em>Monitor</em> 的结构。</p>\n<p>  <em>Monitor</em> 中维护了一个阻塞队列用来存储被阻塞的线程信息，还有一个等待队列，当线程调用wait()方法后，就会释放锁进入等待队列。<br>  <img src=\"/image/synchronized/synchronized10.png\" class=\"\" title=\"重量级锁结构\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  为了清楚的理解synchronized中锁升级及加锁流程，也很是看了很久博客和文档。算是大概理出了\n加锁流程，不过还有很多细节没有弄清楚。\n1. 测试时，定义的String对象内容如果是Object类似的关键字，就会跳过偏向锁，直接升级为轻量\n   级锁。(这种情况我了解的是当对象头的HashCode有值导致偏向锁偏向标识的空间被占用无法偏向\n   才会出现)\n2. 偏向锁与轻量级锁都会在线程栈帧中Lock Word存储对象头信息用作CAS操作，这里我理解的是\n   用无锁状态的对象头当作期望值去尝试CAS，这样当对象头被释放时就能CAS成功\n3. 理解synchronized的使用其实只要抓住他锁定的是对象就够了，关于锁升级主要是了解什么操作\n   会导致重量级锁出现，以尽量避免重量级锁</code></pre><blockquote>\n<p><a href=\"https://rel-fly.com/2020/08/15/synchronized1/\">synchronized相关-对象头&amp;锁机制</a></p>\n</blockquote>\n","site":{"data":{}},"length":1349,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  <a href=\"https://rel-fly.com/2020/08/15/synchronized1/\">上一章</a>总结了synchronized相关的对象头和锁机制，这一章就锁的加锁及升级过程总结一下。</p>","more":"<h3 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h3><p>  首先看一下偏向锁的几个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未偏向线程，可偏向状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testOne</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"ob\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized3.png\" class=\"\" title=\"testOne()输出结果\">\n\n<p>  上例虽然并没有使用synchronized，但输出结果可以看到，锁标志仍然是’101’，不过表示偏向线程标识的位都是零说明此时并未偏向任何线程。<br>  这种情况可以理解为此时锁处于“可偏向但还未偏向”的状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 偏向锁偏向占用线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTwo</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized4.png\" class=\"\" title=\"testTwo()输出结果\">\n\n<p>  testTwo()就展示了一个常见的单一线程占用锁资源的场景，可以看到开始锁标识是“可偏向但还未偏向”的状态。<br>  而当进入同步代码块后，锁就偏向了当前线程。</p>\n<h4 id=\"加锁过程\"><a href=\"#加锁过程\" class=\"headerlink\" title=\"加锁过程\"></a>加锁过程</h4><ol>\n<li>首次占用<br>首先，线程会在自己栈帧中存储一份对象头信息，作为CAS操作的期望值，这块空间被称为<em>Lock Word</em> 。如果CAS执行成功，即当前对象是无锁状态，则直接偏向。</li>\n<li>重入<br>当尝试占用时，发现偏向线程即为当前线程，则会在线程栈帧中再添加一个<em>Lock Word</em> ，但其存的对象头信息为空，与首次存的<em>Lock Word</em> 区分开。<br>这个新增的<em>Lock Word</em> 会作为重入的统计标识，每当退出一次则会清空一个<em>Lock Word</em> 表示一次释放。</li>\n<li>竞争<br>如果请求占用的锁已偏向且偏向的不是的当前线程，则会判断被偏向的线程是否存活或已释放锁：<br>a)线程存活且还在占用，则进行轻量级锁的升级<br>b)线程未存活或不再占用，则会先修改对象头为无锁状态，然后做轻量级锁的升级</li>\n</ol>\n<p>  偏向锁不会主动释放，当偏向后，对象头就会一直处于偏向的状态，直到下一个来竞争的线程使其升级。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread2:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized8.png\" class=\"\" title=\"thread1占用及结束后的对象头信息\">\n\n<img src=\"/image/synchronized/synchronized9.png\" class=\"\" title=\"thread2占用及结束后的对象头信息\">\n\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><p>  出现轻量级锁会有两种情况，一种是正常的抢占偏向锁导致的升级，第二种就是从无锁状态直接到轻量级锁状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testThree</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    <span class=\"comment\">// thread1先抢占到锁</span></span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"comment\">// thread2去竞争锁，此时导致偏向锁升级</span></span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread2:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized5.png\" class=\"\" title=\"testThree()输出结果\">\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无锁直接升级到轻量级锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testFour</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"Object\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized6.png\" class=\"\" title=\"testFour()输出结果\">\n\n<h4 id=\"加锁过程-1\"><a href=\"#加锁过程-1\" class=\"headerlink\" title=\"加锁过程\"></a>加锁过程</h4><p>  轻量级锁的加锁过程与偏向锁有点类似，也是基于<em>Lock Word</em> 去做CAS操作。</p>\n<ol>\n<li><p>首先在<em>Lock Word</em> 中存储一个空的<em>Mark Word</em> 对象，其中会存储指向锁对象的指针<br>然后将这个空的对象头作为期望值去做CAS操作</p>\n</li>\n<li><p>CAS成功：表示此时是无锁状态，直接占用，对象头中存储指向<em>Lock Word</em> 的指针，此时两者互相指向</p>\n</li>\n<li><p>CAS失败：会先判断是否重入，是则在栈帧中增加一个<em>Lock Word</em> 表示重入，否则进行锁升级</p>\n</li>\n</ol>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testFive</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    String object = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"master:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread1:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread2:\"</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">10000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<img src=\"/image/synchronized/synchronized7.png\" class=\"\" title=\"testFive()输出结果\">\n\n<h4 id=\"重量级锁结构\"><a href=\"#重量级锁结构\" class=\"headerlink\" title=\"重量级锁结构\"></a>重量级锁结构</h4><p>  重量级锁与偏向锁，轻量级锁就有很大的差别了，当升级为重量级锁后，未占用的线程是处于阻塞状态的，他的实现是基于<em>Monitor</em> 的结构。</p>\n<p>  <em>Monitor</em> 中维护了一个阻塞队列用来存储被阻塞的线程信息，还有一个等待队列，当线程调用wait()方法后，就会释放锁进入等待队列。<br>  <img src=\"/image/synchronized/synchronized10.png\" class=\"\" title=\"重量级锁结构\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  为了清楚的理解synchronized中锁升级及加锁流程，也很是看了很久博客和文档。算是大概理出了\n加锁流程，不过还有很多细节没有弄清楚。\n1. 测试时，定义的String对象内容如果是Object类似的关键字，就会跳过偏向锁，直接升级为轻量\n   级锁。(这种情况我了解的是当对象头的HashCode有值导致偏向锁偏向标识的空间被占用无法偏向\n   才会出现)\n2. 偏向锁与轻量级锁都会在线程栈帧中Lock Word存储对象头信息用作CAS操作，这里我理解的是\n   用无锁状态的对象头当作期望值去尝试CAS，这样当对象头被释放时就能CAS成功\n3. 理解synchronized的使用其实只要抓住他锁定的是对象就够了，关于锁升级主要是了解什么操作\n   会导致重量级锁出现，以尽量避免重量级锁</code></pre><blockquote>\n<p><a href=\"https://rel-fly.com/2020/08/15/synchronized1/\">synchronized相关-对象头&amp;锁机制</a></p>\n</blockquote>"},{"title":"JUC-Lock(jdk1.8)","date":"2020-09-12T08:43:23.000Z","_content":"\n### 前言\n\n   Lock是JUC包下定义了锁相关方法的接口，相对于synchronized，其提供了更多的锁功能，如响应中断，超时锁等。\n   本章就基于Lock及Condition的使用和实现原理做一个学习总结。\n<!-- more -->\n\n### Lock与synchronized\n\n#### synchronized\n\n1. 基于JVM实现的非同步锁，锁释放由虚拟机完成，死锁可能性较低\n2. 使用wait/notify控制线程的等待和唤醒\n3. 提供锁升级方案提升性能\n4. 无法提供响应中断，超时锁等功能\n\n#### Lock\n\n1. 利用CAS和代码逻辑实现\n2. 提供了synchronized没有的很多功能\n3. 锁的控制全由开发者自己操作，容易因没有释放锁而导致死锁\t \n\n### 四种获取锁的方法\n\n1. void lock()\n   *lock()*方法是最常用的获取锁的方法，使用该方法会一直尝试获取锁，直到获取成功。\n{% codeblock lang:java %}\npublic void testLock() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    lock.lock();\n    threadPoolExecutor.execute(()->{\n        logger.info(\"尝试获取锁\");\n        lock.lock();\n        logger.info(\"获取到锁\");\n        lock.unlock();\n    });\n    Thread.sleep(5000);\n    logger.info(\"过去了5S\");\n    lock.unlock();\n}\n{% endcodeblock %}\n{% img  /image/lock/lock1.png  '\"lock()方法\"' %}\n\n2. void lockInterruptibly() throws InterruptedException\n   响应线程中断，当线程中断时，会停止获取锁的尝试并抛出中断异常，如果线程没有发生中断则和*lock()*方法一样。\n{% codeblock lang:java %}\npublic void testLock() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    lock.lock();\n    Thread thread = new Thread(() -> {\n        logger.info(\"尝试获取锁···\");\n        try {\n            lock.lockInterruptibly();\n        } catch (InterruptedException e) {\n            logger.info(\"中断\");\n        }\n        lock.unlock();\n    });\n    thread.start();\n    Thread.sleep(5000);\n    logger.info(\"过去了5S\");\n    thread.interrupt();\n    lock.unlock();\n}\n{% endcodeblock %}\n{% img  /image/lock/lock2.png  '\"lockInterruptibly()方法\"' %}\n\n3. boolean tryLock()\n   *tryLock()*与*lock()*不一样，他只会尝试一次，如果成功则占用锁，失败则不再尝试。\n{% codeblock lang:java %}\npublic void testLock() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    lock.lock();\n    threadPoolExecutor.execute(() -> {\n        logger.info(\"1尝试获取锁···\");\n        boolean result = lock.tryLock();\n        logger.info(\"1获取结果：{}\", result);\n        if (result) {\n            logger.info(\"1获取成功\");\n            lock.unlock();\n        }\n    });\n    threadPoolExecutor.execute(() -> {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        logger.info(\"2尝试获取锁···\");\n        boolean result = lock.tryLock();\n        logger.info(\"2获取结果：{}\", result);\n        if (result) {\n            logger.info(\"2获取成功\");\n            lock.unlock();\n        }\n    });\n    Thread.sleep(5000);\n    logger.info(\"过去了5S\");\n    lock.unlock();\n}\n{% endcodeblock %}\n{% img  /image/lock/lock3.png  '\"tryLock()方法\"' %}\n\n4. boolean tryLock(long time, TimeUnit unit) throws InterruptedException\n   本方法在*tryLock()*的基础上设置了一个等待时间，在限定时间内会一直等待锁释放，超过了就不再尝试获取锁。另外，本方法也是和*lockInterruptibly()*一样响应线程中断的。\n{% codeblock lang:java %}\npublic void testLock() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    lock.lock();\n    Thread thread1 = new Thread(() -> {\n        logger.info(\"1尝试获取锁···\");\n        boolean result = false;\n        try {\n            result = lock.tryLock(6, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        logger.info(\"1获取结果：{}\", result);\n        if (result) {\n            logger.info(\"1获取成功\");\n            lock.unlock();\n        }\n    });\n    Thread thread2 = new Thread(() -> {\n        logger.info(\"2尝试获取锁···\");\n        boolean result = false;\n        try {\n            result = lock.tryLock(7, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        logger.info(\"2获取结果：{}\", result);\n        if (result) {\n            logger.info(\"2获取成功\");\n            lock.unlock();\n        }\n    });\n    thread1.start();\n    thread2.start();\n    Thread.sleep(5000);\n    thread1.interrupt();\n    logger.info(\"过去了5S\");\n    lock.unlock();\n}\n{% endcodeblock %}\n{% img  /image/lock/lock4.png  '\"tryLock(long time, TimeUnit unit)方法\"' %}\n\n### Condition\n\n  正如synchronized能够通过wait/notify控制线程等待/唤醒一样，Lock也有配套的Condition配合控制线程。\n  当抢占到lock锁资源时，便可使用lock中的Condition的方法控制线程。就像进入synchronized同步块后便可使用wait/notify方法一样。\n\n#### 方法介绍\n\n1. void await()\n   最常用的等待方法，线程会一直等待直到有另一个线程调用*signal()*唤醒他，如果线程中断则抛出异常。\n\n2. void awaitUninterruptibly()\n   与await()相似，不同的是当检查到当前线程中断，会进入一个安全的中断方法而不是抛出异常。\n\n3. long awaitNanos(long nanosTimeout) throws InterruptedException\n   与await()的不同是会设定一个等待时间，只在这个时间段内等待。\n\n4. boolean awaitUntil(Date deadline) throws InterruptedException\n   与awaitNanos(long n)类似，不过其设定的是一个时间点。\n\n5. void signal()\n   唤醒方法，唤醒队列的头节点\n\n6. void signalAll()\n   唤醒方法，唤醒队列中所有节点\n\n#### Condition使用\n\n1. 线程等待唤醒\n{% codeblock lang:java %}\npublic void testCondition() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    Condition condition = lock.newCondition();\n    threadPoolExecutor.execute(()->{\n        logger.info(\"尝试获取锁···\");\n        lock.lock();\n        logger.info(\"获取成功\");\n        try {\n            condition.await();\n            logger.info(\"苏醒\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        lock.unlock();\n    });\n    Thread.sleep(5000);\n    logger.info(\"过了5s···\");\n    lock.lock();\n    logger.info(\"master获取成功\");\n    condition.signal();\n    logger.info(\"唤醒等待线程···\");\n    lock.unlock();\n    Thread.sleep(5000);\n}\n{% endcodeblock %}\n{% img  /image/lock/lock5.png  '\"Condition演示1\"' %}\n\n2. 多个Condition\n{% codeblock lang:java %}\npublic void testCondition() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    Condition conditionOne = lock.newCondition();\n    Condition conditionTwo = lock.newCondition();\n    threadPoolExecutor.execute(() -> {\n        logger.info(\"1尝试获取锁···\");\n        lock.lock();\n        logger.info(\"1获取成功\");\n        try {\n            conditionOne.await();\n            logger.info(\"1苏醒\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        lock.unlock();\n    });\n    threadPoolExecutor.execute(() -> {\n        logger.info(\"2尝试获取锁···\");\n        lock.lock();\n        logger.info(\"2获取成功\");\n        try {\n            conditionTwo.await();\n            logger.info(\"2苏醒\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        lock.unlock();\n    });\n    Thread.sleep(5000);\n    logger.info(\"过了5s···\");\n    lock.lock();\n    logger.info(\"master获取成功\");\n    conditionOne.signal();\n    logger.info(\"唤醒等待线程1···\");\n    lock.unlock();\n    //---------------------------------\n    Thread.sleep(5000);\n    logger.info(\"又过了5s···\");\n    lock.lock();\n    logger.info(\"master获取成功\");\n    conditionTwo.signal();\n    logger.info(\"唤醒等待线程2···\");\n    lock.unlock();\n    Thread.sleep(5000);\n}\n{% endcodeblock %}\n{% img  /image/lock/lock6.png  '\"Condition演示2\"' %}\n\n  可以看到，相对synchronized和wait，Lock和Condition的组合显然更加灵活和强大。\n  一个Lock可以通过*newCondition()*同时拥有多个等待队列，互不干涉影响。阻塞队列正是利用这种方式实现放入/弹出的控制。\n\n\n","source":"_posts/2020/09/lock1.md","raw":"---\ntitle: JUC-Lock(jdk1.8)\ndate: 2020-09-12 16:43:23\ntags:\n- JUC\ncategories:\n- Java\n- JUC\n---\n\n### 前言\n\n   Lock是JUC包下定义了锁相关方法的接口，相对于synchronized，其提供了更多的锁功能，如响应中断，超时锁等。\n   本章就基于Lock及Condition的使用和实现原理做一个学习总结。\n<!-- more -->\n\n### Lock与synchronized\n\n#### synchronized\n\n1. 基于JVM实现的非同步锁，锁释放由虚拟机完成，死锁可能性较低\n2. 使用wait/notify控制线程的等待和唤醒\n3. 提供锁升级方案提升性能\n4. 无法提供响应中断，超时锁等功能\n\n#### Lock\n\n1. 利用CAS和代码逻辑实现\n2. 提供了synchronized没有的很多功能\n3. 锁的控制全由开发者自己操作，容易因没有释放锁而导致死锁\t \n\n### 四种获取锁的方法\n\n1. void lock()\n   *lock()*方法是最常用的获取锁的方法，使用该方法会一直尝试获取锁，直到获取成功。\n{% codeblock lang:java %}\npublic void testLock() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    lock.lock();\n    threadPoolExecutor.execute(()->{\n        logger.info(\"尝试获取锁\");\n        lock.lock();\n        logger.info(\"获取到锁\");\n        lock.unlock();\n    });\n    Thread.sleep(5000);\n    logger.info(\"过去了5S\");\n    lock.unlock();\n}\n{% endcodeblock %}\n{% img  /image/lock/lock1.png  '\"lock()方法\"' %}\n\n2. void lockInterruptibly() throws InterruptedException\n   响应线程中断，当线程中断时，会停止获取锁的尝试并抛出中断异常，如果线程没有发生中断则和*lock()*方法一样。\n{% codeblock lang:java %}\npublic void testLock() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    lock.lock();\n    Thread thread = new Thread(() -> {\n        logger.info(\"尝试获取锁···\");\n        try {\n            lock.lockInterruptibly();\n        } catch (InterruptedException e) {\n            logger.info(\"中断\");\n        }\n        lock.unlock();\n    });\n    thread.start();\n    Thread.sleep(5000);\n    logger.info(\"过去了5S\");\n    thread.interrupt();\n    lock.unlock();\n}\n{% endcodeblock %}\n{% img  /image/lock/lock2.png  '\"lockInterruptibly()方法\"' %}\n\n3. boolean tryLock()\n   *tryLock()*与*lock()*不一样，他只会尝试一次，如果成功则占用锁，失败则不再尝试。\n{% codeblock lang:java %}\npublic void testLock() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    lock.lock();\n    threadPoolExecutor.execute(() -> {\n        logger.info(\"1尝试获取锁···\");\n        boolean result = lock.tryLock();\n        logger.info(\"1获取结果：{}\", result);\n        if (result) {\n            logger.info(\"1获取成功\");\n            lock.unlock();\n        }\n    });\n    threadPoolExecutor.execute(() -> {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        logger.info(\"2尝试获取锁···\");\n        boolean result = lock.tryLock();\n        logger.info(\"2获取结果：{}\", result);\n        if (result) {\n            logger.info(\"2获取成功\");\n            lock.unlock();\n        }\n    });\n    Thread.sleep(5000);\n    logger.info(\"过去了5S\");\n    lock.unlock();\n}\n{% endcodeblock %}\n{% img  /image/lock/lock3.png  '\"tryLock()方法\"' %}\n\n4. boolean tryLock(long time, TimeUnit unit) throws InterruptedException\n   本方法在*tryLock()*的基础上设置了一个等待时间，在限定时间内会一直等待锁释放，超过了就不再尝试获取锁。另外，本方法也是和*lockInterruptibly()*一样响应线程中断的。\n{% codeblock lang:java %}\npublic void testLock() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    lock.lock();\n    Thread thread1 = new Thread(() -> {\n        logger.info(\"1尝试获取锁···\");\n        boolean result = false;\n        try {\n            result = lock.tryLock(6, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        logger.info(\"1获取结果：{}\", result);\n        if (result) {\n            logger.info(\"1获取成功\");\n            lock.unlock();\n        }\n    });\n    Thread thread2 = new Thread(() -> {\n        logger.info(\"2尝试获取锁···\");\n        boolean result = false;\n        try {\n            result = lock.tryLock(7, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        logger.info(\"2获取结果：{}\", result);\n        if (result) {\n            logger.info(\"2获取成功\");\n            lock.unlock();\n        }\n    });\n    thread1.start();\n    thread2.start();\n    Thread.sleep(5000);\n    thread1.interrupt();\n    logger.info(\"过去了5S\");\n    lock.unlock();\n}\n{% endcodeblock %}\n{% img  /image/lock/lock4.png  '\"tryLock(long time, TimeUnit unit)方法\"' %}\n\n### Condition\n\n  正如synchronized能够通过wait/notify控制线程等待/唤醒一样，Lock也有配套的Condition配合控制线程。\n  当抢占到lock锁资源时，便可使用lock中的Condition的方法控制线程。就像进入synchronized同步块后便可使用wait/notify方法一样。\n\n#### 方法介绍\n\n1. void await()\n   最常用的等待方法，线程会一直等待直到有另一个线程调用*signal()*唤醒他，如果线程中断则抛出异常。\n\n2. void awaitUninterruptibly()\n   与await()相似，不同的是当检查到当前线程中断，会进入一个安全的中断方法而不是抛出异常。\n\n3. long awaitNanos(long nanosTimeout) throws InterruptedException\n   与await()的不同是会设定一个等待时间，只在这个时间段内等待。\n\n4. boolean awaitUntil(Date deadline) throws InterruptedException\n   与awaitNanos(long n)类似，不过其设定的是一个时间点。\n\n5. void signal()\n   唤醒方法，唤醒队列的头节点\n\n6. void signalAll()\n   唤醒方法，唤醒队列中所有节点\n\n#### Condition使用\n\n1. 线程等待唤醒\n{% codeblock lang:java %}\npublic void testCondition() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    Condition condition = lock.newCondition();\n    threadPoolExecutor.execute(()->{\n        logger.info(\"尝试获取锁···\");\n        lock.lock();\n        logger.info(\"获取成功\");\n        try {\n            condition.await();\n            logger.info(\"苏醒\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        lock.unlock();\n    });\n    Thread.sleep(5000);\n    logger.info(\"过了5s···\");\n    lock.lock();\n    logger.info(\"master获取成功\");\n    condition.signal();\n    logger.info(\"唤醒等待线程···\");\n    lock.unlock();\n    Thread.sleep(5000);\n}\n{% endcodeblock %}\n{% img  /image/lock/lock5.png  '\"Condition演示1\"' %}\n\n2. 多个Condition\n{% codeblock lang:java %}\npublic void testCondition() throws InterruptedException {\n    Lock lock = new ReentrantLock();\n    Condition conditionOne = lock.newCondition();\n    Condition conditionTwo = lock.newCondition();\n    threadPoolExecutor.execute(() -> {\n        logger.info(\"1尝试获取锁···\");\n        lock.lock();\n        logger.info(\"1获取成功\");\n        try {\n            conditionOne.await();\n            logger.info(\"1苏醒\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        lock.unlock();\n    });\n    threadPoolExecutor.execute(() -> {\n        logger.info(\"2尝试获取锁···\");\n        lock.lock();\n        logger.info(\"2获取成功\");\n        try {\n            conditionTwo.await();\n            logger.info(\"2苏醒\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        lock.unlock();\n    });\n    Thread.sleep(5000);\n    logger.info(\"过了5s···\");\n    lock.lock();\n    logger.info(\"master获取成功\");\n    conditionOne.signal();\n    logger.info(\"唤醒等待线程1···\");\n    lock.unlock();\n    //---------------------------------\n    Thread.sleep(5000);\n    logger.info(\"又过了5s···\");\n    lock.lock();\n    logger.info(\"master获取成功\");\n    conditionTwo.signal();\n    logger.info(\"唤醒等待线程2···\");\n    lock.unlock();\n    Thread.sleep(5000);\n}\n{% endcodeblock %}\n{% img  /image/lock/lock6.png  '\"Condition演示2\"' %}\n\n  可以看到，相对synchronized和wait，Lock和Condition的组合显然更加灵活和强大。\n  一个Lock可以通过*newCondition()*同时拥有多个等待队列，互不干涉影响。阻塞队列正是利用这种方式实现放入/弹出的控制。\n\n\n","slug":"lock1","published":1,"updated":"2020-09-17T12:50:14.470Z","_id":"ckf0wn68h0000ucb5c19acpa0","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   Lock是JUC包下定义了锁相关方法的接口，相对于synchronized，其提供了更多的锁功能，如响应中断，超时锁等。<br>   本章就基于Lock及Condition的使用和实现原理做一个学习总结。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Lock与synchronized\"><a href=\"#Lock与synchronized\" class=\"headerlink\" title=\"Lock与synchronized\"></a>Lock与synchronized</h3><h4 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h4><ol>\n<li>基于JVM实现的非同步锁，锁释放由虚拟机完成，死锁可能性较低</li>\n<li>使用wait/notify控制线程的等待和唤醒</li>\n<li>提供锁升级方案提升性能</li>\n<li>无法提供响应中断，超时锁等功能</li>\n</ol>\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><ol>\n<li>利用CAS和代码逻辑实现</li>\n<li>提供了synchronized没有的很多功能</li>\n<li>锁的控制全由开发者自己操作，容易因没有释放锁而导致死锁     </li>\n</ol>\n<h3 id=\"四种获取锁的方法\"><a href=\"#四种获取锁的方法\" class=\"headerlink\" title=\"四种获取锁的方法\"></a>四种获取锁的方法</h3><ol>\n<li><p>void lock()<br><em>lock()</em>方法是最常用的获取锁的方法，使用该方法会一直尝试获取锁，直到获取成功。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"尝试获取锁\"</span>);</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"获取到锁\"</span>);</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过去了5S\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock1.png\" class=\"\" title=\"lock()方法\">\n</li>\n<li><p>void lockInterruptibly() throws InterruptedException<br>响应线程中断，当线程中断时，会停止获取锁的尝试并抛出中断异常，如果线程没有发生中断则和<em>lock()</em>方法一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lockInterruptibly();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"中断\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过去了5S\"</span>);</span><br><span class=\"line\">    thread.interrupt();</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock2.png\" class=\"\" title=\"lockInterruptibly()方法\">\n</li>\n<li><p>boolean tryLock()<br><em>tryLock()</em>与<em>lock()</em>不一样，他只会尝试一次，如果成功则占用锁，失败则不再尝试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = lock.tryLock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1获取结果：&#123;&#125;\"</span>, result);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"1获取成功\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = lock.tryLock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2获取结果：&#123;&#125;\"</span>, result);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"2获取成功\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过去了5S\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock3.png\" class=\"\" title=\"tryLock()方法\">\n</li>\n<li><p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException<br>本方法在<em>tryLock()</em>的基础上设置了一个等待时间，在限定时间内会一直等待锁释放，超过了就不再尝试获取锁。另外，本方法也是和<em>lockInterruptibly()</em>一样响应线程中断的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    Thread thread1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = lock.tryLock(<span class=\"number\">6</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1获取结果：&#123;&#125;\"</span>, result);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"1获取成功\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread thread2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = lock.tryLock(<span class=\"number\">7</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2获取结果：&#123;&#125;\"</span>, result);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"2获取成功\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread1.start();</span><br><span class=\"line\">    thread2.start();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    thread1.interrupt();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过去了5S\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock4.png\" class=\"\" title=\"tryLock(long time, TimeUnit unit)方法\">\n\n</li>\n</ol>\n<h3 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h3><p>  正如synchronized能够通过wait/notify控制线程等待/唤醒一样，Lock也有配套的Condition配合控制线程。<br>  当抢占到lock锁资源时，便可使用lock中的Condition的方法控制线程。就像进入synchronized同步块后便可使用wait/notify方法一样。</p>\n<h4 id=\"方法介绍\"><a href=\"#方法介绍\" class=\"headerlink\" title=\"方法介绍\"></a>方法介绍</h4><ol>\n<li><p>void await()<br>最常用的等待方法，线程会一直等待直到有另一个线程调用<em>signal()</em>唤醒他，如果线程中断则抛出异常。</p>\n</li>\n<li><p>void awaitUninterruptibly()<br>与await()相似，不同的是当检查到当前线程中断，会进入一个安全的中断方法而不是抛出异常。</p>\n</li>\n<li><p>long awaitNanos(long nanosTimeout) throws InterruptedException<br>与await()的不同是会设定一个等待时间，只在这个时间段内等待。</p>\n</li>\n<li><p>boolean awaitUntil(Date deadline) throws InterruptedException<br>与awaitNanos(long n)类似，不过其设定的是一个时间点。</p>\n</li>\n<li><p>void signal()<br>唤醒方法，唤醒队列的头节点</p>\n</li>\n<li><p>void signalAll()<br>唤醒方法，唤醒队列中所有节点</p>\n</li>\n</ol>\n<h4 id=\"Condition使用\"><a href=\"#Condition使用\" class=\"headerlink\" title=\"Condition使用\"></a>Condition使用</h4><ol>\n<li><p>线程等待唤醒</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCondition</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    Condition condition = lock.newCondition();</span><br><span class=\"line\">    threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"尝试获取锁···\"</span>);</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"获取成功\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            condition.await();</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"苏醒\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过了5s···\"</span>);</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"master获取成功\"</span>);</span><br><span class=\"line\">    condition.signal();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"唤醒等待线程···\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock5.png\" class=\"\" title=\"Condition演示1\">\n</li>\n<li><p>多个Condition</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCondition</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    Condition conditionOne = lock.newCondition();</span><br><span class=\"line\">    Condition conditionTwo = lock.newCondition();</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1尝试获取锁···\"</span>);</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1获取成功\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            conditionOne.await();</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"1苏醒\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2尝试获取锁···\"</span>);</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2获取成功\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            conditionTwo.await();</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"2苏醒\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过了5s···\"</span>);</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"master获取成功\"</span>);</span><br><span class=\"line\">    conditionOne.signal();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"唤醒等待线程1···\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">    <span class=\"comment\">//---------------------------------</span></span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"又过了5s···\"</span>);</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"master获取成功\"</span>);</span><br><span class=\"line\">    conditionTwo.signal();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"唤醒等待线程2···\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock6.png\" class=\"\" title=\"Condition演示2\">\n\n<p>可以看到，相对synchronized和wait，Lock和Condition的组合显然更加灵活和强大。<br>一个Lock可以通过<em>newCondition()</em>同时拥有多个等待队列，互不干涉影响。阻塞队列正是利用这种方式实现放入/弹出的控制。</p>\n</li>\n</ol>\n","site":{"data":{}},"length":1321,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   Lock是JUC包下定义了锁相关方法的接口，相对于synchronized，其提供了更多的锁功能，如响应中断，超时锁等。<br>   本章就基于Lock及Condition的使用和实现原理做一个学习总结。</p>","more":"<h3 id=\"Lock与synchronized\"><a href=\"#Lock与synchronized\" class=\"headerlink\" title=\"Lock与synchronized\"></a>Lock与synchronized</h3><h4 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h4><ol>\n<li>基于JVM实现的非同步锁，锁释放由虚拟机完成，死锁可能性较低</li>\n<li>使用wait/notify控制线程的等待和唤醒</li>\n<li>提供锁升级方案提升性能</li>\n<li>无法提供响应中断，超时锁等功能</li>\n</ol>\n<h4 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h4><ol>\n<li>利用CAS和代码逻辑实现</li>\n<li>提供了synchronized没有的很多功能</li>\n<li>锁的控制全由开发者自己操作，容易因没有释放锁而导致死锁     </li>\n</ol>\n<h3 id=\"四种获取锁的方法\"><a href=\"#四种获取锁的方法\" class=\"headerlink\" title=\"四种获取锁的方法\"></a>四种获取锁的方法</h3><ol>\n<li><p>void lock()<br><em>lock()</em>方法是最常用的获取锁的方法，使用该方法会一直尝试获取锁，直到获取成功。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"尝试获取锁\"</span>);</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"获取到锁\"</span>);</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过去了5S\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock1.png\" class=\"\" title=\"lock()方法\">\n</li>\n<li><p>void lockInterruptibly() throws InterruptedException<br>响应线程中断，当线程中断时，会停止获取锁的尝试并抛出中断异常，如果线程没有发生中断则和<em>lock()</em>方法一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    Thread thread = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            lock.lockInterruptibly();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"中断\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread.start();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过去了5S\"</span>);</span><br><span class=\"line\">    thread.interrupt();</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock2.png\" class=\"\" title=\"lockInterruptibly()方法\">\n</li>\n<li><p>boolean tryLock()<br><em>tryLock()</em>与<em>lock()</em>不一样，他只会尝试一次，如果成功则占用锁，失败则不再尝试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = lock.tryLock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1获取结果：&#123;&#125;\"</span>, result);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"1获取成功\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = lock.tryLock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2获取结果：&#123;&#125;\"</span>, result);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"2获取成功\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过去了5S\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock3.png\" class=\"\" title=\"tryLock()方法\">\n</li>\n<li><p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException<br>本方法在<em>tryLock()</em>的基础上设置了一个等待时间，在限定时间内会一直等待锁释放，超过了就不再尝试获取锁。另外，本方法也是和<em>lockInterruptibly()</em>一样响应线程中断的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testLock</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    Thread thread1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = lock.tryLock(<span class=\"number\">6</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1获取结果：&#123;&#125;\"</span>, result);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"1获取成功\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread thread2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2尝试获取锁···\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            result = lock.tryLock(<span class=\"number\">7</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2获取结果：&#123;&#125;\"</span>, result);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"2获取成功\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    thread1.start();</span><br><span class=\"line\">    thread2.start();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    thread1.interrupt();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过去了5S\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock4.png\" class=\"\" title=\"tryLock(long time, TimeUnit unit)方法\">\n\n</li>\n</ol>\n<h3 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h3><p>  正如synchronized能够通过wait/notify控制线程等待/唤醒一样，Lock也有配套的Condition配合控制线程。<br>  当抢占到lock锁资源时，便可使用lock中的Condition的方法控制线程。就像进入synchronized同步块后便可使用wait/notify方法一样。</p>\n<h4 id=\"方法介绍\"><a href=\"#方法介绍\" class=\"headerlink\" title=\"方法介绍\"></a>方法介绍</h4><ol>\n<li><p>void await()<br>最常用的等待方法，线程会一直等待直到有另一个线程调用<em>signal()</em>唤醒他，如果线程中断则抛出异常。</p>\n</li>\n<li><p>void awaitUninterruptibly()<br>与await()相似，不同的是当检查到当前线程中断，会进入一个安全的中断方法而不是抛出异常。</p>\n</li>\n<li><p>long awaitNanos(long nanosTimeout) throws InterruptedException<br>与await()的不同是会设定一个等待时间，只在这个时间段内等待。</p>\n</li>\n<li><p>boolean awaitUntil(Date deadline) throws InterruptedException<br>与awaitNanos(long n)类似，不过其设定的是一个时间点。</p>\n</li>\n<li><p>void signal()<br>唤醒方法，唤醒队列的头节点</p>\n</li>\n<li><p>void signalAll()<br>唤醒方法，唤醒队列中所有节点</p>\n</li>\n</ol>\n<h4 id=\"Condition使用\"><a href=\"#Condition使用\" class=\"headerlink\" title=\"Condition使用\"></a>Condition使用</h4><ol>\n<li><p>线程等待唤醒</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCondition</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    Condition condition = lock.newCondition();</span><br><span class=\"line\">    threadPoolExecutor.execute(()-&gt;&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"尝试获取锁···\"</span>);</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"获取成功\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            condition.await();</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"苏醒\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过了5s···\"</span>);</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"master获取成功\"</span>);</span><br><span class=\"line\">    condition.signal();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"唤醒等待线程···\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock5.png\" class=\"\" title=\"Condition演示1\">\n</li>\n<li><p>多个Condition</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testCondition</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    Condition conditionOne = lock.newCondition();</span><br><span class=\"line\">    Condition conditionTwo = lock.newCondition();</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1尝试获取锁···\"</span>);</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"1获取成功\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            conditionOne.await();</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"1苏醒\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2尝试获取锁···\"</span>);</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"2获取成功\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            conditionTwo.await();</span><br><span class=\"line\">            logger.info(<span class=\"string\">\"2苏醒\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"过了5s···\"</span>);</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"master获取成功\"</span>);</span><br><span class=\"line\">    conditionOne.signal();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"唤醒等待线程1···\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">    <span class=\"comment\">//---------------------------------</span></span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"又过了5s···\"</span>);</span><br><span class=\"line\">    lock.lock();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"master获取成功\"</span>);</span><br><span class=\"line\">    conditionTwo.signal();</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"唤醒等待线程2···\"</span>);</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/lock/lock6.png\" class=\"\" title=\"Condition演示2\">\n\n<p>可以看到，相对synchronized和wait，Lock和Condition的组合显然更加灵活和强大。<br>一个Lock可以通过<em>newCondition()</em>同时拥有多个等待队列，互不干涉影响。阻塞队列正是利用这种方式实现放入/弹出的控制。</p>\n</li>\n</ol>"},{"title":"飞仔的食谱","date":"2020-09-23T13:51:57.000Z","_content":"\n### 前言\n  食谱及对应食材的总结记录\n<!-- more -->\n\n### 红烧肉\n  五花肉，大葱，生姜，大蒜，八角，花椒，啤酒\n\n### 可乐鸡翅\n  鸡翅，可乐\n\n### 鸡胸肉\n  鸡胸肉，玉米，绿豆\n\n### 黄瓜火腿\n  黄瓜，鸡蛋，火腿\n\n### 番茄土豆牛腩\n  牛腩，番茄，土豆，大葱，生姜，八角\n\n### 洋葱鸡蛋\n  洋葱，鸡蛋\n\n### 麻辣香锅\n  五花肉，黄瓜，藕，土豆，玉米，鸡肉，花椒，八角，酱料\n\n### 土豆烧肉\n  土豆，廋肉\n\n### 辣椒炒肉\n  辣椒，廋肉\n\n\n\n","source":"_posts/2020/09/recipe1.md","raw":"---\ntitle: 飞仔的食谱\ndate: 2020-09-23 21:51:57\ntags:\n- 料理\ncategories:\n- 料理\n---\n\n### 前言\n  食谱及对应食材的总结记录\n<!-- more -->\n\n### 红烧肉\n  五花肉，大葱，生姜，大蒜，八角，花椒，啤酒\n\n### 可乐鸡翅\n  鸡翅，可乐\n\n### 鸡胸肉\n  鸡胸肉，玉米，绿豆\n\n### 黄瓜火腿\n  黄瓜，鸡蛋，火腿\n\n### 番茄土豆牛腩\n  牛腩，番茄，土豆，大葱，生姜，八角\n\n### 洋葱鸡蛋\n  洋葱，鸡蛋\n\n### 麻辣香锅\n  五花肉，黄瓜，藕，土豆，玉米，鸡肉，花椒，八角，酱料\n\n### 土豆烧肉\n  土豆，廋肉\n\n### 辣椒炒肉\n  辣椒，廋肉\n\n\n\n","slug":"recipe1","published":1,"updated":"2020-09-23T14:03:58.259Z","_id":"ckffgd5e400005cb51z5dab68","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  食谱及对应食材的总结记录</p>\n<a id=\"more\"></a>\n\n<h3 id=\"红烧肉\"><a href=\"#红烧肉\" class=\"headerlink\" title=\"红烧肉\"></a>红烧肉</h3><p>  五花肉，大葱，生姜，大蒜，八角，花椒，啤酒</p>\n<h3 id=\"可乐鸡翅\"><a href=\"#可乐鸡翅\" class=\"headerlink\" title=\"可乐鸡翅\"></a>可乐鸡翅</h3><p>  鸡翅，可乐</p>\n<h3 id=\"鸡胸肉\"><a href=\"#鸡胸肉\" class=\"headerlink\" title=\"鸡胸肉\"></a>鸡胸肉</h3><p>  鸡胸肉，玉米，绿豆</p>\n<h3 id=\"黄瓜火腿\"><a href=\"#黄瓜火腿\" class=\"headerlink\" title=\"黄瓜火腿\"></a>黄瓜火腿</h3><p>  黄瓜，鸡蛋，火腿</p>\n<h3 id=\"番茄土豆牛腩\"><a href=\"#番茄土豆牛腩\" class=\"headerlink\" title=\"番茄土豆牛腩\"></a>番茄土豆牛腩</h3><p>  牛腩，番茄，土豆，大葱，生姜，八角</p>\n<h3 id=\"洋葱鸡蛋\"><a href=\"#洋葱鸡蛋\" class=\"headerlink\" title=\"洋葱鸡蛋\"></a>洋葱鸡蛋</h3><p>  洋葱，鸡蛋</p>\n<h3 id=\"麻辣香锅\"><a href=\"#麻辣香锅\" class=\"headerlink\" title=\"麻辣香锅\"></a>麻辣香锅</h3><p>  五花肉，黄瓜，藕，土豆，玉米，鸡肉，花椒，八角，酱料</p>\n<h3 id=\"土豆烧肉\"><a href=\"#土豆烧肉\" class=\"headerlink\" title=\"土豆烧肉\"></a>土豆烧肉</h3><p>  土豆，廋肉</p>\n<h3 id=\"辣椒炒肉\"><a href=\"#辣椒炒肉\" class=\"headerlink\" title=\"辣椒炒肉\"></a>辣椒炒肉</h3><p>  辣椒，廋肉</p>\n","site":{"data":{}},"length":151,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  食谱及对应食材的总结记录</p>","more":"<h3 id=\"红烧肉\"><a href=\"#红烧肉\" class=\"headerlink\" title=\"红烧肉\"></a>红烧肉</h3><p>  五花肉，大葱，生姜，大蒜，八角，花椒，啤酒</p>\n<h3 id=\"可乐鸡翅\"><a href=\"#可乐鸡翅\" class=\"headerlink\" title=\"可乐鸡翅\"></a>可乐鸡翅</h3><p>  鸡翅，可乐</p>\n<h3 id=\"鸡胸肉\"><a href=\"#鸡胸肉\" class=\"headerlink\" title=\"鸡胸肉\"></a>鸡胸肉</h3><p>  鸡胸肉，玉米，绿豆</p>\n<h3 id=\"黄瓜火腿\"><a href=\"#黄瓜火腿\" class=\"headerlink\" title=\"黄瓜火腿\"></a>黄瓜火腿</h3><p>  黄瓜，鸡蛋，火腿</p>\n<h3 id=\"番茄土豆牛腩\"><a href=\"#番茄土豆牛腩\" class=\"headerlink\" title=\"番茄土豆牛腩\"></a>番茄土豆牛腩</h3><p>  牛腩，番茄，土豆，大葱，生姜，八角</p>\n<h3 id=\"洋葱鸡蛋\"><a href=\"#洋葱鸡蛋\" class=\"headerlink\" title=\"洋葱鸡蛋\"></a>洋葱鸡蛋</h3><p>  洋葱，鸡蛋</p>\n<h3 id=\"麻辣香锅\"><a href=\"#麻辣香锅\" class=\"headerlink\" title=\"麻辣香锅\"></a>麻辣香锅</h3><p>  五花肉，黄瓜，藕，土豆，玉米，鸡肉，花椒，八角，酱料</p>\n<h3 id=\"土豆烧肉\"><a href=\"#土豆烧肉\" class=\"headerlink\" title=\"土豆烧肉\"></a>土豆烧肉</h3><p>  土豆，廋肉</p>\n<h3 id=\"辣椒炒肉\"><a href=\"#辣椒炒肉\" class=\"headerlink\" title=\"辣椒炒肉\"></a>辣椒炒肉</h3><p>  辣椒，廋肉</p>"},{"title":"SpringCache的使用","date":"2020-11-02T13:26:28.000Z","_content":"\n### 前言\n\n   在开发一些配置相关的业务时，由于数据变化频率很低，很适合在查询的时候使用缓存。但对于一些复杂的数据结构，使用redis存取又觉得比较麻烦。\n   幸好，Spring提供了注解式的缓存方案-SpringCache。所以本章就来总结下SpringCache的用法。\n<!-- more -->\n\n### 注解\n   \n   SpringCache借助注解来实现对数据的缓存及删除。所以，这里以每个注解为入口依次了解他们的使用。\n\n#### @EnableCaching\n   \n   @EnableCaching注解用来开启SpringCache的缓存功能。\n   首先来看看他的结构：\n{% codeblock lang:java %}\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(CachingConfigurationSelector.class)\npublic @interface EnableCaching {\n\t// 开启基于CGLIB代理的开关，默认为基于JDK的代理\n\tboolean proxyTargetClass() default false;\n\t// AOP的实现方式，默认为基于JDK的，也可以基于AspectJ实现\n\tAdviceMode mode() default AdviceMode.PROXY;\n\t// 一个切点存在多个通知时的执行顺序，默认最低\n\tint order() default Ordered.LOWEST_PRECEDENCE;\n}\n{% endcodeblock %}\n   接着就开始正式的配置。\n   一般来说，为了实现个性化配置，我们会单独建一个配置类：\n{% codeblock lang:java %}\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n    @Bean\n    public CacheManager cacheManager() {\n        // 这里方便测试，使用最简单的CacheManager\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        // 使用CurrentMapCache作为缓存容器，default为默认的key值\n        cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(\"default\")));\n        return cacheManager;\n    }\n}\n{% endcodeblock %}\n   关于CacheManager的使用，SpringCache提供了对应各种缓存工具实现类。\n   例如针对redis的RedisCacheManager，还有针对encache的EhCacheCacheManager的等。\n   这里我们使用的是SimpleCacheManager，通常是用于测试使用，不需要太多配置。\n\n#### @Cacheable\n\n   @Cacheable用来新增缓存，每次会先判断有无缓存，有则取缓存，无则执行方法并将结果放入缓存\n   源码如下：\n{% codeblock lang:java %}\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Cacheable {\n    // 缓存的名字 与cacheNames属性互为别名，两者都是配置缓存名字\n    @AliasFor(\"cacheNames\")\n    String[] value() default {};\n    @AliasFor(\"value\")\n    String[] cacheNames() default {};\n    // 定义缓存的key值，使用SpEl，可以动态取入参的值\n    // \"\" 表示所有入参的值都被当作key，前提是没有配置keyGenerator\n    String key() default \"\";\n    // 指定key的生成策略\n    // 与key属性互斥，二者只能配置一个\n    String keyGenerator() default \"\";\n    // 自定义的CacheManager(当定义了多个时使用)\n    String cacheManager() default \"\";\n    // 自定义的CacheResolver\n    // 与CacheManager互斥\n    String cacheResolver() default \"\";\n    // 设置使用缓存的条件，同样使用SpEl语法\n    String condition() default \"\";\n    // 设置不适用缓存的条件，使用SpEl语法\n    String unless() default \"\";\n    // 是否使用异步模式，为true时无法使用unless属性\n    boolean sync() default false;\n}\n{% endcodeblock %}\n\n\n#### @CachePut\n\n   @CachePut用来更新缓存，每次都会执行方法并将结果放入缓存\n   源码如下：\n{% codeblock lang:java %}\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface CachePut {\n    // 缓存名称\n    @AliasFor(\"cacheNames\")\n    String[] value() default {};\n    @AliasFor(\"value\")\n    String[] cacheNames() default {};\n    // 缓存key\n    String key() default \"\";\n    // 缓存key的生成策略\n    String keyGenerator() default \"\";\n    // 自定义的CacheResolver\n    String cacheManager() default \"\";\n    // 自定义的CacheResolver\n    String cacheResolver() default \"\";\n    // 设置使用缓存的条件\n    String condition() default \"\";\n    // 设置不使用缓存的条件\n    String unless() default \"\";\n}\n{% endcodeblock %}\n   @CachePut的属性和@Cacheable基本一样，除了没有异步开关属性。\n\n#### @CahceEvict\n\n   @CacheEvice用来清除缓存，执行方法后会将对应缓存清除掉\n   源码如下：\n{% codeblock lang:java %}\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface CacheEvict {\n    // 缓存名称\n    @AliasFor(\"cacheNames\")\n    String[] value() default {};\n    @AliasFor(\"value\")\n    String[] cacheNames() default {};\n    // 缓存key\n    String key() default \"\";\n    // 缓存key的生成策略\n    String keyGenerator() default \"\";\n    // 自定义的CacheResolver\n    String cacheManager() default \"\";\n    // 自定义的CacheResolver\n    String cacheResolver() default \"\";\n    // 设置删除缓存的条件\n    String condition() default \"\";\n    // 是否删除缓存内所有内容，当为true时，不能指定key\n    boolean allEntries() default false;\n    // 是否在方法执行前删除缓存\n    // 若为true则表示在方法执行前就删除缓存，方法执行成功与否不影响删除操作\n    boolean beforeInvocation() default false;\n}\n{% endcodeblock %}\n\n#### @Caching\n   \n   @Cacheing用作在同一方法上配置多个缓存操作\n   源码如下：\n{% codeblock lang:java %}\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Caching {\n    // 多个缓存操作\n    Cacheable[] cacheable() default {};\n    // 多个更新缓存操作\n    CachePut[] put() default {};\n    // 多个缓存删除操作\n    CacheEvict[] evict() default {};\n}\n{% endcodeblock %}\n\n#### @CacheConfig\n    \n   @CacheConfig提供了公用配置的实现，避免多次重复配置\n   源码如下：\n{% codeblock lang:java %}\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface CacheConfig {\n    // 缓存名称\n    String[] cacheNames() default {};\n    // 缓存key的生成策略\n    String keyGenerator() default \"\";\n    // 自定义的CacheResolver\n    String cacheManager() default \"\";\n    // 自定义的CacheResolver\n    String cacheResolver() default \"\";\n}\n{% endcodeblock %}\n\n### 使用示例\n\t\n   虽然SpringCache简化了对缓存的操作，但相应的也有了很多限制。\n\n#### 基本用法\n   三个缓存的操作注解分别对应查询，更新，删除操作，但更新操作需要方法也返回对应的结果集。\n   而更新的接口通常只会返回操作结果，成功或者失败。所以这里使用@CacheEvice直接删除缓存会更方便些。\n{% codeblock lang:java %}\n@Cacheable(key = \"#key\", value = \"default\")\npublic Object getInfo(String key) {\n    // find data from DB\n    return result;\n}\n@CacheEvict(key = \"#key\", value = \"default\")\npublic String update(String key) {\n    // update data\n    return result;\n}\n// 每次更新操作后都会清除缓存，这样下次执行查询操作就会直接走库，达到缓存更新的目的。\n{% endcodeblock %}\n\n#### 多个CacheManager\n   前面有说到，我们可以配置多个不同的CacheManager,然后在每个操作注解上指定想要的CacheManager。\n   这里简单举一个例子：\n{% codeblock lang:java %}\n// @Primary指定默认的CacheManager\n@Primary\n@Bean\npublic CacheManager cacheManager() {\n    SimpleCacheManager cacheManager = new SimpleCacheManager();\n    cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(\"default\")));\n    return cacheManager;\n}\n@Bean\npublic CacheManager slaveCacheManager() {\n    ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();\n    List<String> list = Lists.newArrayList();\n    list.add(\"salve1\");\n    list.add(\"salve2\");\n    cacheManager.setCacheNames(list);\n    return cacheManager;\n}\n\n// 指定了slaveCacheManager 相应的缓存的名称也改为对应的salve1\n@Override\n@Cacheable(key = \"#key\", cacheManager = \"slaveCacheManager\",value = \"salve1\")\npublic String cacheAbleTest(String key) {\n    log.info(\"cache able:{}\", key);\n    this.value = \"cache able\";\n    return value;\n}\n// 没有指定CacheManager所以会使用默认的\n@Override\n@CachePut(key = \"#key\", value = \"default\")\npublic String cachePutTest(String key) {\n    log.info(\"cache put:{}\", key);\n    this.value = \"cache put\";\n    return value;\n}\n{% endcodeblock %}\n\n\n#### CacheResolver的使用\n   \n  先看看默认实现的CacheResolver：\n\n{% codeblock lang:java %}\n// 实现了CacheResolver的抽象类，默认实现的CacheResolver也是继承自该抽象类\npublic abstract class AbstractCacheResolver implements CacheResolver, InitializingBean {\n\n  @Nullable\n  private CacheManager cacheManager;\n\n  protected AbstractCacheResolver() {}\n  protected AbstractCacheResolver(CacheManager cacheManager) {\n    this.cacheManager = cacheManager;\n  }\n\n  public void setCacheManager(CacheManager cacheManager) {\n    this.cacheManager = cacheManager;\n  }\n\n  public CacheManager getCacheManager() {\n    Assert.state(this.cacheManager != null, \"No CacheManager set\");\n    return this.cacheManager;\n  }\n\n  @Override\n  public void afterPropertiesSet()  {\n    Assert.notNull(this.cacheManager, \"CacheManager is required\");\n  }\n\n  // 实现自接口的方法，返回包含缓存对象的集合\n  @Override\n  public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {\n    Collection<String> cacheNames = getCacheNames(context);\n    if (cacheNames == null) {\n      return Collections.emptyList();\n    }\n    Collection<Cache> result = new ArrayList<>(cacheNames.size());\n    // 通过缓存名称获取不同的cacheManager\n    for (String cacheName : cacheNames) {\n      Cache cache = getCacheManager().getCache(cacheName);\n      if (cache == null) {\n        throw new IllegalArgumentException(\"Cannot find cache named '\" +\n            cacheName + \"' for \" + context.getOperation());\n      }\n      result.add(cache);\n    }\n    return result;\n  }\n\n  @Nullable\n  protected abstract Collection<String> getCacheNames(CacheOperationInvocationContext<?> context);\n}\n// 继承了抽象类AbstractCacheResolver\npublic class SimpleCacheResolver extends AbstractCacheResolver {\n\n  public SimpleCacheResolver() {}\n  // 构造方法，设置指定的CacheManager\n  public SimpleCacheResolver(CacheManager cacheManager) {\n    super(cacheManager);\n  }\n\n  @Override\n  protected Collection<String> getCacheNames(CacheOperationInvocationContext<?> context) {\n    return context.getOperation().getCacheNames();\n  }\n\n  @Nullable\n  static SimpleCacheResolver of(@Nullable CacheManager cacheManager) {\n    return (cacheManager != null ? new SimpleCacheResolver(cacheManager) : null);\n  }\n}\n{% endcodeblock %}\n   从上述代码可以看出，CacheResolver的作用是管理CacheManager，可以根据特定规则选择CacheManager。\n   下面是根据上述例子实现的CacheResolver，根据缓存名称返回CacheManager:\n{% codeblock lang:java %}\npublic class MyCacheResolver implements CacheResolver {\n    private static final Logger logger = LoggerFactory.getLogger(MyCacheResolver.class);\n\n    private List<CacheManager> cacheManagerList;\n\n    public MyCacheResolver(List<CacheManager> cacheManagerList) {\n        this.cacheManagerList = cacheManagerList;\n    }\n\n    @Override\n    public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {\n        // context包含的内容\n        logger.info(\"method name :{}\", context.getMethod().getName());\n        logger.info(\"args:{}\", context.getArgs());\n        logger.info(\"target:{}\", context.getTarget());\n        // 获取当前执行方法设置的缓存名称\n        String[] values = context.getMethod().getAnnotation(Cacheable.class).value();\n        logger.info(\"cacheName:{}\", values);\n        Collection<Cache> caches = Lists.newArrayList();\n        for (CacheManager cacheManager : cacheManagerList) {\n            // 根据缓存名称从集合中选择CacheManager\n            if (cacheManager.getCacheNames().contains(values[0])) {\n                logger.info(\"cache manager:{}\", cacheManager);\n                caches.add(cacheManager.getCache(values[0]));\n            }\n        }\n        return caches;\n    }\n}\n\n// 然后在配置中新建对应的CacheResolver方法\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n\n    @Primary\n    @Bean\n    public CacheManager cacheManager() {\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(\"default\")));\n        return cacheManager;\n    }\n\n\n    @Bean\n    public CacheManager slaveCacheManager() {\n        ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();\n        List<String> list = Lists.newArrayList();\n        list.add(\"salve1\");\n        list.add(\"salve2\");\n        cacheManager.setCacheNames(list);\n        return cacheManager;\n    }\n\n    @Bean\n    public CacheResolver cacheResolver() {\n        List<CacheManager> list = Lists.newArrayList();\n        list.add(cacheManager());\n        list.add(slaveCacheManager());\n        return new MyCacheResolver(list);\n    }\n}\n{% endcodeblock %}\n\n### 总结\n\n      不得不说，SpringCache极大的简化了项目中对缓存的使用。\n      不过，这也意味着限制了对缓存的操作，就目前来看，SpringCache适合于获取变化较少的数据的\n    查询接口上，例如一些配置信息的查询等。\n      当然，SpringCache也提供了CacheManager和CacheResolver共开发者扩展，不过本章只是简单\n    展示了他们的用法，所以暂时不了解他们更多的运用技巧。\n      总体来说，SpringCache的优势在于快速实现，代码规范化及简化，兼容性高，扩展性都比较高。\n    如果不考虑对缓存生命周期设置或者一些精细操作上的需求，SpringCache必然是最好的选择。","source":"_posts/2020/11/spring-cache1.md","raw":"---\ntitle: SpringCache的使用\ndate: 2020-11-02 21:26:28\ntags:\n- 缓存\n- SpringCache\ncategories:\n- Spring\n- SpringCache\n---\n\n### 前言\n\n   在开发一些配置相关的业务时，由于数据变化频率很低，很适合在查询的时候使用缓存。但对于一些复杂的数据结构，使用redis存取又觉得比较麻烦。\n   幸好，Spring提供了注解式的缓存方案-SpringCache。所以本章就来总结下SpringCache的用法。\n<!-- more -->\n\n### 注解\n   \n   SpringCache借助注解来实现对数据的缓存及删除。所以，这里以每个注解为入口依次了解他们的使用。\n\n#### @EnableCaching\n   \n   @EnableCaching注解用来开启SpringCache的缓存功能。\n   首先来看看他的结构：\n{% codeblock lang:java %}\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Import(CachingConfigurationSelector.class)\npublic @interface EnableCaching {\n\t// 开启基于CGLIB代理的开关，默认为基于JDK的代理\n\tboolean proxyTargetClass() default false;\n\t// AOP的实现方式，默认为基于JDK的，也可以基于AspectJ实现\n\tAdviceMode mode() default AdviceMode.PROXY;\n\t// 一个切点存在多个通知时的执行顺序，默认最低\n\tint order() default Ordered.LOWEST_PRECEDENCE;\n}\n{% endcodeblock %}\n   接着就开始正式的配置。\n   一般来说，为了实现个性化配置，我们会单独建一个配置类：\n{% codeblock lang:java %}\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n    @Bean\n    public CacheManager cacheManager() {\n        // 这里方便测试，使用最简单的CacheManager\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        // 使用CurrentMapCache作为缓存容器，default为默认的key值\n        cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(\"default\")));\n        return cacheManager;\n    }\n}\n{% endcodeblock %}\n   关于CacheManager的使用，SpringCache提供了对应各种缓存工具实现类。\n   例如针对redis的RedisCacheManager，还有针对encache的EhCacheCacheManager的等。\n   这里我们使用的是SimpleCacheManager，通常是用于测试使用，不需要太多配置。\n\n#### @Cacheable\n\n   @Cacheable用来新增缓存，每次会先判断有无缓存，有则取缓存，无则执行方法并将结果放入缓存\n   源码如下：\n{% codeblock lang:java %}\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Cacheable {\n    // 缓存的名字 与cacheNames属性互为别名，两者都是配置缓存名字\n    @AliasFor(\"cacheNames\")\n    String[] value() default {};\n    @AliasFor(\"value\")\n    String[] cacheNames() default {};\n    // 定义缓存的key值，使用SpEl，可以动态取入参的值\n    // \"\" 表示所有入参的值都被当作key，前提是没有配置keyGenerator\n    String key() default \"\";\n    // 指定key的生成策略\n    // 与key属性互斥，二者只能配置一个\n    String keyGenerator() default \"\";\n    // 自定义的CacheManager(当定义了多个时使用)\n    String cacheManager() default \"\";\n    // 自定义的CacheResolver\n    // 与CacheManager互斥\n    String cacheResolver() default \"\";\n    // 设置使用缓存的条件，同样使用SpEl语法\n    String condition() default \"\";\n    // 设置不适用缓存的条件，使用SpEl语法\n    String unless() default \"\";\n    // 是否使用异步模式，为true时无法使用unless属性\n    boolean sync() default false;\n}\n{% endcodeblock %}\n\n\n#### @CachePut\n\n   @CachePut用来更新缓存，每次都会执行方法并将结果放入缓存\n   源码如下：\n{% codeblock lang:java %}\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface CachePut {\n    // 缓存名称\n    @AliasFor(\"cacheNames\")\n    String[] value() default {};\n    @AliasFor(\"value\")\n    String[] cacheNames() default {};\n    // 缓存key\n    String key() default \"\";\n    // 缓存key的生成策略\n    String keyGenerator() default \"\";\n    // 自定义的CacheResolver\n    String cacheManager() default \"\";\n    // 自定义的CacheResolver\n    String cacheResolver() default \"\";\n    // 设置使用缓存的条件\n    String condition() default \"\";\n    // 设置不使用缓存的条件\n    String unless() default \"\";\n}\n{% endcodeblock %}\n   @CachePut的属性和@Cacheable基本一样，除了没有异步开关属性。\n\n#### @CahceEvict\n\n   @CacheEvice用来清除缓存，执行方法后会将对应缓存清除掉\n   源码如下：\n{% codeblock lang:java %}\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface CacheEvict {\n    // 缓存名称\n    @AliasFor(\"cacheNames\")\n    String[] value() default {};\n    @AliasFor(\"value\")\n    String[] cacheNames() default {};\n    // 缓存key\n    String key() default \"\";\n    // 缓存key的生成策略\n    String keyGenerator() default \"\";\n    // 自定义的CacheResolver\n    String cacheManager() default \"\";\n    // 自定义的CacheResolver\n    String cacheResolver() default \"\";\n    // 设置删除缓存的条件\n    String condition() default \"\";\n    // 是否删除缓存内所有内容，当为true时，不能指定key\n    boolean allEntries() default false;\n    // 是否在方法执行前删除缓存\n    // 若为true则表示在方法执行前就删除缓存，方法执行成功与否不影响删除操作\n    boolean beforeInvocation() default false;\n}\n{% endcodeblock %}\n\n#### @Caching\n   \n   @Cacheing用作在同一方法上配置多个缓存操作\n   源码如下：\n{% codeblock lang:java %}\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface Caching {\n    // 多个缓存操作\n    Cacheable[] cacheable() default {};\n    // 多个更新缓存操作\n    CachePut[] put() default {};\n    // 多个缓存删除操作\n    CacheEvict[] evict() default {};\n}\n{% endcodeblock %}\n\n#### @CacheConfig\n    \n   @CacheConfig提供了公用配置的实现，避免多次重复配置\n   源码如下：\n{% codeblock lang:java %}\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface CacheConfig {\n    // 缓存名称\n    String[] cacheNames() default {};\n    // 缓存key的生成策略\n    String keyGenerator() default \"\";\n    // 自定义的CacheResolver\n    String cacheManager() default \"\";\n    // 自定义的CacheResolver\n    String cacheResolver() default \"\";\n}\n{% endcodeblock %}\n\n### 使用示例\n\t\n   虽然SpringCache简化了对缓存的操作，但相应的也有了很多限制。\n\n#### 基本用法\n   三个缓存的操作注解分别对应查询，更新，删除操作，但更新操作需要方法也返回对应的结果集。\n   而更新的接口通常只会返回操作结果，成功或者失败。所以这里使用@CacheEvice直接删除缓存会更方便些。\n{% codeblock lang:java %}\n@Cacheable(key = \"#key\", value = \"default\")\npublic Object getInfo(String key) {\n    // find data from DB\n    return result;\n}\n@CacheEvict(key = \"#key\", value = \"default\")\npublic String update(String key) {\n    // update data\n    return result;\n}\n// 每次更新操作后都会清除缓存，这样下次执行查询操作就会直接走库，达到缓存更新的目的。\n{% endcodeblock %}\n\n#### 多个CacheManager\n   前面有说到，我们可以配置多个不同的CacheManager,然后在每个操作注解上指定想要的CacheManager。\n   这里简单举一个例子：\n{% codeblock lang:java %}\n// @Primary指定默认的CacheManager\n@Primary\n@Bean\npublic CacheManager cacheManager() {\n    SimpleCacheManager cacheManager = new SimpleCacheManager();\n    cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(\"default\")));\n    return cacheManager;\n}\n@Bean\npublic CacheManager slaveCacheManager() {\n    ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();\n    List<String> list = Lists.newArrayList();\n    list.add(\"salve1\");\n    list.add(\"salve2\");\n    cacheManager.setCacheNames(list);\n    return cacheManager;\n}\n\n// 指定了slaveCacheManager 相应的缓存的名称也改为对应的salve1\n@Override\n@Cacheable(key = \"#key\", cacheManager = \"slaveCacheManager\",value = \"salve1\")\npublic String cacheAbleTest(String key) {\n    log.info(\"cache able:{}\", key);\n    this.value = \"cache able\";\n    return value;\n}\n// 没有指定CacheManager所以会使用默认的\n@Override\n@CachePut(key = \"#key\", value = \"default\")\npublic String cachePutTest(String key) {\n    log.info(\"cache put:{}\", key);\n    this.value = \"cache put\";\n    return value;\n}\n{% endcodeblock %}\n\n\n#### CacheResolver的使用\n   \n  先看看默认实现的CacheResolver：\n\n{% codeblock lang:java %}\n// 实现了CacheResolver的抽象类，默认实现的CacheResolver也是继承自该抽象类\npublic abstract class AbstractCacheResolver implements CacheResolver, InitializingBean {\n\n  @Nullable\n  private CacheManager cacheManager;\n\n  protected AbstractCacheResolver() {}\n  protected AbstractCacheResolver(CacheManager cacheManager) {\n    this.cacheManager = cacheManager;\n  }\n\n  public void setCacheManager(CacheManager cacheManager) {\n    this.cacheManager = cacheManager;\n  }\n\n  public CacheManager getCacheManager() {\n    Assert.state(this.cacheManager != null, \"No CacheManager set\");\n    return this.cacheManager;\n  }\n\n  @Override\n  public void afterPropertiesSet()  {\n    Assert.notNull(this.cacheManager, \"CacheManager is required\");\n  }\n\n  // 实现自接口的方法，返回包含缓存对象的集合\n  @Override\n  public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {\n    Collection<String> cacheNames = getCacheNames(context);\n    if (cacheNames == null) {\n      return Collections.emptyList();\n    }\n    Collection<Cache> result = new ArrayList<>(cacheNames.size());\n    // 通过缓存名称获取不同的cacheManager\n    for (String cacheName : cacheNames) {\n      Cache cache = getCacheManager().getCache(cacheName);\n      if (cache == null) {\n        throw new IllegalArgumentException(\"Cannot find cache named '\" +\n            cacheName + \"' for \" + context.getOperation());\n      }\n      result.add(cache);\n    }\n    return result;\n  }\n\n  @Nullable\n  protected abstract Collection<String> getCacheNames(CacheOperationInvocationContext<?> context);\n}\n// 继承了抽象类AbstractCacheResolver\npublic class SimpleCacheResolver extends AbstractCacheResolver {\n\n  public SimpleCacheResolver() {}\n  // 构造方法，设置指定的CacheManager\n  public SimpleCacheResolver(CacheManager cacheManager) {\n    super(cacheManager);\n  }\n\n  @Override\n  protected Collection<String> getCacheNames(CacheOperationInvocationContext<?> context) {\n    return context.getOperation().getCacheNames();\n  }\n\n  @Nullable\n  static SimpleCacheResolver of(@Nullable CacheManager cacheManager) {\n    return (cacheManager != null ? new SimpleCacheResolver(cacheManager) : null);\n  }\n}\n{% endcodeblock %}\n   从上述代码可以看出，CacheResolver的作用是管理CacheManager，可以根据特定规则选择CacheManager。\n   下面是根据上述例子实现的CacheResolver，根据缓存名称返回CacheManager:\n{% codeblock lang:java %}\npublic class MyCacheResolver implements CacheResolver {\n    private static final Logger logger = LoggerFactory.getLogger(MyCacheResolver.class);\n\n    private List<CacheManager> cacheManagerList;\n\n    public MyCacheResolver(List<CacheManager> cacheManagerList) {\n        this.cacheManagerList = cacheManagerList;\n    }\n\n    @Override\n    public Collection<? extends Cache> resolveCaches(CacheOperationInvocationContext<?> context) {\n        // context包含的内容\n        logger.info(\"method name :{}\", context.getMethod().getName());\n        logger.info(\"args:{}\", context.getArgs());\n        logger.info(\"target:{}\", context.getTarget());\n        // 获取当前执行方法设置的缓存名称\n        String[] values = context.getMethod().getAnnotation(Cacheable.class).value();\n        logger.info(\"cacheName:{}\", values);\n        Collection<Cache> caches = Lists.newArrayList();\n        for (CacheManager cacheManager : cacheManagerList) {\n            // 根据缓存名称从集合中选择CacheManager\n            if (cacheManager.getCacheNames().contains(values[0])) {\n                logger.info(\"cache manager:{}\", cacheManager);\n                caches.add(cacheManager.getCache(values[0]));\n            }\n        }\n        return caches;\n    }\n}\n\n// 然后在配置中新建对应的CacheResolver方法\n@Configuration\n@EnableCaching\npublic class CacheConfig {\n\n    @Primary\n    @Bean\n    public CacheManager cacheManager() {\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        cacheManager.setCaches(Arrays.asList(new ConcurrentMapCache(\"default\")));\n        return cacheManager;\n    }\n\n\n    @Bean\n    public CacheManager slaveCacheManager() {\n        ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();\n        List<String> list = Lists.newArrayList();\n        list.add(\"salve1\");\n        list.add(\"salve2\");\n        cacheManager.setCacheNames(list);\n        return cacheManager;\n    }\n\n    @Bean\n    public CacheResolver cacheResolver() {\n        List<CacheManager> list = Lists.newArrayList();\n        list.add(cacheManager());\n        list.add(slaveCacheManager());\n        return new MyCacheResolver(list);\n    }\n}\n{% endcodeblock %}\n\n### 总结\n\n      不得不说，SpringCache极大的简化了项目中对缓存的使用。\n      不过，这也意味着限制了对缓存的操作，就目前来看，SpringCache适合于获取变化较少的数据的\n    查询接口上，例如一些配置信息的查询等。\n      当然，SpringCache也提供了CacheManager和CacheResolver共开发者扩展，不过本章只是简单\n    展示了他们的用法，所以暂时不了解他们更多的运用技巧。\n      总体来说，SpringCache的优势在于快速实现，代码规范化及简化，兼容性高，扩展性都比较高。\n    如果不考虑对缓存生命周期设置或者一些精细操作上的需求，SpringCache必然是最好的选择。","slug":"spring-cache1","published":1,"updated":"2020-12-11T14:39:29.915Z","_id":"ckhan3gpw00008gb5f42y972r","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   在开发一些配置相关的业务时，由于数据变化频率很低，很适合在查询的时候使用缓存。但对于一些复杂的数据结构，使用redis存取又觉得比较麻烦。<br>   幸好，Spring提供了注解式的缓存方案-SpringCache。所以本章就来总结下SpringCache的用法。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>   SpringCache借助注解来实现对数据的缓存及删除。所以，这里以每个注解为入口依次了解他们的使用。</p>\n<h4 id=\"EnableCaching\"><a href=\"#EnableCaching\" class=\"headerlink\" title=\"@EnableCaching\"></a>@EnableCaching</h4><p>   @EnableCaching注解用来开启SpringCache的缓存功能。<br>   首先来看看他的结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(CachingConfigurationSelector<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span> @<span class=\"title\">interface</span> <span class=\"title\">EnableCaching</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 开启基于CGLIB代理的开关，默认为基于JDK的代理</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">proxyTargetClass</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">// AOP的实现方式，默认为基于JDK的，也可以基于AspectJ实现</span></span><br><span class=\"line\">\t<span class=\"function\">AdviceMode <span class=\"title\">mode</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> AdviceMode.PROXY</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 一个切点存在多个通知时的执行顺序，默认最低</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">order</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   接着就开始正式的配置。<br>   一般来说，为了实现个性化配置，我们会单独建一个配置类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">cacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里方便测试，使用最简单的CacheManager</span></span><br><span class=\"line\">        SimpleCacheManager cacheManager = <span class=\"keyword\">new</span> SimpleCacheManager();</span><br><span class=\"line\">        <span class=\"comment\">// 使用CurrentMapCache作为缓存容器，default为默认的key值</span></span><br><span class=\"line\">        cacheManager.setCaches(Arrays.asList(<span class=\"keyword\">new</span> ConcurrentMapCache(<span class=\"string\">\"default\"</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   关于CacheManager的使用，SpringCache提供了对应各种缓存工具实现类。<br>   例如针对redis的RedisCacheManager，还有针对encache的EhCacheCacheManager的等。<br>   这里我们使用的是SimpleCacheManager，通常是用于测试使用，不需要太多配置。</p>\n<h4 id=\"Cacheable\"><a href=\"#Cacheable\" class=\"headerlink\" title=\"@Cacheable\"></a>@Cacheable</h4><p>   @Cacheable用来新增缓存，每次会先判断有无缓存，有则取缓存，无则执行方法并将结果放入缓存<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Cacheable &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存的名字 与cacheNames属性互为别名，两者都是配置缓存名字</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"cacheNames\"</span>)</span><br><span class=\"line\">    String[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"value\"</span>)</span><br><span class=\"line\">    String[] cacheNames() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 定义缓存的key值，使用SpEl，可以动态取入参的值</span></span><br><span class=\"line\">    <span class=\"comment\">// \"\" 表示所有入参的值都被当作key，前提是没有配置keyGenerator</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">key</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 指定key的生成策略</span></span><br><span class=\"line\">    <span class=\"comment\">// 与key属性互斥，二者只能配置一个</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">keyGenerator</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheManager(当定义了多个时使用)</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheManager</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"comment\">// 与CacheManager互斥</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置使用缓存的条件，同样使用SpEl语法</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">condition</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置不适用缓存的条件，使用SpEl语法</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">unless</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 是否使用异步模式，为true时无法使用unless属性</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">sync</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"CachePut\"><a href=\"#CachePut\" class=\"headerlink\" title=\"@CachePut\"></a>@CachePut</h4><p>   @CachePut用来更新缓存，每次都会执行方法并将结果放入缓存<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CachePut &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存名称</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"cacheNames\"</span>)</span><br><span class=\"line\">    String[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"value\"</span>)</span><br><span class=\"line\">    String[] cacheNames() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">key</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key的生成策略</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">keyGenerator</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheManager</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置使用缓存的条件</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">condition</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置不使用缓存的条件</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">unless</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   @CachePut的属性和@Cacheable基本一样，除了没有异步开关属性。</p>\n<h4 id=\"CahceEvict\"><a href=\"#CahceEvict\" class=\"headerlink\" title=\"@CahceEvict\"></a>@CahceEvict</h4><p>   @CacheEvice用来清除缓存，执行方法后会将对应缓存清除掉<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CacheEvict &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存名称</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"cacheNames\"</span>)</span><br><span class=\"line\">    String[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"value\"</span>)</span><br><span class=\"line\">    String[] cacheNames() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">key</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key的生成策略</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">keyGenerator</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheManager</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置删除缓存的条件</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">condition</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 是否删除缓存内所有内容，当为true时，不能指定key</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">allEntries</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 是否在方法执行前删除缓存</span></span><br><span class=\"line\">    <span class=\"comment\">// 若为true则表示在方法执行前就删除缓存，方法执行成功与否不影响删除操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">beforeInvocation</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Caching\"><a href=\"#Caching\" class=\"headerlink\" title=\"@Caching\"></a>@Caching</h4><p>   @Cacheing用作在同一方法上配置多个缓存操作<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Caching &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 多个缓存操作</span></span><br><span class=\"line\">    Cacheable[] cacheable() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 多个更新缓存操作</span></span><br><span class=\"line\">    CachePut[] put() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 多个缓存删除操作</span></span><br><span class=\"line\">    CacheEvict[] evict() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CacheConfig\"><a href=\"#CacheConfig\" class=\"headerlink\" title=\"@CacheConfig\"></a>@CacheConfig</h4><p>   @CacheConfig提供了公用配置的实现，避免多次重复配置<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CacheConfig &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存名称</span></span><br><span class=\"line\">    String[] cacheNames() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key的生成策略</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">keyGenerator</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheManager</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><p>   虽然SpringCache简化了对缓存的操作，但相应的也有了很多限制。</p>\n<h4 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><p>   三个缓存的操作注解分别对应查询，更新，删除操作，但更新操作需要方法也返回对应的结果集。<br>   而更新的接口通常只会返回操作结果，成功或者失败。所以这里使用@CacheEvice直接删除缓存会更方便些。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable</span>(key = <span class=\"string\">\"#key\"</span>, value = <span class=\"string\">\"default\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getInfo</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// find data from DB</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@CacheEvict</span>(key = <span class=\"string\">\"#key\"</span>, value = <span class=\"string\">\"default\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">update</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// update data</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 每次更新操作后都会清除缓存，这样下次执行查询操作就会直接走库，达到缓存更新的目的。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多个CacheManager\"><a href=\"#多个CacheManager\" class=\"headerlink\" title=\"多个CacheManager\"></a>多个CacheManager</h4><p>   前面有说到，我们可以配置多个不同的CacheManager,然后在每个操作注解上指定想要的CacheManager。<br>   这里简单举一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @Primary指定默认的CacheManager</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">cacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    SimpleCacheManager cacheManager = <span class=\"keyword\">new</span> SimpleCacheManager();</span><br><span class=\"line\">    cacheManager.setCaches(Arrays.asList(<span class=\"keyword\">new</span> ConcurrentMapCache(<span class=\"string\">\"default\"</span>)));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">slaveCacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ConcurrentMapCacheManager cacheManager = <span class=\"keyword\">new</span> ConcurrentMapCacheManager();</span><br><span class=\"line\">    List&lt;String&gt; list = Lists.newArrayList();</span><br><span class=\"line\">    list.add(<span class=\"string\">\"salve1\"</span>);</span><br><span class=\"line\">    list.add(<span class=\"string\">\"salve2\"</span>);</span><br><span class=\"line\">    cacheManager.setCacheNames(list);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定了slaveCacheManager 相应的缓存的名称也改为对应的salve1</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Cacheable</span>(key = <span class=\"string\">\"#key\"</span>, cacheManager = <span class=\"string\">\"slaveCacheManager\"</span>,value = <span class=\"string\">\"salve1\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">cacheAbleTest</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"cache able:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"string\">\"cache able\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 没有指定CacheManager所以会使用默认的</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@CachePut</span>(key = <span class=\"string\">\"#key\"</span>, value = <span class=\"string\">\"default\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">cachePutTest</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"cache put:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"string\">\"cache put\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"CacheResolver的使用\"><a href=\"#CacheResolver的使用\" class=\"headerlink\" title=\"CacheResolver的使用\"></a>CacheResolver的使用</h4><p>  先看看默认实现的CacheResolver：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现了CacheResolver的抽象类，默认实现的CacheResolver也是继承自该抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractCacheResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">CacheResolver</span>, <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> CacheManager cacheManager;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractCacheResolver</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractCacheResolver</span><span class=\"params\">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cacheManager = cacheManager;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCacheManager</span><span class=\"params\">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cacheManager = cacheManager;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">getCacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Assert.state(<span class=\"keyword\">this</span>.cacheManager != <span class=\"keyword\">null</span>, <span class=\"string\">\"No CacheManager set\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.cacheManager;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">    Assert.notNull(<span class=\"keyword\">this</span>.cacheManager, <span class=\"string\">\"CacheManager is required\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实现自接口的方法，返回包含缓存对象的集合</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Collection&lt;? extends Cache&gt; resolveCaches(CacheOperationInvocationContext&lt;?&gt; context) &#123;</span><br><span class=\"line\">    Collection&lt;String&gt; cacheNames = getCacheNames(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheNames == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Collection&lt;Cache&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(cacheNames.size());</span><br><span class=\"line\">    <span class=\"comment\">// 通过缓存名称获取不同的cacheManager</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cacheName : cacheNames) &#123;</span><br><span class=\"line\">      Cache cache = getCacheManager().getCache(cacheName);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cache == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot find cache named '\"</span> +</span><br><span class=\"line\">            cacheName + <span class=\"string\">\"' for \"</span> + context.getOperation());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      result.add(cache);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Collection&lt;String&gt; <span class=\"title\">getCacheNames</span><span class=\"params\">(CacheOperationInvocationContext&lt;?&gt; context)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 继承了抽象类AbstractCacheResolver</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleCacheResolver</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractCacheResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleCacheResolver</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 构造方法，设置指定的CacheManager</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleCacheResolver</span><span class=\"params\">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(cacheManager);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> Collection&lt;String&gt; <span class=\"title\">getCacheNames</span><span class=\"params\">(CacheOperationInvocationContext&lt;?&gt; context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context.getOperation().getCacheNames();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> SimpleCacheResolver <span class=\"title\">of</span><span class=\"params\">(@Nullable CacheManager cacheManager)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (cacheManager != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> SimpleCacheResolver(cacheManager) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   从上述代码可以看出，CacheResolver的作用是管理CacheManager，可以根据特定规则选择CacheManager。<br>   下面是根据上述例子实现的CacheResolver，根据缓存名称返回CacheManager:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCacheResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">CacheResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(MyCacheResolver<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;CacheManager&gt; cacheManagerList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyCacheResolver</span><span class=\"params\">(List&lt;CacheManager&gt; cacheManagerList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cacheManagerList = cacheManagerList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Collection&lt;? extends Cache&gt; resolveCaches(CacheOperationInvocationContext&lt;?&gt; context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// context包含的内容</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">\"method name :&#123;&#125;\"</span>, context.getMethod().getName());</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"args:&#123;&#125;\"</span>, context.getArgs());</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"target:&#123;&#125;\"</span>, context.getTarget());</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前执行方法设置的缓存名称</span></span><br><span class=\"line\">        String[] values = context.getMethod().getAnnotation(Cacheable<span class=\"class\">.<span class=\"keyword\">class</span>).<span class=\"title\">value</span>()</span>;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"cacheName:&#123;&#125;\"</span>, values);</span><br><span class=\"line\">        Collection&lt;Cache&gt; caches = Lists.newArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (CacheManager cacheManager : cacheManagerList) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据缓存名称从集合中选择CacheManager</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheManager.getCacheNames().contains(values[<span class=\"number\">0</span>])) &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"cache manager:&#123;&#125;\"</span>, cacheManager);</span><br><span class=\"line\">                caches.add(cacheManager.getCache(values[<span class=\"number\">0</span>]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> caches;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后在配置中新建对应的CacheResolver方法</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">cacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SimpleCacheManager cacheManager = <span class=\"keyword\">new</span> SimpleCacheManager();</span><br><span class=\"line\">        cacheManager.setCaches(Arrays.asList(<span class=\"keyword\">new</span> ConcurrentMapCache(<span class=\"string\">\"default\"</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">slaveCacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ConcurrentMapCacheManager cacheManager = <span class=\"keyword\">new</span> ConcurrentMapCacheManager();</span><br><span class=\"line\">        List&lt;String&gt; list = Lists.newArrayList();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"salve1\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"salve2\"</span>);</span><br><span class=\"line\">        cacheManager.setCacheNames(list);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CacheResolver <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;CacheManager&gt; list = Lists.newArrayList();</span><br><span class=\"line\">        list.add(cacheManager());</span><br><span class=\"line\">        list.add(slaveCacheManager());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyCacheResolver(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  不得不说，SpringCache极大的简化了项目中对缓存的使用。\n  不过，这也意味着限制了对缓存的操作，就目前来看，SpringCache适合于获取变化较少的数据的\n查询接口上，例如一些配置信息的查询等。\n  当然，SpringCache也提供了CacheManager和CacheResolver共开发者扩展，不过本章只是简单\n展示了他们的用法，所以暂时不了解他们更多的运用技巧。\n  总体来说，SpringCache的优势在于快速实现，代码规范化及简化，兼容性高，扩展性都比较高。\n如果不考虑对缓存生命周期设置或者一些精细操作上的需求，SpringCache必然是最好的选择。</code></pre>","site":{"data":{}},"length":1365,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   在开发一些配置相关的业务时，由于数据变化频率很低，很适合在查询的时候使用缓存。但对于一些复杂的数据结构，使用redis存取又觉得比较麻烦。<br>   幸好，Spring提供了注解式的缓存方案-SpringCache。所以本章就来总结下SpringCache的用法。</p>","more":"<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>   SpringCache借助注解来实现对数据的缓存及删除。所以，这里以每个注解为入口依次了解他们的使用。</p>\n<h4 id=\"EnableCaching\"><a href=\"#EnableCaching\" class=\"headerlink\" title=\"@EnableCaching\"></a>@EnableCaching</h4><p>   @EnableCaching注解用来开启SpringCache的缓存功能。<br>   首先来看看他的结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Import</span>(CachingConfigurationSelector<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">public</span> @<span class=\"title\">interface</span> <span class=\"title\">EnableCaching</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 开启基于CGLIB代理的开关，默认为基于JDK的代理</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">proxyTargetClass</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">// AOP的实现方式，默认为基于JDK的，也可以基于AspectJ实现</span></span><br><span class=\"line\">\t<span class=\"function\">AdviceMode <span class=\"title\">mode</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> AdviceMode.PROXY</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 一个切点存在多个通知时的执行顺序，默认最低</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">order</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   接着就开始正式的配置。<br>   一般来说，为了实现个性化配置，我们会单独建一个配置类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">cacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里方便测试，使用最简单的CacheManager</span></span><br><span class=\"line\">        SimpleCacheManager cacheManager = <span class=\"keyword\">new</span> SimpleCacheManager();</span><br><span class=\"line\">        <span class=\"comment\">// 使用CurrentMapCache作为缓存容器，default为默认的key值</span></span><br><span class=\"line\">        cacheManager.setCaches(Arrays.asList(<span class=\"keyword\">new</span> ConcurrentMapCache(<span class=\"string\">\"default\"</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   关于CacheManager的使用，SpringCache提供了对应各种缓存工具实现类。<br>   例如针对redis的RedisCacheManager，还有针对encache的EhCacheCacheManager的等。<br>   这里我们使用的是SimpleCacheManager，通常是用于测试使用，不需要太多配置。</p>\n<h4 id=\"Cacheable\"><a href=\"#Cacheable\" class=\"headerlink\" title=\"@Cacheable\"></a>@Cacheable</h4><p>   @Cacheable用来新增缓存，每次会先判断有无缓存，有则取缓存，无则执行方法并将结果放入缓存<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Cacheable &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存的名字 与cacheNames属性互为别名，两者都是配置缓存名字</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"cacheNames\"</span>)</span><br><span class=\"line\">    String[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"value\"</span>)</span><br><span class=\"line\">    String[] cacheNames() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 定义缓存的key值，使用SpEl，可以动态取入参的值</span></span><br><span class=\"line\">    <span class=\"comment\">// \"\" 表示所有入参的值都被当作key，前提是没有配置keyGenerator</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">key</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 指定key的生成策略</span></span><br><span class=\"line\">    <span class=\"comment\">// 与key属性互斥，二者只能配置一个</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">keyGenerator</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheManager(当定义了多个时使用)</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheManager</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"comment\">// 与CacheManager互斥</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置使用缓存的条件，同样使用SpEl语法</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">condition</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置不适用缓存的条件，使用SpEl语法</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">unless</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 是否使用异步模式，为true时无法使用unless属性</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">sync</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"CachePut\"><a href=\"#CachePut\" class=\"headerlink\" title=\"@CachePut\"></a>@CachePut</h4><p>   @CachePut用来更新缓存，每次都会执行方法并将结果放入缓存<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CachePut &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存名称</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"cacheNames\"</span>)</span><br><span class=\"line\">    String[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"value\"</span>)</span><br><span class=\"line\">    String[] cacheNames() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">key</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key的生成策略</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">keyGenerator</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheManager</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置使用缓存的条件</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">condition</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置不使用缓存的条件</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">unless</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   @CachePut的属性和@Cacheable基本一样，除了没有异步开关属性。</p>\n<h4 id=\"CahceEvict\"><a href=\"#CahceEvict\" class=\"headerlink\" title=\"@CahceEvict\"></a>@CahceEvict</h4><p>   @CacheEvice用来清除缓存，执行方法后会将对应缓存清除掉<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CacheEvict &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存名称</span></span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"cacheNames\"</span>)</span><br><span class=\"line\">    String[] value() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"meta\">@AliasFor</span>(<span class=\"string\">\"value\"</span>)</span><br><span class=\"line\">    String[] cacheNames() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">key</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key的生成策略</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">keyGenerator</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheManager</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置删除缓存的条件</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">condition</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 是否删除缓存内所有内容，当为true时，不能指定key</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">allEntries</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 是否在方法执行前删除缓存</span></span><br><span class=\"line\">    <span class=\"comment\">// 若为true则表示在方法执行前就删除缓存，方法执行成功与否不影响删除操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">beforeInvocation</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"keyword\">false</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Caching\"><a href=\"#Caching\" class=\"headerlink\" title=\"@Caching\"></a>@Caching</h4><p>   @Cacheing用作在同一方法上配置多个缓存操作<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Caching &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 多个缓存操作</span></span><br><span class=\"line\">    Cacheable[] cacheable() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 多个更新缓存操作</span></span><br><span class=\"line\">    CachePut[] put() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 多个缓存删除操作</span></span><br><span class=\"line\">    CacheEvict[] evict() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CacheConfig\"><a href=\"#CacheConfig\" class=\"headerlink\" title=\"@CacheConfig\"></a>@CacheConfig</h4><p>   @CacheConfig提供了公用配置的实现，避免多次重复配置<br>   源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target</span>(ElementType.TYPE)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> CacheConfig &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存名称</span></span><br><span class=\"line\">    String[] cacheNames() <span class=\"keyword\">default</span> &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存key的生成策略</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">keyGenerator</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheManager</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 自定义的CacheResolver</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用示例\"><a href=\"#使用示例\" class=\"headerlink\" title=\"使用示例\"></a>使用示例</h3><p>   虽然SpringCache简化了对缓存的操作，但相应的也有了很多限制。</p>\n<h4 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h4><p>   三个缓存的操作注解分别对应查询，更新，删除操作，但更新操作需要方法也返回对应的结果集。<br>   而更新的接口通常只会返回操作结果，成功或者失败。所以这里使用@CacheEvice直接删除缓存会更方便些。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable</span>(key = <span class=\"string\">\"#key\"</span>, value = <span class=\"string\">\"default\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getInfo</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// find data from DB</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@CacheEvict</span>(key = <span class=\"string\">\"#key\"</span>, value = <span class=\"string\">\"default\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">update</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// update data</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 每次更新操作后都会清除缓存，这样下次执行查询操作就会直接走库，达到缓存更新的目的。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多个CacheManager\"><a href=\"#多个CacheManager\" class=\"headerlink\" title=\"多个CacheManager\"></a>多个CacheManager</h4><p>   前面有说到，我们可以配置多个不同的CacheManager,然后在每个操作注解上指定想要的CacheManager。<br>   这里简单举一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// @Primary指定默认的CacheManager</span></span><br><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">cacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    SimpleCacheManager cacheManager = <span class=\"keyword\">new</span> SimpleCacheManager();</span><br><span class=\"line\">    cacheManager.setCaches(Arrays.asList(<span class=\"keyword\">new</span> ConcurrentMapCache(<span class=\"string\">\"default\"</span>)));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">slaveCacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ConcurrentMapCacheManager cacheManager = <span class=\"keyword\">new</span> ConcurrentMapCacheManager();</span><br><span class=\"line\">    List&lt;String&gt; list = Lists.newArrayList();</span><br><span class=\"line\">    list.add(<span class=\"string\">\"salve1\"</span>);</span><br><span class=\"line\">    list.add(<span class=\"string\">\"salve2\"</span>);</span><br><span class=\"line\">    cacheManager.setCacheNames(list);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定了slaveCacheManager 相应的缓存的名称也改为对应的salve1</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@Cacheable</span>(key = <span class=\"string\">\"#key\"</span>, cacheManager = <span class=\"string\">\"slaveCacheManager\"</span>,value = <span class=\"string\">\"salve1\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">cacheAbleTest</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"cache able:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"string\">\"cache able\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 没有指定CacheManager所以会使用默认的</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"meta\">@CachePut</span>(key = <span class=\"string\">\"#key\"</span>, value = <span class=\"string\">\"default\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">cachePutTest</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">    log.info(<span class=\"string\">\"cache put:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = <span class=\"string\">\"cache put\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"CacheResolver的使用\"><a href=\"#CacheResolver的使用\" class=\"headerlink\" title=\"CacheResolver的使用\"></a>CacheResolver的使用</h4><p>  先看看默认实现的CacheResolver：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现了CacheResolver的抽象类，默认实现的CacheResolver也是继承自该抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractCacheResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">CacheResolver</span>, <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> CacheManager cacheManager;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractCacheResolver</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">AbstractCacheResolver</span><span class=\"params\">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cacheManager = cacheManager;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCacheManager</span><span class=\"params\">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cacheManager = cacheManager;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">getCacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Assert.state(<span class=\"keyword\">this</span>.cacheManager != <span class=\"keyword\">null</span>, <span class=\"string\">\"No CacheManager set\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.cacheManager;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">    Assert.notNull(<span class=\"keyword\">this</span>.cacheManager, <span class=\"string\">\"CacheManager is required\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实现自接口的方法，返回包含缓存对象的集合</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Collection&lt;? extends Cache&gt; resolveCaches(CacheOperationInvocationContext&lt;?&gt; context) &#123;</span><br><span class=\"line\">    Collection&lt;String&gt; cacheNames = getCacheNames(context);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cacheNames == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Collections.emptyList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Collection&lt;Cache&gt; result = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(cacheNames.size());</span><br><span class=\"line\">    <span class=\"comment\">// 通过缓存名称获取不同的cacheManager</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String cacheName : cacheNames) &#123;</span><br><span class=\"line\">      Cache cache = getCacheManager().getCache(cacheName);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (cache == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Cannot find cache named '\"</span> +</span><br><span class=\"line\">            cacheName + <span class=\"string\">\"' for \"</span> + context.getOperation());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      result.add(cache);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Collection&lt;String&gt; <span class=\"title\">getCacheNames</span><span class=\"params\">(CacheOperationInvocationContext&lt;?&gt; context)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 继承了抽象类AbstractCacheResolver</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleCacheResolver</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractCacheResolver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleCacheResolver</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 构造方法，设置指定的CacheManager</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleCacheResolver</span><span class=\"params\">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(cacheManager);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> Collection&lt;String&gt; <span class=\"title\">getCacheNames</span><span class=\"params\">(CacheOperationInvocationContext&lt;?&gt; context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> context.getOperation().getCacheNames();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> SimpleCacheResolver <span class=\"title\">of</span><span class=\"params\">(@Nullable CacheManager cacheManager)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (cacheManager != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> SimpleCacheResolver(cacheManager) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   从上述代码可以看出，CacheResolver的作用是管理CacheManager，可以根据特定规则选择CacheManager。<br>   下面是根据上述例子实现的CacheResolver，根据缓存名称返回CacheManager:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCacheResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">CacheResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(MyCacheResolver<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;CacheManager&gt; cacheManagerList;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyCacheResolver</span><span class=\"params\">(List&lt;CacheManager&gt; cacheManagerList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cacheManagerList = cacheManagerList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Collection&lt;? extends Cache&gt; resolveCaches(CacheOperationInvocationContext&lt;?&gt; context) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// context包含的内容</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">\"method name :&#123;&#125;\"</span>, context.getMethod().getName());</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"args:&#123;&#125;\"</span>, context.getArgs());</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"target:&#123;&#125;\"</span>, context.getTarget());</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前执行方法设置的缓存名称</span></span><br><span class=\"line\">        String[] values = context.getMethod().getAnnotation(Cacheable<span class=\"class\">.<span class=\"keyword\">class</span>).<span class=\"title\">value</span>()</span>;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"cacheName:&#123;&#125;\"</span>, values);</span><br><span class=\"line\">        Collection&lt;Cache&gt; caches = Lists.newArrayList();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (CacheManager cacheManager : cacheManagerList) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 根据缓存名称从集合中选择CacheManager</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cacheManager.getCacheNames().contains(values[<span class=\"number\">0</span>])) &#123;</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"cache manager:&#123;&#125;\"</span>, cacheManager);</span><br><span class=\"line\">                caches.add(cacheManager.getCache(values[<span class=\"number\">0</span>]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> caches;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 然后在配置中新建对应的CacheResolver方法</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Primary</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">cacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        SimpleCacheManager cacheManager = <span class=\"keyword\">new</span> SimpleCacheManager();</span><br><span class=\"line\">        cacheManager.setCaches(Arrays.asList(<span class=\"keyword\">new</span> ConcurrentMapCache(<span class=\"string\">\"default\"</span>)));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">slaveCacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ConcurrentMapCacheManager cacheManager = <span class=\"keyword\">new</span> ConcurrentMapCacheManager();</span><br><span class=\"line\">        List&lt;String&gt; list = Lists.newArrayList();</span><br><span class=\"line\">        list.add(<span class=\"string\">\"salve1\"</span>);</span><br><span class=\"line\">        list.add(<span class=\"string\">\"salve2\"</span>);</span><br><span class=\"line\">        cacheManager.setCacheNames(list);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cacheManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> CacheResolver <span class=\"title\">cacheResolver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;CacheManager&gt; list = Lists.newArrayList();</span><br><span class=\"line\">        list.add(cacheManager());</span><br><span class=\"line\">        list.add(slaveCacheManager());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyCacheResolver(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  不得不说，SpringCache极大的简化了项目中对缓存的使用。\n  不过，这也意味着限制了对缓存的操作，就目前来看，SpringCache适合于获取变化较少的数据的\n查询接口上，例如一些配置信息的查询等。\n  当然，SpringCache也提供了CacheManager和CacheResolver共开发者扩展，不过本章只是简单\n展示了他们的用法，所以暂时不了解他们更多的运用技巧。\n  总体来说，SpringCache的优势在于快速实现，代码规范化及简化，兼容性高，扩展性都比较高。\n如果不考虑对缓存生命周期设置或者一些精细操作上的需求，SpringCache必然是最好的选择。</code></pre>"},{"title":"MyBatis-if标签判断问题","date":"2020-11-11T14:49:43.000Z","_content":"\n### 前言\n\n  最近在使用mybatis的if标签时遇到一个有趣的问题，这里记录一下。\n<!-- more -->\n\n### if标签的字符比较\n\n  mybatis的if标签是用来在拼装sql时做一些判断。\n  如果我们需要判断的对象是单个字符，比如下面的例子：\n{% codeblock lang:xml%}\n<if test=\"param == 'N'\">\n  and column_name = #{param}\n</if>\n{% endcodeblock %}\n\n  如果这样写，会发现程序抛出类型转换异常。\n  究其原因是这里将*N* 当作了char类型处理，而不是字符串。而传进来的param是String类型。\n  如果追踪源码会发现在比较的时候两者无法相等，会在一个switch判断中走入强转double操作的分支，导致异常报错。\n\n  而解决该问题的办法就是避免mybatis的“误认”：\n\n{% codeblock lang:xml%}\n<if test=\"param == 'N'.toString()\">\n  and column_name = #{param}\n</if>\n\n<if test='param == \"N\"'>\n  and column_name = #{param}\n</if>\n{% endcodeblock %}\n  \n  如上两种写法就能避免这种问题。","source":"_posts/2020/11/mybatis-if1.md","raw":"---\ntitle: MyBatis-if标签判断问题\ndate: 2020-11-11 22:49:43\ntags:\n- MyBatis\ncategories:\n- MyBatis\n---\n\n### 前言\n\n  最近在使用mybatis的if标签时遇到一个有趣的问题，这里记录一下。\n<!-- more -->\n\n### if标签的字符比较\n\n  mybatis的if标签是用来在拼装sql时做一些判断。\n  如果我们需要判断的对象是单个字符，比如下面的例子：\n{% codeblock lang:xml%}\n<if test=\"param == 'N'\">\n  and column_name = #{param}\n</if>\n{% endcodeblock %}\n\n  如果这样写，会发现程序抛出类型转换异常。\n  究其原因是这里将*N* 当作了char类型处理，而不是字符串。而传进来的param是String类型。\n  如果追踪源码会发现在比较的时候两者无法相等，会在一个switch判断中走入强转double操作的分支，导致异常报错。\n\n  而解决该问题的办法就是避免mybatis的“误认”：\n\n{% codeblock lang:xml%}\n<if test=\"param == 'N'.toString()\">\n  and column_name = #{param}\n</if>\n\n<if test='param == \"N\"'>\n  and column_name = #{param}\n</if>\n{% endcodeblock %}\n  \n  如上两种写法就能避免这种问题。","slug":"mybatis-if1","published":1,"updated":"2020-11-13T13:54:11.561Z","_id":"ckhevyvc20000twb563x30myv","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  最近在使用mybatis的if标签时遇到一个有趣的问题，这里记录一下。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"if标签的字符比较\"><a href=\"#if标签的字符比较\" class=\"headerlink\" title=\"if标签的字符比较\"></a>if标签的字符比较</h3><p>  mybatis的if标签是用来在拼装sql时做一些判断。<br>  如果我们需要判断的对象是单个字符，比如下面的例子：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">\"param == 'N'\"</span>&gt;</span></span><br><span class=\"line\">  and column_name = #&#123;param&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>  如果这样写，会发现程序抛出类型转换异常。<br>  究其原因是这里将<em>N</em> 当作了char类型处理，而不是字符串。而传进来的param是String类型。<br>  如果追踪源码会发现在比较的时候两者无法相等，会在一个switch判断中走入强转double操作的分支，导致异常报错。</p>\n<p>  而解决该问题的办法就是避免mybatis的“误认”：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">\"param == 'N'.toString()\"</span>&gt;</span></span><br><span class=\"line\">  and column_name = #&#123;param&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">'param == \"N\"'</span>&gt;</span></span><br><span class=\"line\">  and column_name = #&#123;param&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>  如上两种写法就能避免这种问题。</p>\n","site":{"data":{}},"length":266,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  最近在使用mybatis的if标签时遇到一个有趣的问题，这里记录一下。</p>","more":"<h3 id=\"if标签的字符比较\"><a href=\"#if标签的字符比较\" class=\"headerlink\" title=\"if标签的字符比较\"></a>if标签的字符比较</h3><p>  mybatis的if标签是用来在拼装sql时做一些判断。<br>  如果我们需要判断的对象是单个字符，比如下面的例子：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">\"param == 'N'\"</span>&gt;</span></span><br><span class=\"line\">  and column_name = #&#123;param&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>  如果这样写，会发现程序抛出类型转换异常。<br>  究其原因是这里将<em>N</em> 当作了char类型处理，而不是字符串。而传进来的param是String类型。<br>  如果追踪源码会发现在比较的时候两者无法相等，会在一个switch判断中走入强转double操作的分支，导致异常报错。</p>\n<p>  而解决该问题的办法就是避免mybatis的“误认”：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">\"param == 'N'.toString()\"</span>&gt;</span></span><br><span class=\"line\">  and column_name = #&#123;param&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">if</span> <span class=\"attr\">test</span>=<span class=\"string\">'param == \"N\"'</span>&gt;</span></span><br><span class=\"line\">  and column_name = #&#123;param&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">if</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>  如上两种写法就能避免这种问题。</p>"},{"title":"final修饰入参的问题","date":"2020-11-11T14:49:56.000Z","_content":"\n### 前言\n\n  最近在使用itext导出pdf的时候遇到一个关于final修饰入参的问题，这里记录一下。\n<!-- more -->\n\n### final修饰入参\n\n  首先看看正确例子\n{% img  /image/final/final1.png  '\"正确例子\"' %}\n\n  错误例子\n{% img  /image/final/final2.png  '\"错误例子\"' %}\n\n\n  两个例子一个是分别判断去new，一个是先new再调用set方法。\n  为什么说第一个例子是错误例子呢？\n  先看看这里的setFont()方法：\n{% img  /image/final/final3.png  '\"构造方法\"' %}\n\n  这里展示的是Paragraph类的父类Phrase的构造方法，当调用*new Paragraph(value)*时，其底层就是调用的这个方法。\n  可以看到这里用final修饰入参font，表示在第一次传入参数后，就会永远指向这个对象不再改变。\n  所以在错误例子中，当调用Paragraph构造方法时，font属性的值已被“锁定”，后续调用set方法也无法改变他的值。\n\n### 总结\n\n  这个关于final的使用虽然是一个很基础的知识点，但是当时却还是花了较多时间去定位问题。\n  因为极少会碰到用final修饰入参的情况，一开始也没注意这里用final修饰。\n  后续也思考了下这里为啥要这么写，没有一个确定的答案。\n  只能从效果推测应该是不希望二次修改属性值。\n\n\n","source":"_posts/2020/11/itext-final1.md","raw":"---\ntitle: final修饰入参的问题\ndate: 2020-11-11 22:49:56\ntags:\n- final\ncategories:\n- Java\n- 基础\n---\n\n### 前言\n\n  最近在使用itext导出pdf的时候遇到一个关于final修饰入参的问题，这里记录一下。\n<!-- more -->\n\n### final修饰入参\n\n  首先看看正确例子\n{% img  /image/final/final1.png  '\"正确例子\"' %}\n\n  错误例子\n{% img  /image/final/final2.png  '\"错误例子\"' %}\n\n\n  两个例子一个是分别判断去new，一个是先new再调用set方法。\n  为什么说第一个例子是错误例子呢？\n  先看看这里的setFont()方法：\n{% img  /image/final/final3.png  '\"构造方法\"' %}\n\n  这里展示的是Paragraph类的父类Phrase的构造方法，当调用*new Paragraph(value)*时，其底层就是调用的这个方法。\n  可以看到这里用final修饰入参font，表示在第一次传入参数后，就会永远指向这个对象不再改变。\n  所以在错误例子中，当调用Paragraph构造方法时，font属性的值已被“锁定”，后续调用set方法也无法改变他的值。\n\n### 总结\n\n  这个关于final的使用虽然是一个很基础的知识点，但是当时却还是花了较多时间去定位问题。\n  因为极少会碰到用final修饰入参的情况，一开始也没注意这里用final修饰。\n  后续也思考了下这里为啥要这么写，没有一个确定的答案。\n  只能从效果推测应该是不希望二次修改属性值。\n\n\n","slug":"itext-final1","published":1,"updated":"2020-11-12T14:32:04.776Z","_id":"ckhevyvc80001twb551ou7hn7","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  最近在使用itext导出pdf的时候遇到一个关于final修饰入参的问题，这里记录一下。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"final修饰入参\"><a href=\"#final修饰入参\" class=\"headerlink\" title=\"final修饰入参\"></a>final修饰入参</h3><p>  首先看看正确例子</p>\n<img src=\"/image/final/final1.png\" class=\"\" title=\"正确例子\">\n\n<p>  错误例子</p>\n<img src=\"/image/final/final2.png\" class=\"\" title=\"错误例子\">\n\n\n<p>  两个例子一个是分别判断去new，一个是先new再调用set方法。<br>  为什么说第一个例子是错误例子呢？<br>  先看看这里的setFont()方法：</p>\n<img src=\"/image/final/final3.png\" class=\"\" title=\"构造方法\">\n\n<p>  这里展示的是Paragraph类的父类Phrase的构造方法，当调用<em>new Paragraph(value)</em>时，其底层就是调用的这个方法。<br>  可以看到这里用final修饰入参font，表示在第一次传入参数后，就会永远指向这个对象不再改变。<br>  所以在错误例子中，当调用Paragraph构造方法时，font属性的值已被“锁定”，后续调用set方法也无法改变他的值。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>  这个关于final的使用虽然是一个很基础的知识点，但是当时却还是花了较多时间去定位问题。<br>  因为极少会碰到用final修饰入参的情况，一开始也没注意这里用final修饰。<br>  后续也思考了下这里为啥要这么写，没有一个确定的答案。<br>  只能从效果推测应该是不希望二次修改属性值。</p>\n","site":{"data":{}},"length":441,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  最近在使用itext导出pdf的时候遇到一个关于final修饰入参的问题，这里记录一下。</p>","more":"<h3 id=\"final修饰入参\"><a href=\"#final修饰入参\" class=\"headerlink\" title=\"final修饰入参\"></a>final修饰入参</h3><p>  首先看看正确例子</p>\n<img src=\"/image/final/final1.png\" class=\"\" title=\"正确例子\">\n\n<p>  错误例子</p>\n<img src=\"/image/final/final2.png\" class=\"\" title=\"错误例子\">\n\n\n<p>  两个例子一个是分别判断去new，一个是先new再调用set方法。<br>  为什么说第一个例子是错误例子呢？<br>  先看看这里的setFont()方法：</p>\n<img src=\"/image/final/final3.png\" class=\"\" title=\"构造方法\">\n\n<p>  这里展示的是Paragraph类的父类Phrase的构造方法，当调用<em>new Paragraph(value)</em>时，其底层就是调用的这个方法。<br>  可以看到这里用final修饰入参font，表示在第一次传入参数后，就会永远指向这个对象不再改变。<br>  所以在错误例子中，当调用Paragraph构造方法时，font属性的值已被“锁定”，后续调用set方法也无法改变他的值。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>  这个关于final的使用虽然是一个很基础的知识点，但是当时却还是花了较多时间去定位问题。<br>  因为极少会碰到用final修饰入参的情况，一开始也没注意这里用final修饰。<br>  后续也思考了下这里为啥要这么写，没有一个确定的答案。<br>  只能从效果推测应该是不希望二次修改属性值。</p>"},{"title":"初识NIO","date":"2021-01-16T03:38:38.000Z","_content":"\n### 前言\n    \n   最近做技术分享，选择的主题是NIO。将分享内容记录一下，方便以后回顾。\n<!-- more -->\n\n### 不同的IO处理模型\n\n   首先来了解下集中常用的IO处理模型。\n\n#### BIO\n   BIO是同步阻塞IO，他的特点是读取数据必须在读到数据前提下才会返回，所以会发生阻塞。\n   而要解决BIO阻塞带来的效率问题，就需要使用到多线程。\n   建立一个线程专门用于读取数据，读到数据返回后，就开辟新的线程去处理数据，而原有线程继续阻塞式的读取数据。\n   在连接数没那么多的时候，这种处理模式确实能充分利用CPU，但是当连接数达到一定级别时，这种\n   模式在线程切换，创建销毁上的性能，资源损耗就会成倍增加。\n   这时候就需要新的IO处理模型。\n#### NIO\n   NIO作为同步非阻塞IO，他与BIO的不同之处在于读取数据的操作不会阻塞，不管有没有读到数据都会立刻返回。\n   而且NIO的相关操作都会返回操作结果，告诉我们是否读取到数据等，这就方便我们进行操作。而不会像操作BIO一样，只能傻等着。\n\n#### AIO\n   AIO在NIO的基础上更进一步，不仅读取数据是非阻塞的，而且在进行I/O操作时，采用的是异步方式，也是非阻塞的。\n   因此，AIO被叫做异步非阻塞IO。\n\n### NIO的操作\n   在了解了几种IO处理模型的工作方式与不同点后，回到正题，来看看如何使用NIO。\n   首先，NIO有三大模块：\n   1. Buffer：缓冲区，用于存储数据\n   2. Channel：通道，用于传输数据\n   3. Selector：选择器，会监听通道的事件，借此可实现对读写操作的自定义处理\n\n\n  下面来看看示例代码\n\n{% codeblock lang:java %}\n// 服务端代码\npublic void testNioServer() throws IOException {\n    // 创建服务端连接并设置为非阻塞\n    ServerSocketChannel serverChannel = ServerSocketChannel.open();\n    serverChannel.configureBlocking(false);\n    // 创建选择器\n    Selector selector = Selector.open();\n    // 注册channel到选择器\n    SelectionKey key = serverChannel.register(selector, 0, serverChannel);\n    // 设置关注事件\n    key.interestOps(SelectionKey.OP_ACCEPT);\n    // 绑定\n    serverChannel.socket().bind(new InetSocketAddress(8888));\n    logger.info(\"服务端启动\");\n    while (true) {\n        // 查询事件，直到有时间通知才会返回\n        selector.select();\n        // 获取返回的事件\n        Set<SelectionKey> keySet = selector.selectedKeys();\n        Iterator<SelectionKey> it = keySet.iterator();\n        while (it.hasNext()) {\n            SelectionKey currentKey = it.next();\n            // 从选择器集合中移除 避免重复处理\n            it.remove();\n            // 判断连接状态\n            if (currentKey.isAcceptable()) {\n                // 获取当前的channel\n                ServerSocketChannel server = (ServerSocketChannel) currentKey.attachment();\n                // 接受客户端连接\n                SocketChannel clientChannel = server.accept();\n                clientChannel.configureBlocking(false);\n                // 注册selector 读操作\n                clientChannel.register(selector, SelectionKey.OP_READ, clientChannel);\n                logger.info(\"新连接：{}\", clientChannel.getRemoteAddress());\n            }\n            // 判断读取状态\n            if (currentKey.isReadable()) {\n                SocketChannel currentChannel = (SocketChannel) currentKey.attachment();\n                // 建立缓冲区\n                ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n                // 读操作\n                int count = 0;\n                while (currentChannel.isOpen() && currentChannel.read(readBuffer) != -1) {\n                    // 读取完成 跳出循环\n                    if (readBuffer.position() == count) {\n                        break;\n                    }\n                    count = readBuffer.position();\n                }\n                if (readBuffer.position() == 0) {\n                    continue;\n                }\n                // 重置指针\n                readBuffer.flip();\n                // limit表示缓冲区内能读到的最大大小\n                byte[] content = new byte[readBuffer.limit()];\n                readBuffer.get(content);\n                logger.info(\"读取内容：{}\", new String(content\n                // 响应\n                String msg = \"收到了：\" + currentChannel.getRemoteAddress();\n                ByteBuffer responseBuffer = ByteBuffer.wrap(msg.getBytes());\n                // 判断是否还有数据未读\n                while (responseBuffer.hasRemaining()) {\n                    // 写操作\n                    currentChannel.write(responseBuffer);\n                }\n            }\n        }\n    }\n}\n// 客户端代码\npublic void testNioClient() throws IOException {\n    SocketChannel clientChannel = SocketChannel.open();\n    clientChannel.configureBlocking(false);\n    clientChannel.connect(new InetSocketAddress(\"127.0.0.1\", 8888));\n    // 判断连接是否完成\n    while (!clientChannel.finishConnect()) {\n        Thread.yield();\n    }\n    logger.info(\"客户端启动\");\n    String msg = \"测试NIO:12345689你好呀@\";\n    ByteBuffer writeBuffer = ByteBuffer.wrap(msg.getBytes());\n    while (writeBuffer.hasRemaining()) {\n        clientChannel.write(writeBuffer);\n    }\n    logger.info(\"收取响应\");\n    ByteBuffer responseBuffer = ByteBuffer.allocate(1024);\n    int count = 0;\n    while (clientChannel.isOpen() && clientChannel.read(responseBuffer) != -1) {\n        // 读取完成 跳出循环\n        if (responseBuffer.position() > 0 && responseBuffer.position() == count) {\n            break;\n        }\n        count = responseBuffer.position();\n    }\n    responseBuffer.flip();\n    byte[] content = new byte[responseBuffer.limit()];\n    responseBuffer.get(content);\n    logger.info(\"响应内容：{}\", new String(content));\n    clientChannel.close();\n}\n{% endcodeblock%}\n\n### 总结\n      本章简单介绍了几种IO模型，并初步了解NIO的特点与用法。\n      相比于BIO极度依赖多线程，NIO只用单线程就可以高效的完成IO操作。使其在高数量的连接场景\n    下依旧有很好性能保证。\n\n### 参考\n>[Java NIO浅析](https://tech.meituan.com/2016/11/04/nio.html)\n\n### 推荐阅读\n>[Scalable IO in Java](http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf)\n","source":"_posts/2021/01/nio1.md","raw":"---\ntitle: 初识NIO\ndate: 2021-01-16 11:38:38\ntags:\n- NIO\ncategories:\n- Java\n- NIO\n---\n\n### 前言\n    \n   最近做技术分享，选择的主题是NIO。将分享内容记录一下，方便以后回顾。\n<!-- more -->\n\n### 不同的IO处理模型\n\n   首先来了解下集中常用的IO处理模型。\n\n#### BIO\n   BIO是同步阻塞IO，他的特点是读取数据必须在读到数据前提下才会返回，所以会发生阻塞。\n   而要解决BIO阻塞带来的效率问题，就需要使用到多线程。\n   建立一个线程专门用于读取数据，读到数据返回后，就开辟新的线程去处理数据，而原有线程继续阻塞式的读取数据。\n   在连接数没那么多的时候，这种处理模式确实能充分利用CPU，但是当连接数达到一定级别时，这种\n   模式在线程切换，创建销毁上的性能，资源损耗就会成倍增加。\n   这时候就需要新的IO处理模型。\n#### NIO\n   NIO作为同步非阻塞IO，他与BIO的不同之处在于读取数据的操作不会阻塞，不管有没有读到数据都会立刻返回。\n   而且NIO的相关操作都会返回操作结果，告诉我们是否读取到数据等，这就方便我们进行操作。而不会像操作BIO一样，只能傻等着。\n\n#### AIO\n   AIO在NIO的基础上更进一步，不仅读取数据是非阻塞的，而且在进行I/O操作时，采用的是异步方式，也是非阻塞的。\n   因此，AIO被叫做异步非阻塞IO。\n\n### NIO的操作\n   在了解了几种IO处理模型的工作方式与不同点后，回到正题，来看看如何使用NIO。\n   首先，NIO有三大模块：\n   1. Buffer：缓冲区，用于存储数据\n   2. Channel：通道，用于传输数据\n   3. Selector：选择器，会监听通道的事件，借此可实现对读写操作的自定义处理\n\n\n  下面来看看示例代码\n\n{% codeblock lang:java %}\n// 服务端代码\npublic void testNioServer() throws IOException {\n    // 创建服务端连接并设置为非阻塞\n    ServerSocketChannel serverChannel = ServerSocketChannel.open();\n    serverChannel.configureBlocking(false);\n    // 创建选择器\n    Selector selector = Selector.open();\n    // 注册channel到选择器\n    SelectionKey key = serverChannel.register(selector, 0, serverChannel);\n    // 设置关注事件\n    key.interestOps(SelectionKey.OP_ACCEPT);\n    // 绑定\n    serverChannel.socket().bind(new InetSocketAddress(8888));\n    logger.info(\"服务端启动\");\n    while (true) {\n        // 查询事件，直到有时间通知才会返回\n        selector.select();\n        // 获取返回的事件\n        Set<SelectionKey> keySet = selector.selectedKeys();\n        Iterator<SelectionKey> it = keySet.iterator();\n        while (it.hasNext()) {\n            SelectionKey currentKey = it.next();\n            // 从选择器集合中移除 避免重复处理\n            it.remove();\n            // 判断连接状态\n            if (currentKey.isAcceptable()) {\n                // 获取当前的channel\n                ServerSocketChannel server = (ServerSocketChannel) currentKey.attachment();\n                // 接受客户端连接\n                SocketChannel clientChannel = server.accept();\n                clientChannel.configureBlocking(false);\n                // 注册selector 读操作\n                clientChannel.register(selector, SelectionKey.OP_READ, clientChannel);\n                logger.info(\"新连接：{}\", clientChannel.getRemoteAddress());\n            }\n            // 判断读取状态\n            if (currentKey.isReadable()) {\n                SocketChannel currentChannel = (SocketChannel) currentKey.attachment();\n                // 建立缓冲区\n                ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n                // 读操作\n                int count = 0;\n                while (currentChannel.isOpen() && currentChannel.read(readBuffer) != -1) {\n                    // 读取完成 跳出循环\n                    if (readBuffer.position() == count) {\n                        break;\n                    }\n                    count = readBuffer.position();\n                }\n                if (readBuffer.position() == 0) {\n                    continue;\n                }\n                // 重置指针\n                readBuffer.flip();\n                // limit表示缓冲区内能读到的最大大小\n                byte[] content = new byte[readBuffer.limit()];\n                readBuffer.get(content);\n                logger.info(\"读取内容：{}\", new String(content\n                // 响应\n                String msg = \"收到了：\" + currentChannel.getRemoteAddress();\n                ByteBuffer responseBuffer = ByteBuffer.wrap(msg.getBytes());\n                // 判断是否还有数据未读\n                while (responseBuffer.hasRemaining()) {\n                    // 写操作\n                    currentChannel.write(responseBuffer);\n                }\n            }\n        }\n    }\n}\n// 客户端代码\npublic void testNioClient() throws IOException {\n    SocketChannel clientChannel = SocketChannel.open();\n    clientChannel.configureBlocking(false);\n    clientChannel.connect(new InetSocketAddress(\"127.0.0.1\", 8888));\n    // 判断连接是否完成\n    while (!clientChannel.finishConnect()) {\n        Thread.yield();\n    }\n    logger.info(\"客户端启动\");\n    String msg = \"测试NIO:12345689你好呀@\";\n    ByteBuffer writeBuffer = ByteBuffer.wrap(msg.getBytes());\n    while (writeBuffer.hasRemaining()) {\n        clientChannel.write(writeBuffer);\n    }\n    logger.info(\"收取响应\");\n    ByteBuffer responseBuffer = ByteBuffer.allocate(1024);\n    int count = 0;\n    while (clientChannel.isOpen() && clientChannel.read(responseBuffer) != -1) {\n        // 读取完成 跳出循环\n        if (responseBuffer.position() > 0 && responseBuffer.position() == count) {\n            break;\n        }\n        count = responseBuffer.position();\n    }\n    responseBuffer.flip();\n    byte[] content = new byte[responseBuffer.limit()];\n    responseBuffer.get(content);\n    logger.info(\"响应内容：{}\", new String(content));\n    clientChannel.close();\n}\n{% endcodeblock%}\n\n### 总结\n      本章简单介绍了几种IO模型，并初步了解NIO的特点与用法。\n      相比于BIO极度依赖多线程，NIO只用单线程就可以高效的完成IO操作。使其在高数量的连接场景\n    下依旧有很好性能保证。\n\n### 参考\n>[Java NIO浅析](https://tech.meituan.com/2016/11/04/nio.html)\n\n### 推荐阅读\n>[Scalable IO in Java](http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf)\n","slug":"nio1","published":1,"updated":"2021-01-16T11:29:02.461Z","_id":"ckjzgmq6y0000dsb5gfi64u3x","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   最近做技术分享，选择的主题是NIO。将分享内容记录一下，方便以后回顾。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"不同的IO处理模型\"><a href=\"#不同的IO处理模型\" class=\"headerlink\" title=\"不同的IO处理模型\"></a>不同的IO处理模型</h3><p>   首先来了解下集中常用的IO处理模型。</p>\n<h4 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h4><p>   BIO是同步阻塞IO，他的特点是读取数据必须在读到数据前提下才会返回，所以会发生阻塞。<br>   而要解决BIO阻塞带来的效率问题，就需要使用到多线程。<br>   建立一个线程专门用于读取数据，读到数据返回后，就开辟新的线程去处理数据，而原有线程继续阻塞式的读取数据。<br>   在连接数没那么多的时候，这种处理模式确实能充分利用CPU，但是当连接数达到一定级别时，这种<br>   模式在线程切换，创建销毁上的性能，资源损耗就会成倍增加。<br>   这时候就需要新的IO处理模型。</p>\n<h4 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h4><p>   NIO作为同步非阻塞IO，他与BIO的不同之处在于读取数据的操作不会阻塞，不管有没有读到数据都会立刻返回。<br>   而且NIO的相关操作都会返回操作结果，告诉我们是否读取到数据等，这就方便我们进行操作。而不会像操作BIO一样，只能傻等着。</p>\n<h4 id=\"AIO\"><a href=\"#AIO\" class=\"headerlink\" title=\"AIO\"></a>AIO</h4><p>   AIO在NIO的基础上更进一步，不仅读取数据是非阻塞的，而且在进行I/O操作时，采用的是异步方式，也是非阻塞的。<br>   因此，AIO被叫做异步非阻塞IO。</p>\n<h3 id=\"NIO的操作\"><a href=\"#NIO的操作\" class=\"headerlink\" title=\"NIO的操作\"></a>NIO的操作</h3><p>   在了解了几种IO处理模型的工作方式与不同点后，回到正题，来看看如何使用NIO。<br>   首先，NIO有三大模块：</p>\n<ol>\n<li>Buffer：缓冲区，用于存储数据</li>\n<li>Channel：通道，用于传输数据</li>\n<li>Selector：选择器，会监听通道的事件，借此可实现对读写操作的自定义处理</li>\n</ol>\n<p>  下面来看看示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 服务端代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testNioServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建服务端连接并设置为非阻塞</span></span><br><span class=\"line\">    ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class=\"line\">    serverChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 创建选择器</span></span><br><span class=\"line\">    Selector selector = Selector.open();</span><br><span class=\"line\">    <span class=\"comment\">// 注册channel到选择器</span></span><br><span class=\"line\">    SelectionKey key = serverChannel.register(selector, <span class=\"number\">0</span>, serverChannel);</span><br><span class=\"line\">    <span class=\"comment\">// 设置关注事件</span></span><br><span class=\"line\">    key.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">    <span class=\"comment\">// 绑定</span></span><br><span class=\"line\">    serverChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">8888</span>));</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"服务端启动\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 查询事件，直到有时间通知才会返回</span></span><br><span class=\"line\">        selector.select();</span><br><span class=\"line\">        <span class=\"comment\">// 获取返回的事件</span></span><br><span class=\"line\">        Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; it = keySet.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">            SelectionKey currentKey = it.next();</span><br><span class=\"line\">            <span class=\"comment\">// 从选择器集合中移除 避免重复处理</span></span><br><span class=\"line\">            it.remove();</span><br><span class=\"line\">            <span class=\"comment\">// 判断连接状态</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentKey.isAcceptable()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取当前的channel</span></span><br><span class=\"line\">                ServerSocketChannel server = (ServerSocketChannel) currentKey.attachment();</span><br><span class=\"line\">                <span class=\"comment\">// 接受客户端连接</span></span><br><span class=\"line\">                SocketChannel clientChannel = server.accept();</span><br><span class=\"line\">                clientChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 注册selector 读操作</span></span><br><span class=\"line\">                clientChannel.register(selector, SelectionKey.OP_READ, clientChannel);</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"新连接：&#123;&#125;\"</span>, clientChannel.getRemoteAddress());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 判断读取状态</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentKey.isReadable()) &#123;</span><br><span class=\"line\">                SocketChannel currentChannel = (SocketChannel) currentKey.attachment();</span><br><span class=\"line\">                <span class=\"comment\">// 建立缓冲区</span></span><br><span class=\"line\">                ByteBuffer readBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 读操作</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (currentChannel.isOpen() &amp;&amp; currentChannel.read(readBuffer) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 读取完成 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBuffer.position() == count) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count = readBuffer.position();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (readBuffer.position() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 重置指针</span></span><br><span class=\"line\">                readBuffer.flip();</span><br><span class=\"line\">                <span class=\"comment\">// limit表示缓冲区内能读到的最大大小</span></span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] content = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readBuffer.limit()];</span><br><span class=\"line\">                readBuffer.get(content);</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"读取内容：&#123;&#125;\"</span>, <span class=\"keyword\">new</span> String(content</span><br><span class=\"line\">                <span class=\"comment\">// 响应</span></span><br><span class=\"line\">                String msg = <span class=\"string\">\"收到了：\"</span> + currentChannel.getRemoteAddress();</span><br><span class=\"line\">                ByteBuffer responseBuffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class=\"line\">                <span class=\"comment\">// 判断是否还有数据未读</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (responseBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 写操作</span></span><br><span class=\"line\">                    currentChannel.write(responseBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 客户端代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testNioClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    SocketChannel clientChannel = SocketChannel.open();</span><br><span class=\"line\">    clientChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    clientChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">8888</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 判断连接是否完成</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!clientChannel.finishConnect()) &#123;</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"客户端启动\"</span>);</span><br><span class=\"line\">    String msg = <span class=\"string\">\"测试NIO:12345689你好呀@\"</span>;</span><br><span class=\"line\">    ByteBuffer writeBuffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (writeBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">        clientChannel.write(writeBuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"收取响应\"</span>);</span><br><span class=\"line\">    ByteBuffer responseBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (clientChannel.isOpen() &amp;&amp; clientChannel.read(responseBuffer) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取完成 跳出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (responseBuffer.position() &gt; <span class=\"number\">0</span> &amp;&amp; responseBuffer.position() == count) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count = responseBuffer.position();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    responseBuffer.flip();</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] content = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[responseBuffer.limit()];</span><br><span class=\"line\">    responseBuffer.get(content);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"响应内容：&#123;&#125;\"</span>, <span class=\"keyword\">new</span> String(content));</span><br><span class=\"line\">    clientChannel.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  本章简单介绍了几种IO模型，并初步了解NIO的特点与用法。\n  相比于BIO极度依赖多线程，NIO只用单线程就可以高效的完成IO操作。使其在高数量的连接场景\n下依旧有很好性能保证。</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://tech.meituan.com/2016/11/04/nio.html\" target=\"_blank\" rel=\"noopener\">Java NIO浅析</a></p>\n</blockquote>\n<h3 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h3><blockquote>\n<p><a href=\"http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\" target=\"_blank\" rel=\"noopener\">Scalable IO in Java</a></p>\n</blockquote>\n","site":{"data":{}},"length":727,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   最近做技术分享，选择的主题是NIO。将分享内容记录一下，方便以后回顾。</p>","more":"<h3 id=\"不同的IO处理模型\"><a href=\"#不同的IO处理模型\" class=\"headerlink\" title=\"不同的IO处理模型\"></a>不同的IO处理模型</h3><p>   首先来了解下集中常用的IO处理模型。</p>\n<h4 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h4><p>   BIO是同步阻塞IO，他的特点是读取数据必须在读到数据前提下才会返回，所以会发生阻塞。<br>   而要解决BIO阻塞带来的效率问题，就需要使用到多线程。<br>   建立一个线程专门用于读取数据，读到数据返回后，就开辟新的线程去处理数据，而原有线程继续阻塞式的读取数据。<br>   在连接数没那么多的时候，这种处理模式确实能充分利用CPU，但是当连接数达到一定级别时，这种<br>   模式在线程切换，创建销毁上的性能，资源损耗就会成倍增加。<br>   这时候就需要新的IO处理模型。</p>\n<h4 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h4><p>   NIO作为同步非阻塞IO，他与BIO的不同之处在于读取数据的操作不会阻塞，不管有没有读到数据都会立刻返回。<br>   而且NIO的相关操作都会返回操作结果，告诉我们是否读取到数据等，这就方便我们进行操作。而不会像操作BIO一样，只能傻等着。</p>\n<h4 id=\"AIO\"><a href=\"#AIO\" class=\"headerlink\" title=\"AIO\"></a>AIO</h4><p>   AIO在NIO的基础上更进一步，不仅读取数据是非阻塞的，而且在进行I/O操作时，采用的是异步方式，也是非阻塞的。<br>   因此，AIO被叫做异步非阻塞IO。</p>\n<h3 id=\"NIO的操作\"><a href=\"#NIO的操作\" class=\"headerlink\" title=\"NIO的操作\"></a>NIO的操作</h3><p>   在了解了几种IO处理模型的工作方式与不同点后，回到正题，来看看如何使用NIO。<br>   首先，NIO有三大模块：</p>\n<ol>\n<li>Buffer：缓冲区，用于存储数据</li>\n<li>Channel：通道，用于传输数据</li>\n<li>Selector：选择器，会监听通道的事件，借此可实现对读写操作的自定义处理</li>\n</ol>\n<p>  下面来看看示例代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 服务端代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testNioServer</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建服务端连接并设置为非阻塞</span></span><br><span class=\"line\">    ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class=\"line\">    serverChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 创建选择器</span></span><br><span class=\"line\">    Selector selector = Selector.open();</span><br><span class=\"line\">    <span class=\"comment\">// 注册channel到选择器</span></span><br><span class=\"line\">    SelectionKey key = serverChannel.register(selector, <span class=\"number\">0</span>, serverChannel);</span><br><span class=\"line\">    <span class=\"comment\">// 设置关注事件</span></span><br><span class=\"line\">    key.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class=\"line\">    <span class=\"comment\">// 绑定</span></span><br><span class=\"line\">    serverChannel.socket().bind(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">8888</span>));</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"服务端启动\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 查询事件，直到有时间通知才会返回</span></span><br><span class=\"line\">        selector.select();</span><br><span class=\"line\">        <span class=\"comment\">// 获取返回的事件</span></span><br><span class=\"line\">        Set&lt;SelectionKey&gt; keySet = selector.selectedKeys();</span><br><span class=\"line\">        Iterator&lt;SelectionKey&gt; it = keySet.iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">            SelectionKey currentKey = it.next();</span><br><span class=\"line\">            <span class=\"comment\">// 从选择器集合中移除 避免重复处理</span></span><br><span class=\"line\">            it.remove();</span><br><span class=\"line\">            <span class=\"comment\">// 判断连接状态</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentKey.isAcceptable()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取当前的channel</span></span><br><span class=\"line\">                ServerSocketChannel server = (ServerSocketChannel) currentKey.attachment();</span><br><span class=\"line\">                <span class=\"comment\">// 接受客户端连接</span></span><br><span class=\"line\">                SocketChannel clientChannel = server.accept();</span><br><span class=\"line\">                clientChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 注册selector 读操作</span></span><br><span class=\"line\">                clientChannel.register(selector, SelectionKey.OP_READ, clientChannel);</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"新连接：&#123;&#125;\"</span>, clientChannel.getRemoteAddress());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 判断读取状态</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (currentKey.isReadable()) &#123;</span><br><span class=\"line\">                SocketChannel currentChannel = (SocketChannel) currentKey.attachment();</span><br><span class=\"line\">                <span class=\"comment\">// 建立缓冲区</span></span><br><span class=\"line\">                ByteBuffer readBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 读操作</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (currentChannel.isOpen() &amp;&amp; currentChannel.read(readBuffer) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 读取完成 跳出循环</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (readBuffer.position() == count) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    count = readBuffer.position();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (readBuffer.position() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 重置指针</span></span><br><span class=\"line\">                readBuffer.flip();</span><br><span class=\"line\">                <span class=\"comment\">// limit表示缓冲区内能读到的最大大小</span></span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] content = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[readBuffer.limit()];</span><br><span class=\"line\">                readBuffer.get(content);</span><br><span class=\"line\">                logger.info(<span class=\"string\">\"读取内容：&#123;&#125;\"</span>, <span class=\"keyword\">new</span> String(content</span><br><span class=\"line\">                <span class=\"comment\">// 响应</span></span><br><span class=\"line\">                String msg = <span class=\"string\">\"收到了：\"</span> + currentChannel.getRemoteAddress();</span><br><span class=\"line\">                ByteBuffer responseBuffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class=\"line\">                <span class=\"comment\">// 判断是否还有数据未读</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (responseBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 写操作</span></span><br><span class=\"line\">                    currentChannel.write(responseBuffer);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 客户端代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testNioClient</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    SocketChannel clientChannel = SocketChannel.open();</span><br><span class=\"line\">    clientChannel.configureBlocking(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    clientChannel.connect(<span class=\"keyword\">new</span> InetSocketAddress(<span class=\"string\">\"127.0.0.1\"</span>, <span class=\"number\">8888</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 判断连接是否完成</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!clientChannel.finishConnect()) &#123;</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"客户端启动\"</span>);</span><br><span class=\"line\">    String msg = <span class=\"string\">\"测试NIO:12345689你好呀@\"</span>;</span><br><span class=\"line\">    ByteBuffer writeBuffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (writeBuffer.hasRemaining()) &#123;</span><br><span class=\"line\">        clientChannel.write(writeBuffer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"收取响应\"</span>);</span><br><span class=\"line\">    ByteBuffer responseBuffer = ByteBuffer.allocate(<span class=\"number\">1024</span>);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (clientChannel.isOpen() &amp;&amp; clientChannel.read(responseBuffer) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取完成 跳出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (responseBuffer.position() &gt; <span class=\"number\">0</span> &amp;&amp; responseBuffer.position() == count) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count = responseBuffer.position();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    responseBuffer.flip();</span><br><span class=\"line\">    <span class=\"keyword\">byte</span>[] content = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[responseBuffer.limit()];</span><br><span class=\"line\">    responseBuffer.get(content);</span><br><span class=\"line\">    logger.info(<span class=\"string\">\"响应内容：&#123;&#125;\"</span>, <span class=\"keyword\">new</span> String(content));</span><br><span class=\"line\">    clientChannel.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  本章简单介绍了几种IO模型，并初步了解NIO的特点与用法。\n  相比于BIO极度依赖多线程，NIO只用单线程就可以高效的完成IO操作。使其在高数量的连接场景\n下依旧有很好性能保证。</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://tech.meituan.com/2016/11/04/nio.html\" target=\"_blank\" rel=\"noopener\">Java NIO浅析</a></p>\n</blockquote>\n<h3 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"></a>推荐阅读</h3><blockquote>\n<p><a href=\"http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf\" target=\"_blank\" rel=\"noopener\">Scalable IO in Java</a></p>\n</blockquote>"},{"title":"redis多维度排序问题","date":"2021-03-02T13:32:10.000Z","_content":"\n### 前言\n   \n      之前面试有被问到一个问题：小程序榜单按照点赞数降序排列，若点赞数一样，则按照最\n    新点赞时间降序排列。\n      当时没有给出解决方案，现在突然有点想法，记录一下。\n<!-- more -->\n\n### mysql排序\n   \n   在网上看到过一种比较简单的解决方法：直接从数据库查询的时候，在sql中用order by进行排序。\n   mysql是支持多维度排序的，然后将查询结果放入redis即可。\n   不过这种方案限制比较多，因为排序是通过mysql查询实现的，那么每一次点赞操作都需要查一次库更新缓存。\n   这显然与我们使用redis缓存榜单数据的初衷背离了。\n\n### 问题分析\n\n   放弃mysql查询排序的方案后，就只能将希望全放在redis上。\n   由简单到复杂，依次考虑以下几种情况：\n   1. 单维度：\n     如果是只按照点赞数排序，那么很简单，使用redis的zset类型，将点赞数作为score存入缓存。\n   这样，可以借助zset的相关操作很方便按照点赞数排序查询数据。而每次点赞操作同步更新缓存中的score值即可。\n\n   2. 两个维度，但同升序或降序：\n     这时候增加时间维度，但和点赞数一样降序排列。那么实现方案也比较容易，依然使用zset的\n   score，这时候，就不能直接将点赞数赋值给score，因为时间也是影响因数。\n   \t 直接想到的方案是取两者之和，但这就有一个明显问题，时间戳的值太大了，\n   \t 例如：一个点赞数30，一个点赞数20，但后者的时间戳比前者大100，那么就会出现点赞数少的排在前面。不符合先按点赞数排序的要求。\n     为了实现先比较点赞数再比较时间戳的效果，可以采取组合的方式，将点赞数放在高位，时间戳放在低位，组合成一个数字。\n     数字的大小比较不就是从高位往低位依次比较的嘛。\n     不过这里需要注意，因为时间戳以秒为单位的话也有十位，而score是double类型，最高16位，\n     可以采取将时间戳放在小数位或者设定一个比较接近的时间点为起始时间点计算时间戳等方法避免点赞数过大时超出score范围。\n\n   3. 两个维度，但不同的排序要求：\n     如开篇一样，增加时间维度，但为降序。那么就是点赞升序，时间降序。\n     有了上述方案，可以照葫芦画瓢，修改下对时间戳的处理即可。\n     这里定义一个未来的时间点为基准，取点赞最新时间点与其的差值，当点赞最新时间越晚(即时间戳越大)，其差值便越小。\n     然后依次将点赞数放在高位，差值放在低位组合成数字当作score存入缓存即可。\n\n   4. 如果有更多维度的话，依旧按照维度的权重从高位放到低位，只不过需要注意，如点赞数这种会\n      不断增加的数据，增加一些处理控制他的位数，避免最后计算的结果超过了double的范围。\n\n### 总结\n   现在来看，这个问题并不复杂，关键思路是怎么设置维度数据的权重，有了权重的设置，将计算的结果当作score即可。","source":"_posts/2021/03/redis-sort1.md","raw":"---\ntitle: redis多维度排序问题\ndate: 2021-03-02 21:32:10\ntags:\n- redis\ncategories:\n- redis\n---\n\n### 前言\n   \n      之前面试有被问到一个问题：小程序榜单按照点赞数降序排列，若点赞数一样，则按照最\n    新点赞时间降序排列。\n      当时没有给出解决方案，现在突然有点想法，记录一下。\n<!-- more -->\n\n### mysql排序\n   \n   在网上看到过一种比较简单的解决方法：直接从数据库查询的时候，在sql中用order by进行排序。\n   mysql是支持多维度排序的，然后将查询结果放入redis即可。\n   不过这种方案限制比较多，因为排序是通过mysql查询实现的，那么每一次点赞操作都需要查一次库更新缓存。\n   这显然与我们使用redis缓存榜单数据的初衷背离了。\n\n### 问题分析\n\n   放弃mysql查询排序的方案后，就只能将希望全放在redis上。\n   由简单到复杂，依次考虑以下几种情况：\n   1. 单维度：\n     如果是只按照点赞数排序，那么很简单，使用redis的zset类型，将点赞数作为score存入缓存。\n   这样，可以借助zset的相关操作很方便按照点赞数排序查询数据。而每次点赞操作同步更新缓存中的score值即可。\n\n   2. 两个维度，但同升序或降序：\n     这时候增加时间维度，但和点赞数一样降序排列。那么实现方案也比较容易，依然使用zset的\n   score，这时候，就不能直接将点赞数赋值给score，因为时间也是影响因数。\n   \t 直接想到的方案是取两者之和，但这就有一个明显问题，时间戳的值太大了，\n   \t 例如：一个点赞数30，一个点赞数20，但后者的时间戳比前者大100，那么就会出现点赞数少的排在前面。不符合先按点赞数排序的要求。\n     为了实现先比较点赞数再比较时间戳的效果，可以采取组合的方式，将点赞数放在高位，时间戳放在低位，组合成一个数字。\n     数字的大小比较不就是从高位往低位依次比较的嘛。\n     不过这里需要注意，因为时间戳以秒为单位的话也有十位，而score是double类型，最高16位，\n     可以采取将时间戳放在小数位或者设定一个比较接近的时间点为起始时间点计算时间戳等方法避免点赞数过大时超出score范围。\n\n   3. 两个维度，但不同的排序要求：\n     如开篇一样，增加时间维度，但为降序。那么就是点赞升序，时间降序。\n     有了上述方案，可以照葫芦画瓢，修改下对时间戳的处理即可。\n     这里定义一个未来的时间点为基准，取点赞最新时间点与其的差值，当点赞最新时间越晚(即时间戳越大)，其差值便越小。\n     然后依次将点赞数放在高位，差值放在低位组合成数字当作score存入缓存即可。\n\n   4. 如果有更多维度的话，依旧按照维度的权重从高位放到低位，只不过需要注意，如点赞数这种会\n      不断增加的数据，增加一些处理控制他的位数，避免最后计算的结果超过了double的范围。\n\n### 总结\n   现在来看，这个问题并不复杂，关键思路是怎么设置维度数据的权重，有了权重的设置，将计算的结果当作score即可。","slug":"redis-sort1","published":1,"updated":"2021-03-03T13:16:32.681Z","_id":"ckls21jr500002sb50r3r4ch8","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><pre><code>  之前面试有被问到一个问题：小程序榜单按照点赞数降序排列，若点赞数一样，则按照最\n新点赞时间降序排列。\n  当时没有给出解决方案，现在突然有点想法，记录一下。</code></pre><a id=\"more\"></a>\n\n<h3 id=\"mysql排序\"><a href=\"#mysql排序\" class=\"headerlink\" title=\"mysql排序\"></a>mysql排序</h3><p>   在网上看到过一种比较简单的解决方法：直接从数据库查询的时候，在sql中用order by进行排序。<br>   mysql是支持多维度排序的，然后将查询结果放入redis即可。<br>   不过这种方案限制比较多，因为排序是通过mysql查询实现的，那么每一次点赞操作都需要查一次库更新缓存。<br>   这显然与我们使用redis缓存榜单数据的初衷背离了。</p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>   放弃mysql查询排序的方案后，就只能将希望全放在redis上。<br>   由简单到复杂，依次考虑以下几种情况：</p>\n<ol>\n<li><p>单维度：<br>如果是只按照点赞数排序，那么很简单，使用redis的zset类型，将点赞数作为score存入缓存。<br>这样，可以借助zset的相关操作很方便按照点赞数排序查询数据。而每次点赞操作同步更新缓存中的score值即可。</p>\n</li>\n<li><p>两个维度，但同升序或降序：<br>这时候增加时间维度，但和点赞数一样降序排列。那么实现方案也比较容易，依然使用zset的<br>score，这时候，就不能直接将点赞数赋值给score，因为时间也是影响因数。<br>  直接想到的方案是取两者之和，但这就有一个明显问题，时间戳的值太大了，<br>  例如：一个点赞数30，一个点赞数20，但后者的时间戳比前者大100，那么就会出现点赞数少的排在前面。不符合先按点赞数排序的要求。<br>为了实现先比较点赞数再比较时间戳的效果，可以采取组合的方式，将点赞数放在高位，时间戳放在低位，组合成一个数字。<br>数字的大小比较不就是从高位往低位依次比较的嘛。<br>不过这里需要注意，因为时间戳以秒为单位的话也有十位，而score是double类型，最高16位，<br>可以采取将时间戳放在小数位或者设定一个比较接近的时间点为起始时间点计算时间戳等方法避免点赞数过大时超出score范围。</p>\n</li>\n<li><p>两个维度，但不同的排序要求：<br>如开篇一样，增加时间维度，但为降序。那么就是点赞升序，时间降序。<br>有了上述方案，可以照葫芦画瓢，修改下对时间戳的处理即可。<br>这里定义一个未来的时间点为基准，取点赞最新时间点与其的差值，当点赞最新时间越晚(即时间戳越大)，其差值便越小。<br>然后依次将点赞数放在高位，差值放在低位组合成数字当作score存入缓存即可。</p>\n</li>\n<li><p>如果有更多维度的话，依旧按照维度的权重从高位放到低位，只不过需要注意，如点赞数这种会<br>不断增加的数据，增加一些处理控制他的位数，避免最后计算的结果超过了double的范围。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>   现在来看，这个问题并不复杂，关键思路是怎么设置维度数据的权重，有了权重的设置，将计算的结果当作score即可。</p>\n","site":{"data":{}},"length":1089,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><pre><code>  之前面试有被问到一个问题：小程序榜单按照点赞数降序排列，若点赞数一样，则按照最\n新点赞时间降序排列。\n  当时没有给出解决方案，现在突然有点想法，记录一下。</code></pre>","more":"<h3 id=\"mysql排序\"><a href=\"#mysql排序\" class=\"headerlink\" title=\"mysql排序\"></a>mysql排序</h3><p>   在网上看到过一种比较简单的解决方法：直接从数据库查询的时候，在sql中用order by进行排序。<br>   mysql是支持多维度排序的，然后将查询结果放入redis即可。<br>   不过这种方案限制比较多，因为排序是通过mysql查询实现的，那么每一次点赞操作都需要查一次库更新缓存。<br>   这显然与我们使用redis缓存榜单数据的初衷背离了。</p>\n<h3 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h3><p>   放弃mysql查询排序的方案后，就只能将希望全放在redis上。<br>   由简单到复杂，依次考虑以下几种情况：</p>\n<ol>\n<li><p>单维度：<br>如果是只按照点赞数排序，那么很简单，使用redis的zset类型，将点赞数作为score存入缓存。<br>这样，可以借助zset的相关操作很方便按照点赞数排序查询数据。而每次点赞操作同步更新缓存中的score值即可。</p>\n</li>\n<li><p>两个维度，但同升序或降序：<br>这时候增加时间维度，但和点赞数一样降序排列。那么实现方案也比较容易，依然使用zset的<br>score，这时候，就不能直接将点赞数赋值给score，因为时间也是影响因数。<br>  直接想到的方案是取两者之和，但这就有一个明显问题，时间戳的值太大了，<br>  例如：一个点赞数30，一个点赞数20，但后者的时间戳比前者大100，那么就会出现点赞数少的排在前面。不符合先按点赞数排序的要求。<br>为了实现先比较点赞数再比较时间戳的效果，可以采取组合的方式，将点赞数放在高位，时间戳放在低位，组合成一个数字。<br>数字的大小比较不就是从高位往低位依次比较的嘛。<br>不过这里需要注意，因为时间戳以秒为单位的话也有十位，而score是double类型，最高16位，<br>可以采取将时间戳放在小数位或者设定一个比较接近的时间点为起始时间点计算时间戳等方法避免点赞数过大时超出score范围。</p>\n</li>\n<li><p>两个维度，但不同的排序要求：<br>如开篇一样，增加时间维度，但为降序。那么就是点赞升序，时间降序。<br>有了上述方案，可以照葫芦画瓢，修改下对时间戳的处理即可。<br>这里定义一个未来的时间点为基准，取点赞最新时间点与其的差值，当点赞最新时间越晚(即时间戳越大)，其差值便越小。<br>然后依次将点赞数放在高位，差值放在低位组合成数字当作score存入缓存即可。</p>\n</li>\n<li><p>如果有更多维度的话，依旧按照维度的权重从高位放到低位，只不过需要注意，如点赞数这种会<br>不断增加的数据，增加一些处理控制他的位数，避免最后计算的结果超过了double的范围。</p>\n</li>\n</ol>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>   现在来看，这个问题并不复杂，关键思路是怎么设置维度数据的权重，有了权重的设置，将计算的结果当作score即可。</p>"},{"title":"LinkedHashMap(jdk1.8)","date":"2021-03-04T12:26:54.000Z","_content":"\n### LinkedHashMap简介\n   \n     LinkedHashMap是HashMap的子类，基于HashMap的数据结构，维护了一个双向链表。\n     所以相对HashMap来说，LinkedHashMap可以保证取数的顺序。\n\n<!-- more -->\n\n类定义如下\n{% codeblock lang:java %}\npublic class LinkedHashMap<K,V>\n    extends HashMap<K,V>\n    implements Map<K,V>\n{% endcodeblock%}\n\n### 基础属性\n{% codeblock lang:java %}\n// 节点对象\nstatic class Entry<K,V> extends HashMap.Node<K,V> {\n    Entry<K,V> before, after;\n    Entry(int hash, K key, V value, Node<K,V> next) {\n        super(hash, key, value, next);\n    }\n}\n// 链表的头指针和尾指针\ntransient LinkedHashMap.Entry<K,V> head;\ntransient LinkedHashMap.Entry<K,V> tail;\n// 排序方式的设置 true表示访问顺序 false表示插入顺序\nfinal boolean accessOrder;\n{% endcodeblock%}\n\n### put操作\n  \n  LinkedHashMap继承了HashMap，他的put方法没有重写，直接使用的HashMap的put方法。\n  但是，LinkedHashMap需要维护一个链表结构，所以在重写newNode()方法。\n\n{% codeblock lang:java %}\n// 创建新节点\nNode<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n    LinkedHashMap.Entry<K,V> p = \n    \tnew LinkedHashMap.Entry<K,V>(hash, key, value, e);\n    linkNodeLast(p);\n    return p;\n}\n// 维护链表关系\nprivate void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n    LinkedHashMap.Entry<K,V> last = tail;\n    tail = p;\n    if (last == null)\n        head = p;\n    else {\n        p.before = last;\n        last.after = p;\n    }\n}\n{% endcodeblock%}\n   \n   LinkedHashMap的put操作逻辑与HashMap完全一样，只是在新建节点时通过重写方法，增加了链表维护的逻辑。\n\n### get操作\n   \n   get操作与put操作不同，LinkedHashMap直接重写了父类的方法，并在其中增加了取数顺序的判断及处理逻辑。\n\n{% codeblock lang:java %}\npublic V get(Object key) {\n    Node<K,V> e;\n    // 使用HasMap的getNode方法获取节点对象\n    if ((e = getNode(hash(key), key)) == null)\n        return null;\n    // 访问顺序的处理\n    if (accessOrder)\n        afterNodeAccess(e);\n    return e.value;\n}\n// 将节点移动到尾部\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n    LinkedHashMap.Entry<K,V> last;\n    // 判断入参节点是否尾部\n    if (accessOrder && (last = tail) != e) {\n        LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e, \n        b = p.before, \n        a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n{% endcodeblock %}\n\n### 示例\n{% codeblock lang:java %}\n// 按照插入顺序访问\npublic void linkedHashMapTest() {\n    LinkedHashMap<Integer, Integer> linkedHashMap = new LinkedHashMap<>();\n    Set<Integer> set = linkedHashMap.keySet();\n    linkedHashMap.put(1, 1);\n    linkedHashMap.put(2, 2);\n    linkedHashMap.put(22, 22);\n    for (Integer key : set) {\n        logger.info(\"key:{}\", key);\n    }\n    linkedHashMap.get(2);\n    for (Integer key1 : set) {\n        logger.info(\"key1:{}\", key);\n    }\n}\n{% endcodeblock %}\n结果输出：\n{% img  /image/LinkedHashMap/LinkedHashMap1.png  '\"结果展示\"' %}\n\n  get方法并不会影响取值的顺序，永远按照插入顺序取出数据。\n\n{% codeblock lang:java %}\n// 按照访问顺序\npublic void linkedHashMapTest() {\n    LinkedHashMap<Integer, Integer> linkedHashMap1 = new LinkedHashMap<>(16, (float) 0.75, true);\n    linkedHashMap.put(1, 1);\n    linkedHashMap.put(2, 2);\n    linkedHashMap.put(22, 22);\n    for (Integer key : set) {\n        logger.info(\"key1:{}\", key);\n    }\n    linkedHashMap1.get(2);\n    for (Integer key : set) {\n        logger.info(\"key2:{}\", key);\n    }\n    linkedHashMap1.get(22);\n    for (Integer key : set) {\n        logger.info(\"key3:{}\", key);\n    }\n}\n{% endcodeblock %}\n结果输出：\n{% img  /image/LinkedHashMap/LinkedHashMap2.png  '\"结果展示\"' %}\n\n  当通过构造方法将accessOrder设置为true时，get方法除了查到节点，还会将所查到的节点放入到链表队尾，实现访问顺序的维护。\n\n\n### 总结\n\n       LinkedHashMap大部分内容都与HashMap一样，其通过重写部分方法，在HashMap的操作逻辑基础上，穿插了\n     链表的操作逻辑。\n       另外，LinkedHashMap还提供了访问顺序的维护，逻辑很简单，每一次get取数时，就将这个数据所属节点放\n     到链表队尾，这样遍历数据时，就是按照最近最少使用的顺序输出。也是一种LRU算法的实现思路。\n\n\n\n\n\n","source":"_posts/2021/03/LinkedHashMap1.md","raw":"---\ntitle: LinkedHashMap(jdk1.8)\ndate: 2021-03-04 20:26:54\ntags:\n- Java容器\ncategories:\n- Java\n- Map\n---\n\n### LinkedHashMap简介\n   \n     LinkedHashMap是HashMap的子类，基于HashMap的数据结构，维护了一个双向链表。\n     所以相对HashMap来说，LinkedHashMap可以保证取数的顺序。\n\n<!-- more -->\n\n类定义如下\n{% codeblock lang:java %}\npublic class LinkedHashMap<K,V>\n    extends HashMap<K,V>\n    implements Map<K,V>\n{% endcodeblock%}\n\n### 基础属性\n{% codeblock lang:java %}\n// 节点对象\nstatic class Entry<K,V> extends HashMap.Node<K,V> {\n    Entry<K,V> before, after;\n    Entry(int hash, K key, V value, Node<K,V> next) {\n        super(hash, key, value, next);\n    }\n}\n// 链表的头指针和尾指针\ntransient LinkedHashMap.Entry<K,V> head;\ntransient LinkedHashMap.Entry<K,V> tail;\n// 排序方式的设置 true表示访问顺序 false表示插入顺序\nfinal boolean accessOrder;\n{% endcodeblock%}\n\n### put操作\n  \n  LinkedHashMap继承了HashMap，他的put方法没有重写，直接使用的HashMap的put方法。\n  但是，LinkedHashMap需要维护一个链表结构，所以在重写newNode()方法。\n\n{% codeblock lang:java %}\n// 创建新节点\nNode<K,V> newNode(int hash, K key, V value, Node<K,V> e) {\n    LinkedHashMap.Entry<K,V> p = \n    \tnew LinkedHashMap.Entry<K,V>(hash, key, value, e);\n    linkNodeLast(p);\n    return p;\n}\n// 维护链表关系\nprivate void linkNodeLast(LinkedHashMap.Entry<K,V> p) {\n    LinkedHashMap.Entry<K,V> last = tail;\n    tail = p;\n    if (last == null)\n        head = p;\n    else {\n        p.before = last;\n        last.after = p;\n    }\n}\n{% endcodeblock%}\n   \n   LinkedHashMap的put操作逻辑与HashMap完全一样，只是在新建节点时通过重写方法，增加了链表维护的逻辑。\n\n### get操作\n   \n   get操作与put操作不同，LinkedHashMap直接重写了父类的方法，并在其中增加了取数顺序的判断及处理逻辑。\n\n{% codeblock lang:java %}\npublic V get(Object key) {\n    Node<K,V> e;\n    // 使用HasMap的getNode方法获取节点对象\n    if ((e = getNode(hash(key), key)) == null)\n        return null;\n    // 访问顺序的处理\n    if (accessOrder)\n        afterNodeAccess(e);\n    return e.value;\n}\n// 将节点移动到尾部\nvoid afterNodeAccess(Node<K,V> e) { // move node to last\n    LinkedHashMap.Entry<K,V> last;\n    // 判断入参节点是否尾部\n    if (accessOrder && (last = tail) != e) {\n        LinkedHashMap.Entry<K,V> p = (LinkedHashMap.Entry<K,V>)e, \n        b = p.before, \n        a = p.after;\n        p.after = null;\n        if (b == null)\n            head = a;\n        else\n            b.after = a;\n        if (a != null)\n            a.before = b;\n        else\n            last = b;\n        if (last == null)\n            head = p;\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n{% endcodeblock %}\n\n### 示例\n{% codeblock lang:java %}\n// 按照插入顺序访问\npublic void linkedHashMapTest() {\n    LinkedHashMap<Integer, Integer> linkedHashMap = new LinkedHashMap<>();\n    Set<Integer> set = linkedHashMap.keySet();\n    linkedHashMap.put(1, 1);\n    linkedHashMap.put(2, 2);\n    linkedHashMap.put(22, 22);\n    for (Integer key : set) {\n        logger.info(\"key:{}\", key);\n    }\n    linkedHashMap.get(2);\n    for (Integer key1 : set) {\n        logger.info(\"key1:{}\", key);\n    }\n}\n{% endcodeblock %}\n结果输出：\n{% img  /image/LinkedHashMap/LinkedHashMap1.png  '\"结果展示\"' %}\n\n  get方法并不会影响取值的顺序，永远按照插入顺序取出数据。\n\n{% codeblock lang:java %}\n// 按照访问顺序\npublic void linkedHashMapTest() {\n    LinkedHashMap<Integer, Integer> linkedHashMap1 = new LinkedHashMap<>(16, (float) 0.75, true);\n    linkedHashMap.put(1, 1);\n    linkedHashMap.put(2, 2);\n    linkedHashMap.put(22, 22);\n    for (Integer key : set) {\n        logger.info(\"key1:{}\", key);\n    }\n    linkedHashMap1.get(2);\n    for (Integer key : set) {\n        logger.info(\"key2:{}\", key);\n    }\n    linkedHashMap1.get(22);\n    for (Integer key : set) {\n        logger.info(\"key3:{}\", key);\n    }\n}\n{% endcodeblock %}\n结果输出：\n{% img  /image/LinkedHashMap/LinkedHashMap2.png  '\"结果展示\"' %}\n\n  当通过构造方法将accessOrder设置为true时，get方法除了查到节点，还会将所查到的节点放入到链表队尾，实现访问顺序的维护。\n\n\n### 总结\n\n       LinkedHashMap大部分内容都与HashMap一样，其通过重写部分方法，在HashMap的操作逻辑基础上，穿插了\n     链表的操作逻辑。\n       另外，LinkedHashMap还提供了访问顺序的维护，逻辑很简单，每一次get取数时，就将这个数据所属节点放\n     到链表队尾，这样遍历数据时，就是按照最近最少使用的顺序输出。也是一种LRU算法的实现思路。\n\n\n\n\n\n","slug":"LinkedHashMap1","published":1,"updated":"2021-03-06T07:15:55.102Z","_id":"cklx9xf3p0000gob5606408gl","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"LinkedHashMap简介\"><a href=\"#LinkedHashMap简介\" class=\"headerlink\" title=\"LinkedHashMap简介\"></a>LinkedHashMap简介</h3><pre><code>LinkedHashMap是HashMap的子类，基于HashMap的数据结构，维护了一个双向链表。\n所以相对HashMap来说，LinkedHashMap可以保证取数的顺序。</code></pre><a id=\"more\"></a>\n\n<p>类定义如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedHashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基础属性\"><a href=\"#基础属性\" class=\"headerlink\" title=\"基础属性\"></a>基础属性</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节点对象</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">HashMap</span>.<span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\">    Entry(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(hash, key, value, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 链表的头指针和尾指针</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class=\"line\"><span class=\"keyword\">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class=\"line\"><span class=\"comment\">// 排序方式的设置 true表示访问顺序 false表示插入顺序</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"put操作\"><a href=\"#put操作\" class=\"headerlink\" title=\"put操作\"></a>put操作</h3><p>  LinkedHashMap继承了HashMap，他的put方法没有重写，直接使用的HashMap的put方法。<br>  但是，LinkedHashMap需要维护一个链表结构，所以在重写newNode()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建新节点</span></span><br><span class=\"line\"><span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">newNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; p = </span><br><span class=\"line\">    \t<span class=\"keyword\">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class=\"line\">    linkNodeLast(p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 维护链表关系</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkNodeLast</span><span class=\"params\">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class=\"line\">    tail = p;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        head = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p.before = last;</span><br><span class=\"line\">        last.after = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   LinkedHashMap的put操作逻辑与HashMap完全一样，只是在新建节点时通过重写方法，增加了链表维护的逻辑。</p>\n<h3 id=\"get操作\"><a href=\"#get操作\" class=\"headerlink\" title=\"get操作\"></a>get操作</h3><p>   get操作与put操作不同，LinkedHashMap直接重写了父类的方法，并在其中增加了取数顺序的判断及处理逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"comment\">// 使用HasMap的getNode方法获取节点对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e = getNode(hash(key), key)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 访问顺序的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accessOrder)</span><br><span class=\"line\">        afterNodeAccess(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将节点移动到尾部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeAccess</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// move node to last</span></span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class=\"line\">    <span class=\"comment\">// 判断入参节点是否尾部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class=\"line\">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, </span><br><span class=\"line\">        b = p.before, </span><br><span class=\"line\">        a = p.after;</span><br><span class=\"line\">        p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            head = a;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b.after = a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            a.before = b;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            last = b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            head = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p.before = last;</span><br><span class=\"line\">            last.after = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tail = p;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 按照插入顺序访问</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">linkedHashMapTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;Integer, Integer&gt; linkedHashMap = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\">    Set&lt;Integer&gt; set = linkedHashMap.keySet();</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">22</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    linkedHashMap.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key1 : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key1:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果输出：</p>\n<img src=\"/image/LinkedHashMap/LinkedHashMap1.png\" class=\"\" title=\"结果展示\">\n\n<p>  get方法并不会影响取值的顺序，永远按照插入顺序取出数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 按照访问顺序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">linkedHashMapTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;Integer, Integer&gt; linkedHashMap1 = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;(<span class=\"number\">16</span>, (<span class=\"keyword\">float</span>) <span class=\"number\">0.75</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">22</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key1:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    linkedHashMap1.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key2:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    linkedHashMap1.get(<span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key3:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果输出：</p>\n<img src=\"/image/LinkedHashMap/LinkedHashMap2.png\" class=\"\" title=\"结果展示\">\n\n<p>  当通过构造方法将accessOrder设置为true时，get方法除了查到节点，还会将所查到的节点放入到链表队尾，实现访问顺序的维护。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  LinkedHashMap大部分内容都与HashMap一样，其通过重写部分方法，在HashMap的操作逻辑基础上，穿插了\n链表的操作逻辑。\n  另外，LinkedHashMap还提供了访问顺序的维护，逻辑很简单，每一次get取数时，就将这个数据所属节点放\n到链表队尾，这样遍历数据时，就是按照最近最少使用的顺序输出。也是一种LRU算法的实现思路。</code></pre>","site":{"data":{}},"length":616,"excerpt":"<h3 id=\"LinkedHashMap简介\"><a href=\"#LinkedHashMap简介\" class=\"headerlink\" title=\"LinkedHashMap简介\"></a>LinkedHashMap简介</h3><pre><code>LinkedHashMap是HashMap的子类，基于HashMap的数据结构，维护了一个双向链表。\n所以相对HashMap来说，LinkedHashMap可以保证取数的顺序。</code></pre>","more":"<p>类定义如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinkedHashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">HashMap</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基础属性\"><a href=\"#基础属性\" class=\"headerlink\" title=\"基础属性\"></a>基础属性</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节点对象</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">HashMap</span>.<span class=\"title\">Node</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\">    Entry(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(hash, key, value, next);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 链表的头指针和尾指针</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class=\"line\"><span class=\"keyword\">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class=\"line\"><span class=\"comment\">// 排序方式的设置 true表示访问顺序 false表示插入顺序</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"put操作\"><a href=\"#put操作\" class=\"headerlink\" title=\"put操作\"></a>put操作</h3><p>  LinkedHashMap继承了HashMap，他的put方法没有重写，直接使用的HashMap的put方法。<br>  但是，LinkedHashMap需要维护一个链表结构，所以在重写newNode()方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建新节点</span></span><br><span class=\"line\"><span class=\"function\">Node&lt;K,V&gt; <span class=\"title\">newNode</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; p = </span><br><span class=\"line\">    \t<span class=\"keyword\">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class=\"line\">    linkNodeLast(p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 维护链表关系</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">linkNodeLast</span><span class=\"params\">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class=\"line\">    tail = p;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        head = p;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        p.before = last;</span><br><span class=\"line\">        last.after = p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   LinkedHashMap的put操作逻辑与HashMap完全一样，只是在新建节点时通过重写方法，增加了链表维护的逻辑。</p>\n<h3 id=\"get操作\"><a href=\"#get操作\" class=\"headerlink\" title=\"get操作\"></a>get操作</h3><p>   get操作与put操作不同，LinkedHashMap直接重写了父类的方法，并在其中增加了取数顺序的判断及处理逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"comment\">// 使用HasMap的getNode方法获取节点对象</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e = getNode(hash(key), key)) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 访问顺序的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accessOrder)</span><br><span class=\"line\">        afterNodeAccess(e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将节点移动到尾部</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterNodeAccess</span><span class=\"params\">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class=\"comment\">// move node to last</span></span><br><span class=\"line\">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class=\"line\">    <span class=\"comment\">// 判断入参节点是否尾部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class=\"line\">        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, </span><br><span class=\"line\">        b = p.before, </span><br><span class=\"line\">        a = p.after;</span><br><span class=\"line\">        p.after = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            head = a;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            b.after = a;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            a.before = b;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            last = b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (last == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            head = p;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            p.before = last;</span><br><span class=\"line\">            last.after = p;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tail = p;</span><br><span class=\"line\">        ++modCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 按照插入顺序访问</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">linkedHashMapTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;Integer, Integer&gt; linkedHashMap = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;();</span><br><span class=\"line\">    Set&lt;Integer&gt; set = linkedHashMap.keySet();</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">22</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    linkedHashMap.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key1 : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key1:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果输出：</p>\n<img src=\"/image/LinkedHashMap/LinkedHashMap1.png\" class=\"\" title=\"结果展示\">\n\n<p>  get方法并不会影响取值的顺序，永远按照插入顺序取出数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 按照访问顺序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">linkedHashMapTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LinkedHashMap&lt;Integer, Integer&gt; linkedHashMap1 = <span class=\"keyword\">new</span> LinkedHashMap&lt;&gt;(<span class=\"number\">16</span>, (<span class=\"keyword\">float</span>) <span class=\"number\">0.75</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">2</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    linkedHashMap.put(<span class=\"number\">22</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key1:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    linkedHashMap1.get(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key2:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    linkedHashMap1.get(<span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer key : set) &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"key3:&#123;&#125;\"</span>, key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果输出：</p>\n<img src=\"/image/LinkedHashMap/LinkedHashMap2.png\" class=\"\" title=\"结果展示\">\n\n<p>  当通过构造方法将accessOrder设置为true时，get方法除了查到节点，还会将所查到的节点放入到链表队尾，实现访问顺序的维护。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  LinkedHashMap大部分内容都与HashMap一样，其通过重写部分方法，在HashMap的操作逻辑基础上，穿插了\n链表的操作逻辑。\n  另外，LinkedHashMap还提供了访问顺序的维护，逻辑很简单，每一次get取数时，就将这个数据所属节点放\n到链表队尾，这样遍历数据时，就是按照最近最少使用的顺序输出。也是一种LRU算法的实现思路。</code></pre>"},{"title":"排序算法总结","date":"2021-03-07T04:13:24.000Z","_content":"\n### 前言\n  本章对常用的排序算法做个系统的回顾与总结。\n<!-- more -->\n\n### 冒泡排序\n\n  基本思路：每次遍历，两两比较，确定一个位置的值\n  平均时间复杂度：O(n^2)\n  是否稳定：是\n\n{% codeblock lang:java %}\npublic void algorithmTest() {\n    List<Integer> list = \n    \t    Lists.newArrayList(61, 2, 13, 5, 11, 4, 55, 12, 45, 21, 56, 76, 1, 22);\n    // 两两比较，外层循环表示循环次数\n    for (int i = 0; i < list.size() - 1; i++) {\n        for (int j = list.size() - 1; j > i; j--) {\n            // 把小的交换到前面\n            if (list.get(j) < list.get(j - 1)) {\n                swap(list, j, j - 1);\n            }\n        }\n    }\n}\n{% endcodeblock %}\n\n### 选择排序\n\n  基本思路：每一次遍历，确定一个位置的数据\n  平均时间复杂度：O(n^2)\n  是否稳定：否\n\n{% codeblock lang:java %}\nprivate void chooseSort(List<Integer> chooseList) {\n    for (int i = 0; i < chooseList.size(); i++) {\n        // 每次循环最小值的下标\n        int choose = i;\n        // 向后遍历，找出最小值元素所在下标\n        for (int j = i + 1; j < chooseList.size(); j++) {\n            if (chooseList.get(j) < chooseList.get(i)) {\n                choose = j;\n            }\n        }\n        // 将最小值与当前首位交换\n        swap(chooseList, i, choose);\n    }\n}\n{% endcodeblock%}\n\n### 插入排序\n  \n  基本思路：将第一个元素看作一个已经排好序的序列，从第二个元素开始，依次按顺序插入序列中。\n  平均时间复杂度：O(n^2)\\\n  是否稳定：是\n\n{% codeblock lang:java %}\nprivate void insertSort(List<Integer> insertList) {\n    int temp;\n    int j;\n    // 因为第一个元素可以看作有序的，所以从第二个元素开始排序\n    for (int i = 1; i < insertList.size(); i++) {\n        // 待插入元素\n        temp = insertList.get(i);\n        j = i - 1;\n        // 依次向前比较，当前元素大于temp时，将该元素向后移动，然后继续向前遍历\n        // 因为是有序序列，如果当前元素小于等于temp，那么更前面的元素一定小于temp，不用继续遍历\n        for (; j >= 0 && insertList.get(j) > temp; j--) {\n            insertList.set(j + 1, insertList.get(j));\n        }\n        // 最后j的前一位便是应当插入的位置\n        insertList.set(j + 1, temp);\n    }\n}\n{% endcodeblock %}\n\n### 快速排序\n\n  基本思路：\n  1. 先设定一个基准值(可以是首位，也可以是随机一个)，然后从末尾向首位遍历，遇到比基准小的\n     便移往左边，再然后从首位向末尾遍历，遇到比基准大的便移往右边。最后得到基准值的下标\n  2. 以基准值下标为界，分为左右两部分，继续按照1中的逻辑分别继续递归处理\n\n\n  平均时间复杂度：O(NlogN)\n  是否稳定：否\n\n{% codeblock lang:java %}\npublic void algorithmTest() {\n    // 快速排序\n    List<Integer> quickList =\n            Lists.newArrayList(61, 2, 13, 5, 11, 4, 55, 12, 45, 21, 56, 76, 1, 22);\n    quickSort(quickList, 0, quickList.size() - 1);\n}\n// 递归处理\nprivate void quickSort(List<Integer> list, int x, int y) {\n    if (x < y) {\n        int middle = getMiddle(list, x, y);\n        quickSort(list, x, middle - 1);\n        quickSort(list, middle + 1, y);\n    }\n}\n// 找出基准值的下标\nprivate int getMiddle(List<Integer> sortList, int start, int end) {\n    int compareInt = sortList.get(start);\n    while (start < end) {\n        while (start < end && sortList.get(end) >= compareInt) {\n            end--;\n        }\n        swap(sortList, start, end);\n        while (start < end && sortList.get(start) <= compareInt) {\n            start++;\n        }\n        swap(sortList, start, end);\n    }\n    sortList.set(start, compareInt);\n    return start;\n}\n{% endcodeblock%}\n\n### 归并排序\n\n  基本思路：\n  1. 将每一个元素看做一个有序序列\n  2. 将这些有序序列两两合并形成新的有序序列\n  3. 依次执行直到最终合并成一个有序序列\n\n\n  平均时间复杂度：O(NlogN)\n  是否稳定：是\n{% codeblock lang:java %}\nprivate void mergeSort(List<Integer> mergeList) {\n    List<Integer> tempList;\n    int size = mergeList.size();\n    for (int space = 1; space < size; space * = 2) {\n        tempList = Lists.newArrayListWithCapacity(mergeList.size());\n        for (int start = 0; start < size; start += space * 2) {\n            // 分为两个有序序列 start-mid   mid-high\n            int mid = start + space < size ? start + space : size;\n            int high = mid + space < size ? mid + space : size;\n            // 定义两个序列起始下标\n            int start1 = start;\n            int start2 = mid;\n            while (start1 < mid && start2 < high) {\n                // 从两个序列队首开始取其中小的塞入临时队列\n                int min = mergeList.get(start1) < mergeList.get(start2) ? \n                          mergeList.get(start1++) : mergeList.get(start2++);\n                tempList.add(min);\n            }\n            // 处理可能剩下的数据\n            while (start1 < mid) {\n                tempList.add(mergeList.get(start1++));\n            }\n            while (start2 < high) {\n                tempList.add(mergeList.get(start2++));\n            }\n        }\n        // 结束一次归并 将临时队列复制到原队列中 继续排序\n        mergeList.clear();\n        mergeList.addAll(tempList);\n        tempList.clear();\n    }\n}\n{% endcodeblock %}\n\n\n### 堆排序\n\n    堆的定义：用数组实现的二叉树，分为最大堆，最小堆两类。\n             在最大堆中，父节点的值比每一个子节点的值都要大；而在最小堆中，父节点的值比每一个\n             子节点的值都要小。\n             因此，最大堆的根节点既是数组中的最大值，同样，最小堆的根节点就是其最小值。\n\n  基本思路：\n  1. 利用堆的特性，首先将无序序列构建成一个堆，得到其最大|最小值\n  2. 将根节点与序列队尾置换\n  3. 抛开队尾元素，调整序列使其重新成为一个堆，然后重复2，3步骤\n\n\n  平均时间复杂度：O(NlogN)\n  是否稳定：否\n\n\n{% codeblock lang:java %}\nprivate void heapSort(List<Integer> heapList) {\n    int size = heapList.size();\n    maxHeap(heapList, size);\n    // 开始排序\n    for (int j = size - 1; j > 0; j--) {\n        // 首尾互换\n        swap(heapList, 0, j);\n        // 构造最大堆\n        maxHeap(heapList, j);\n    }\n}\n\n// 构造最大堆\nprivate void maxHeap(List<Integer> heapList, int size) {\n    // 第一个非叶子节点 2n+1 = size-1\n    int start = size / 2 - 1;\n    // 构造最大堆\n    for (int root = start; root > -1; root--) {\n        // 左右子节点\n        int left = 2 * root + 1;\n        int right = left + 1;\n        // 取子节点最大值\n        int swap = left;\n        if (right < size && heapList.get(left) < heapList.get(right)) {\n            swap = right;\n        }\n        // 取最大值\n        if (heapList.get(swap) > heapList.get(root)) {\n            swap(heapList, root, swap);\n        }\n    }\n}\n{% endcodeblock%}\n\n### 希尔排序\n  \n  基本思路：希尔排序是基于插入排序做的优化，插入排序在序列基本有序的前提下性能会大大提升。\n  所以希尔排序的思路就是一步步使得序列基本有序。\n  1. 定义一个增量，如size/2，根据增量将序列分为n个序列\n  2. 对每个序列做插入排序\n  3. 按照计算方式，缩小增量，然后重复步骤2，直到增量为1，形成一个序列\n  4 .对最后一个序列做插入排序，因其基本有序，性能会大大提高\n\n\n  平均时间复杂度：受增量影响\n  是否稳定：否\n\n{% codeblock lang:java %}\nprivate void shellSort(List<Integer> shellList) {\n    int size = shellList.size();\n    // 步长\n    for (int stepSize = size / 2; stepSize > 0; stepSize = stepSize / 2) {\n        // 遍历序列 根据步长插入排序\n        for (int i = stepSize; i < size; i++) {\n            // 待插入元素\n            int temp = shellList.get(i);\n            int j = i - stepSize;\n            // 依次向前比较\n            for (; j >= 0 && shellList.get(j) > temp; j = j - stepSize) {\n                shellList.set(j + stepSize, shellList.get(j));\n            }\n            shellList.set(j + stepSize, temp);\n        }\n    }\n}\n{% endcodeblock %}\n\n### 总结\n   \n    排序算法最关注的应该是时间复杂度了，在对排序算法的选择上，当然是优先选择更快的算法。\n    在没有要求稳定的情况下，快排是第一选择。\n    冒泡，选择，插入三种排序应该避免使用，因为有更好选择。\n    归并排序由于其空间要求，所以需要考虑实际应用中内存空间的占用。可以作为在要求稳定情况\n    下的快排的替代。\n    希尔排序基于插入排序的优化，可以满足一般情况下的需求，而且相对快排实现更简单。\n","source":"_posts/2021/03/sortAlgorithm1.md","raw":"---\ntitle: 排序算法总结\ndate: 2021-03-07 12:13:24\ntags:\n- 排序算法\ncategories:\n- 算法\n- 排序算法\n---\n\n### 前言\n  本章对常用的排序算法做个系统的回顾与总结。\n<!-- more -->\n\n### 冒泡排序\n\n  基本思路：每次遍历，两两比较，确定一个位置的值\n  平均时间复杂度：O(n^2)\n  是否稳定：是\n\n{% codeblock lang:java %}\npublic void algorithmTest() {\n    List<Integer> list = \n    \t    Lists.newArrayList(61, 2, 13, 5, 11, 4, 55, 12, 45, 21, 56, 76, 1, 22);\n    // 两两比较，外层循环表示循环次数\n    for (int i = 0; i < list.size() - 1; i++) {\n        for (int j = list.size() - 1; j > i; j--) {\n            // 把小的交换到前面\n            if (list.get(j) < list.get(j - 1)) {\n                swap(list, j, j - 1);\n            }\n        }\n    }\n}\n{% endcodeblock %}\n\n### 选择排序\n\n  基本思路：每一次遍历，确定一个位置的数据\n  平均时间复杂度：O(n^2)\n  是否稳定：否\n\n{% codeblock lang:java %}\nprivate void chooseSort(List<Integer> chooseList) {\n    for (int i = 0; i < chooseList.size(); i++) {\n        // 每次循环最小值的下标\n        int choose = i;\n        // 向后遍历，找出最小值元素所在下标\n        for (int j = i + 1; j < chooseList.size(); j++) {\n            if (chooseList.get(j) < chooseList.get(i)) {\n                choose = j;\n            }\n        }\n        // 将最小值与当前首位交换\n        swap(chooseList, i, choose);\n    }\n}\n{% endcodeblock%}\n\n### 插入排序\n  \n  基本思路：将第一个元素看作一个已经排好序的序列，从第二个元素开始，依次按顺序插入序列中。\n  平均时间复杂度：O(n^2)\\\n  是否稳定：是\n\n{% codeblock lang:java %}\nprivate void insertSort(List<Integer> insertList) {\n    int temp;\n    int j;\n    // 因为第一个元素可以看作有序的，所以从第二个元素开始排序\n    for (int i = 1; i < insertList.size(); i++) {\n        // 待插入元素\n        temp = insertList.get(i);\n        j = i - 1;\n        // 依次向前比较，当前元素大于temp时，将该元素向后移动，然后继续向前遍历\n        // 因为是有序序列，如果当前元素小于等于temp，那么更前面的元素一定小于temp，不用继续遍历\n        for (; j >= 0 && insertList.get(j) > temp; j--) {\n            insertList.set(j + 1, insertList.get(j));\n        }\n        // 最后j的前一位便是应当插入的位置\n        insertList.set(j + 1, temp);\n    }\n}\n{% endcodeblock %}\n\n### 快速排序\n\n  基本思路：\n  1. 先设定一个基准值(可以是首位，也可以是随机一个)，然后从末尾向首位遍历，遇到比基准小的\n     便移往左边，再然后从首位向末尾遍历，遇到比基准大的便移往右边。最后得到基准值的下标\n  2. 以基准值下标为界，分为左右两部分，继续按照1中的逻辑分别继续递归处理\n\n\n  平均时间复杂度：O(NlogN)\n  是否稳定：否\n\n{% codeblock lang:java %}\npublic void algorithmTest() {\n    // 快速排序\n    List<Integer> quickList =\n            Lists.newArrayList(61, 2, 13, 5, 11, 4, 55, 12, 45, 21, 56, 76, 1, 22);\n    quickSort(quickList, 0, quickList.size() - 1);\n}\n// 递归处理\nprivate void quickSort(List<Integer> list, int x, int y) {\n    if (x < y) {\n        int middle = getMiddle(list, x, y);\n        quickSort(list, x, middle - 1);\n        quickSort(list, middle + 1, y);\n    }\n}\n// 找出基准值的下标\nprivate int getMiddle(List<Integer> sortList, int start, int end) {\n    int compareInt = sortList.get(start);\n    while (start < end) {\n        while (start < end && sortList.get(end) >= compareInt) {\n            end--;\n        }\n        swap(sortList, start, end);\n        while (start < end && sortList.get(start) <= compareInt) {\n            start++;\n        }\n        swap(sortList, start, end);\n    }\n    sortList.set(start, compareInt);\n    return start;\n}\n{% endcodeblock%}\n\n### 归并排序\n\n  基本思路：\n  1. 将每一个元素看做一个有序序列\n  2. 将这些有序序列两两合并形成新的有序序列\n  3. 依次执行直到最终合并成一个有序序列\n\n\n  平均时间复杂度：O(NlogN)\n  是否稳定：是\n{% codeblock lang:java %}\nprivate void mergeSort(List<Integer> mergeList) {\n    List<Integer> tempList;\n    int size = mergeList.size();\n    for (int space = 1; space < size; space * = 2) {\n        tempList = Lists.newArrayListWithCapacity(mergeList.size());\n        for (int start = 0; start < size; start += space * 2) {\n            // 分为两个有序序列 start-mid   mid-high\n            int mid = start + space < size ? start + space : size;\n            int high = mid + space < size ? mid + space : size;\n            // 定义两个序列起始下标\n            int start1 = start;\n            int start2 = mid;\n            while (start1 < mid && start2 < high) {\n                // 从两个序列队首开始取其中小的塞入临时队列\n                int min = mergeList.get(start1) < mergeList.get(start2) ? \n                          mergeList.get(start1++) : mergeList.get(start2++);\n                tempList.add(min);\n            }\n            // 处理可能剩下的数据\n            while (start1 < mid) {\n                tempList.add(mergeList.get(start1++));\n            }\n            while (start2 < high) {\n                tempList.add(mergeList.get(start2++));\n            }\n        }\n        // 结束一次归并 将临时队列复制到原队列中 继续排序\n        mergeList.clear();\n        mergeList.addAll(tempList);\n        tempList.clear();\n    }\n}\n{% endcodeblock %}\n\n\n### 堆排序\n\n    堆的定义：用数组实现的二叉树，分为最大堆，最小堆两类。\n             在最大堆中，父节点的值比每一个子节点的值都要大；而在最小堆中，父节点的值比每一个\n             子节点的值都要小。\n             因此，最大堆的根节点既是数组中的最大值，同样，最小堆的根节点就是其最小值。\n\n  基本思路：\n  1. 利用堆的特性，首先将无序序列构建成一个堆，得到其最大|最小值\n  2. 将根节点与序列队尾置换\n  3. 抛开队尾元素，调整序列使其重新成为一个堆，然后重复2，3步骤\n\n\n  平均时间复杂度：O(NlogN)\n  是否稳定：否\n\n\n{% codeblock lang:java %}\nprivate void heapSort(List<Integer> heapList) {\n    int size = heapList.size();\n    maxHeap(heapList, size);\n    // 开始排序\n    for (int j = size - 1; j > 0; j--) {\n        // 首尾互换\n        swap(heapList, 0, j);\n        // 构造最大堆\n        maxHeap(heapList, j);\n    }\n}\n\n// 构造最大堆\nprivate void maxHeap(List<Integer> heapList, int size) {\n    // 第一个非叶子节点 2n+1 = size-1\n    int start = size / 2 - 1;\n    // 构造最大堆\n    for (int root = start; root > -1; root--) {\n        // 左右子节点\n        int left = 2 * root + 1;\n        int right = left + 1;\n        // 取子节点最大值\n        int swap = left;\n        if (right < size && heapList.get(left) < heapList.get(right)) {\n            swap = right;\n        }\n        // 取最大值\n        if (heapList.get(swap) > heapList.get(root)) {\n            swap(heapList, root, swap);\n        }\n    }\n}\n{% endcodeblock%}\n\n### 希尔排序\n  \n  基本思路：希尔排序是基于插入排序做的优化，插入排序在序列基本有序的前提下性能会大大提升。\n  所以希尔排序的思路就是一步步使得序列基本有序。\n  1. 定义一个增量，如size/2，根据增量将序列分为n个序列\n  2. 对每个序列做插入排序\n  3. 按照计算方式，缩小增量，然后重复步骤2，直到增量为1，形成一个序列\n  4 .对最后一个序列做插入排序，因其基本有序，性能会大大提高\n\n\n  平均时间复杂度：受增量影响\n  是否稳定：否\n\n{% codeblock lang:java %}\nprivate void shellSort(List<Integer> shellList) {\n    int size = shellList.size();\n    // 步长\n    for (int stepSize = size / 2; stepSize > 0; stepSize = stepSize / 2) {\n        // 遍历序列 根据步长插入排序\n        for (int i = stepSize; i < size; i++) {\n            // 待插入元素\n            int temp = shellList.get(i);\n            int j = i - stepSize;\n            // 依次向前比较\n            for (; j >= 0 && shellList.get(j) > temp; j = j - stepSize) {\n                shellList.set(j + stepSize, shellList.get(j));\n            }\n            shellList.set(j + stepSize, temp);\n        }\n    }\n}\n{% endcodeblock %}\n\n### 总结\n   \n    排序算法最关注的应该是时间复杂度了，在对排序算法的选择上，当然是优先选择更快的算法。\n    在没有要求稳定的情况下，快排是第一选择。\n    冒泡，选择，插入三种排序应该避免使用，因为有更好选择。\n    归并排序由于其空间要求，所以需要考虑实际应用中内存空间的占用。可以作为在要求稳定情况\n    下的快排的替代。\n    希尔排序基于插入排序的优化，可以满足一般情况下的需求，而且相对快排实现更简单。\n","slug":"sortAlgorithm1","published":1,"updated":"2021-04-03T03:42:11.632Z","_id":"ckm0p6aew0000pwb52j1z3l33","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章对常用的排序算法做个系统的回顾与总结。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>  基本思路：每次遍历，两两比较，确定一个位置的值<br>  平均时间复杂度：O(n^2)<br>  是否稳定：是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">algorithmTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = </span><br><span class=\"line\">    \t    Lists.newArrayList(<span class=\"number\">61</span>, <span class=\"number\">2</span>, <span class=\"number\">13</span>, <span class=\"number\">5</span>, <span class=\"number\">11</span>, <span class=\"number\">4</span>, <span class=\"number\">55</span>, <span class=\"number\">12</span>, <span class=\"number\">45</span>, <span class=\"number\">21</span>, <span class=\"number\">56</span>, <span class=\"number\">76</span>, <span class=\"number\">1</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 两两比较，外层循环表示循环次数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = list.size() - <span class=\"number\">1</span>; j &gt; i; j--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把小的交换到前面</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list.get(j) &lt; list.get(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                swap(list, j, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>  基本思路：每一次遍历，确定一个位置的数据<br>  平均时间复杂度：O(n^2)<br>  是否稳定：否</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">chooseSort</span><span class=\"params\">(List&lt;Integer&gt; chooseList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; chooseList.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次循环最小值的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> choose = i;</span><br><span class=\"line\">        <span class=\"comment\">// 向后遍历，找出最小值元素所在下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; chooseList.size(); j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chooseList.get(j) &lt; chooseList.get(i)) &#123;</span><br><span class=\"line\">                choose = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将最小值与当前首位交换</span></span><br><span class=\"line\">        swap(chooseList, i, choose);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>  基本思路：将第一个元素看作一个已经排好序的序列，从第二个元素开始，依次按顺序插入序列中。<br>  平均时间复杂度：O(n^2)<br>  是否稳定：是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(List&lt;Integer&gt; insertList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">    <span class=\"comment\">// 因为第一个元素可以看作有序的，所以从第二个元素开始排序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; insertList.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 待插入元素</span></span><br><span class=\"line\">        temp = insertList.get(i);</span><br><span class=\"line\">        j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 依次向前比较，当前元素大于temp时，将该元素向后移动，然后继续向前遍历</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为是有序序列，如果当前元素小于等于temp，那么更前面的元素一定小于temp，不用继续遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; insertList.get(j) &gt; temp; j--) &#123;</span><br><span class=\"line\">            insertList.set(j + <span class=\"number\">1</span>, insertList.get(j));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后j的前一位便是应当插入的位置</span></span><br><span class=\"line\">        insertList.set(j + <span class=\"number\">1</span>, temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>  基本思路：</p>\n<ol>\n<li>先设定一个基准值(可以是首位，也可以是随机一个)，然后从末尾向首位遍历，遇到比基准小的<br>便移往左边，再然后从首位向末尾遍历，遇到比基准大的便移往右边。最后得到基准值的下标</li>\n<li>以基准值下标为界，分为左右两部分，继续按照1中的逻辑分别继续递归处理</li>\n</ol>\n<p>  平均时间复杂度：O(NlogN)<br>  是否稳定：否</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">algorithmTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 快速排序</span></span><br><span class=\"line\">    List&lt;Integer&gt; quickList =</span><br><span class=\"line\">            Lists.newArrayList(<span class=\"number\">61</span>, <span class=\"number\">2</span>, <span class=\"number\">13</span>, <span class=\"number\">5</span>, <span class=\"number\">11</span>, <span class=\"number\">4</span>, <span class=\"number\">55</span>, <span class=\"number\">12</span>, <span class=\"number\">45</span>, <span class=\"number\">21</span>, <span class=\"number\">56</span>, <span class=\"number\">76</span>, <span class=\"number\">1</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">    quickSort(quickList, <span class=\"number\">0</span>, quickList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 递归处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(List&lt;Integer&gt; list, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> middle = getMiddle(list, x, y);</span><br><span class=\"line\">        quickSort(list, x, middle - <span class=\"number\">1</span>);</span><br><span class=\"line\">        quickSort(list, middle + <span class=\"number\">1</span>, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 找出基准值的下标</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getMiddle</span><span class=\"params\">(List&lt;Integer&gt; sortList, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> compareInt = sortList.get(start);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt; end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end &amp;&amp; sortList.get(end) &gt;= compareInt) &#123;</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(sortList, start, end);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end &amp;&amp; sortList.get(start) &lt;= compareInt) &#123;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(sortList, start, end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortList.set(start, compareInt);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>  基本思路：</p>\n<ol>\n<li>将每一个元素看做一个有序序列</li>\n<li>将这些有序序列两两合并形成新的有序序列</li>\n<li>依次执行直到最终合并成一个有序序列</li>\n</ol>\n<p>  平均时间复杂度：O(NlogN)<br>  是否稳定：是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(List&lt;Integer&gt; mergeList)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; tempList;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = mergeList.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> space = <span class=\"number\">1</span>; space &lt; size; space * = <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        tempList = Lists.newArrayListWithCapacity(mergeList.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>; start &lt; size; start += space * <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分为两个有序序列 start-mid   mid-high</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = start + space &lt; size ? start + space : size;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> high = mid + space &lt; size ? mid + space : size;</span><br><span class=\"line\">            <span class=\"comment\">// 定义两个序列起始下标</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> start1 = start;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> start2 = mid;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start1 &lt; mid &amp;&amp; start2 &lt; high) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从两个序列队首开始取其中小的塞入临时队列</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> min = mergeList.get(start1) &lt; mergeList.get(start2) ? </span><br><span class=\"line\">                          mergeList.get(start1++) : mergeList.get(start2++);</span><br><span class=\"line\">                tempList.add(min);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理可能剩下的数据</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start1 &lt; mid) &#123;</span><br><span class=\"line\">                tempList.add(mergeList.get(start1++));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start2 &lt; high) &#123;</span><br><span class=\"line\">                tempList.add(mergeList.get(start2++));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 结束一次归并 将临时队列复制到原队列中 继续排序</span></span><br><span class=\"line\">        mergeList.clear();</span><br><span class=\"line\">        mergeList.addAll(tempList);</span><br><span class=\"line\">        tempList.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><pre><code>堆的定义：用数组实现的二叉树，分为最大堆，最小堆两类。\n         在最大堆中，父节点的值比每一个子节点的值都要大；而在最小堆中，父节点的值比每一个\n         子节点的值都要小。\n         因此，最大堆的根节点既是数组中的最大值，同样，最小堆的根节点就是其最小值。</code></pre><p>  基本思路：</p>\n<ol>\n<li>利用堆的特性，首先将无序序列构建成一个堆，得到其最大|最小值</li>\n<li>将根节点与序列队尾置换</li>\n<li>抛开队尾元素，调整序列使其重新成为一个堆，然后重复2，3步骤</li>\n</ol>\n<p>  平均时间复杂度：O(NlogN)<br>  是否稳定：否</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(List&lt;Integer&gt; heapList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = heapList.size();</span><br><span class=\"line\">    maxHeap(heapList, size);</span><br><span class=\"line\">    <span class=\"comment\">// 开始排序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = size - <span class=\"number\">1</span>; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 首尾互换</span></span><br><span class=\"line\">        swap(heapList, <span class=\"number\">0</span>, j);</span><br><span class=\"line\">        <span class=\"comment\">// 构造最大堆</span></span><br><span class=\"line\">        maxHeap(heapList, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造最大堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">maxHeap</span><span class=\"params\">(List&lt;Integer&gt; heapList, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第一个非叶子节点 2n+1 = size-1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = size / <span class=\"number\">2</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 构造最大堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> root = start; root &gt; -<span class=\"number\">1</span>; root--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 左右子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">2</span> * root + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = left + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 取子节点最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> swap = left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; size &amp;&amp; heapList.get(left) &lt; heapList.get(right)) &#123;</span><br><span class=\"line\">            swap = right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 取最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heapList.get(swap) &gt; heapList.get(root)) &#123;</span><br><span class=\"line\">            swap(heapList, root, swap);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>  基本思路：希尔排序是基于插入排序做的优化，插入排序在序列基本有序的前提下性能会大大提升。<br>  所以希尔排序的思路就是一步步使得序列基本有序。</p>\n<ol>\n<li>定义一个增量，如size/2，根据增量将序列分为n个序列</li>\n<li>对每个序列做插入排序</li>\n<li>按照计算方式，缩小增量，然后重复步骤2，直到增量为1，形成一个序列<br>4 .对最后一个序列做插入排序，因其基本有序，性能会大大提高</li>\n</ol>\n<p>  平均时间复杂度：受增量影响<br>  是否稳定：否</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(List&lt;Integer&gt; shellList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = shellList.size();</span><br><span class=\"line\">    <span class=\"comment\">// 步长</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> stepSize = size / <span class=\"number\">2</span>; stepSize &gt; <span class=\"number\">0</span>; stepSize = stepSize / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历序列 根据步长插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = stepSize; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 待插入元素</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = shellList.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = i - stepSize;</span><br><span class=\"line\">            <span class=\"comment\">// 依次向前比较</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; shellList.get(j) &gt; temp; j = j - stepSize) &#123;</span><br><span class=\"line\">                shellList.set(j + stepSize, shellList.get(j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            shellList.set(j + stepSize, temp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>排序算法最关注的应该是时间复杂度了，在对排序算法的选择上，当然是优先选择更快的算法。\n在没有要求稳定的情况下，快排是第一选择。\n冒泡，选择，插入三种排序应该避免使用，因为有更好选择。\n归并排序由于其空间要求，所以需要考虑实际应用中内存空间的占用。可以作为在要求稳定情况\n下的快排的替代。\n希尔排序基于插入排序的优化，可以满足一般情况下的需求，而且相对快排实现更简单。</code></pre>","site":{"data":{}},"length":996,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章对常用的排序算法做个系统的回顾与总结。</p>","more":"<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>  基本思路：每次遍历，两两比较，确定一个位置的值<br>  平均时间复杂度：O(n^2)<br>  是否稳定：是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">algorithmTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; list = </span><br><span class=\"line\">    \t    Lists.newArrayList(<span class=\"number\">61</span>, <span class=\"number\">2</span>, <span class=\"number\">13</span>, <span class=\"number\">5</span>, <span class=\"number\">11</span>, <span class=\"number\">4</span>, <span class=\"number\">55</span>, <span class=\"number\">12</span>, <span class=\"number\">45</span>, <span class=\"number\">21</span>, <span class=\"number\">56</span>, <span class=\"number\">76</span>, <span class=\"number\">1</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 两两比较，外层循环表示循环次数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; list.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = list.size() - <span class=\"number\">1</span>; j &gt; i; j--) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把小的交换到前面</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list.get(j) &lt; list.get(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                swap(list, j, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>  基本思路：每一次遍历，确定一个位置的数据<br>  平均时间复杂度：O(n^2)<br>  是否稳定：否</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">chooseSort</span><span class=\"params\">(List&lt;Integer&gt; chooseList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; chooseList.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次循环最小值的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> choose = i;</span><br><span class=\"line\">        <span class=\"comment\">// 向后遍历，找出最小值元素所在下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; chooseList.size(); j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (chooseList.get(j) &lt; chooseList.get(i)) &#123;</span><br><span class=\"line\">                choose = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将最小值与当前首位交换</span></span><br><span class=\"line\">        swap(chooseList, i, choose);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>  基本思路：将第一个元素看作一个已经排好序的序列，从第二个元素开始，依次按顺序插入序列中。<br>  平均时间复杂度：O(n^2)<br>  是否稳定：是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">insertSort</span><span class=\"params\">(List&lt;Integer&gt; insertList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">    <span class=\"comment\">// 因为第一个元素可以看作有序的，所以从第二个元素开始排序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; insertList.size(); i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 待插入元素</span></span><br><span class=\"line\">        temp = insertList.get(i);</span><br><span class=\"line\">        j = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 依次向前比较，当前元素大于temp时，将该元素向后移动，然后继续向前遍历</span></span><br><span class=\"line\">        <span class=\"comment\">// 因为是有序序列，如果当前元素小于等于temp，那么更前面的元素一定小于temp，不用继续遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; insertList.get(j) &gt; temp; j--) &#123;</span><br><span class=\"line\">            insertList.set(j + <span class=\"number\">1</span>, insertList.get(j));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 最后j的前一位便是应当插入的位置</span></span><br><span class=\"line\">        insertList.set(j + <span class=\"number\">1</span>, temp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>  基本思路：</p>\n<ol>\n<li>先设定一个基准值(可以是首位，也可以是随机一个)，然后从末尾向首位遍历，遇到比基准小的<br>便移往左边，再然后从首位向末尾遍历，遇到比基准大的便移往右边。最后得到基准值的下标</li>\n<li>以基准值下标为界，分为左右两部分，继续按照1中的逻辑分别继续递归处理</li>\n</ol>\n<p>  平均时间复杂度：O(NlogN)<br>  是否稳定：否</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">algorithmTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 快速排序</span></span><br><span class=\"line\">    List&lt;Integer&gt; quickList =</span><br><span class=\"line\">            Lists.newArrayList(<span class=\"number\">61</span>, <span class=\"number\">2</span>, <span class=\"number\">13</span>, <span class=\"number\">5</span>, <span class=\"number\">11</span>, <span class=\"number\">4</span>, <span class=\"number\">55</span>, <span class=\"number\">12</span>, <span class=\"number\">45</span>, <span class=\"number\">21</span>, <span class=\"number\">56</span>, <span class=\"number\">76</span>, <span class=\"number\">1</span>, <span class=\"number\">22</span>);</span><br><span class=\"line\">    quickSort(quickList, <span class=\"number\">0</span>, quickList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 递归处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(List&lt;Integer&gt; list, <span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x &lt; y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> middle = getMiddle(list, x, y);</span><br><span class=\"line\">        quickSort(list, x, middle - <span class=\"number\">1</span>);</span><br><span class=\"line\">        quickSort(list, middle + <span class=\"number\">1</span>, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 找出基准值的下标</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">getMiddle</span><span class=\"params\">(List&lt;Integer&gt; sortList, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> compareInt = sortList.get(start);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (start &lt; end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end &amp;&amp; sortList.get(end) &gt;= compareInt) &#123;</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(sortList, start, end);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end &amp;&amp; sortList.get(start) &lt;= compareInt) &#123;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        swap(sortList, start, end);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sortList.set(start, compareInt);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> start;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>  基本思路：</p>\n<ol>\n<li>将每一个元素看做一个有序序列</li>\n<li>将这些有序序列两两合并形成新的有序序列</li>\n<li>依次执行直到最终合并成一个有序序列</li>\n</ol>\n<p>  平均时间复杂度：O(NlogN)<br>  是否稳定：是</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(List&lt;Integer&gt; mergeList)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; tempList;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = mergeList.size();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> space = <span class=\"number\">1</span>; space &lt; size; space * = <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        tempList = Lists.newArrayListWithCapacity(mergeList.size());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>; start &lt; size; start += space * <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 分为两个有序序列 start-mid   mid-high</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = start + space &lt; size ? start + space : size;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> high = mid + space &lt; size ? mid + space : size;</span><br><span class=\"line\">            <span class=\"comment\">// 定义两个序列起始下标</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> start1 = start;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> start2 = mid;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start1 &lt; mid &amp;&amp; start2 &lt; high) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 从两个序列队首开始取其中小的塞入临时队列</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> min = mergeList.get(start1) &lt; mergeList.get(start2) ? </span><br><span class=\"line\">                          mergeList.get(start1++) : mergeList.get(start2++);</span><br><span class=\"line\">                tempList.add(min);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 处理可能剩下的数据</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start1 &lt; mid) &#123;</span><br><span class=\"line\">                tempList.add(mergeList.get(start1++));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (start2 &lt; high) &#123;</span><br><span class=\"line\">                tempList.add(mergeList.get(start2++));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 结束一次归并 将临时队列复制到原队列中 继续排序</span></span><br><span class=\"line\">        mergeList.clear();</span><br><span class=\"line\">        mergeList.addAll(tempList);</span><br><span class=\"line\">        tempList.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><pre><code>堆的定义：用数组实现的二叉树，分为最大堆，最小堆两类。\n         在最大堆中，父节点的值比每一个子节点的值都要大；而在最小堆中，父节点的值比每一个\n         子节点的值都要小。\n         因此，最大堆的根节点既是数组中的最大值，同样，最小堆的根节点就是其最小值。</code></pre><p>  基本思路：</p>\n<ol>\n<li>利用堆的特性，首先将无序序列构建成一个堆，得到其最大|最小值</li>\n<li>将根节点与序列队尾置换</li>\n<li>抛开队尾元素，调整序列使其重新成为一个堆，然后重复2，3步骤</li>\n</ol>\n<p>  平均时间复杂度：O(NlogN)<br>  是否稳定：否</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">heapSort</span><span class=\"params\">(List&lt;Integer&gt; heapList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = heapList.size();</span><br><span class=\"line\">    maxHeap(heapList, size);</span><br><span class=\"line\">    <span class=\"comment\">// 开始排序</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = size - <span class=\"number\">1</span>; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 首尾互换</span></span><br><span class=\"line\">        swap(heapList, <span class=\"number\">0</span>, j);</span><br><span class=\"line\">        <span class=\"comment\">// 构造最大堆</span></span><br><span class=\"line\">        maxHeap(heapList, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造最大堆</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">maxHeap</span><span class=\"params\">(List&lt;Integer&gt; heapList, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 第一个非叶子节点 2n+1 = size-1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = size / <span class=\"number\">2</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 构造最大堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> root = start; root &gt; -<span class=\"number\">1</span>; root--) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 左右子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">2</span> * root + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = left + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 取子节点最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> swap = left;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right &lt; size &amp;&amp; heapList.get(left) &lt; heapList.get(right)) &#123;</span><br><span class=\"line\">            swap = right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 取最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (heapList.get(swap) &gt; heapList.get(root)) &#123;</span><br><span class=\"line\">            swap(heapList, root, swap);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>  基本思路：希尔排序是基于插入排序做的优化，插入排序在序列基本有序的前提下性能会大大提升。<br>  所以希尔排序的思路就是一步步使得序列基本有序。</p>\n<ol>\n<li>定义一个增量，如size/2，根据增量将序列分为n个序列</li>\n<li>对每个序列做插入排序</li>\n<li>按照计算方式，缩小增量，然后重复步骤2，直到增量为1，形成一个序列<br>4 .对最后一个序列做插入排序，因其基本有序，性能会大大提高</li>\n</ol>\n<p>  平均时间复杂度：受增量影响<br>  是否稳定：否</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">shellSort</span><span class=\"params\">(List&lt;Integer&gt; shellList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = shellList.size();</span><br><span class=\"line\">    <span class=\"comment\">// 步长</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> stepSize = size / <span class=\"number\">2</span>; stepSize &gt; <span class=\"number\">0</span>; stepSize = stepSize / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历序列 根据步长插入排序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = stepSize; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 待插入元素</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = shellList.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = i - stepSize;</span><br><span class=\"line\">            <span class=\"comment\">// 依次向前比较</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &gt;= <span class=\"number\">0</span> &amp;&amp; shellList.get(j) &gt; temp; j = j - stepSize) &#123;</span><br><span class=\"line\">                shellList.set(j + stepSize, shellList.get(j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            shellList.set(j + stepSize, temp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>排序算法最关注的应该是时间复杂度了，在对排序算法的选择上，当然是优先选择更快的算法。\n在没有要求稳定的情况下，快排是第一选择。\n冒泡，选择，插入三种排序应该避免使用，因为有更好选择。\n归并排序由于其空间要求，所以需要考虑实际应用中内存空间的占用。可以作为在要求稳定情况\n下的快排的替代。\n希尔排序基于插入排序的优化，可以满足一般情况下的需求，而且相对快排实现更简单。</code></pre>"},{"title":"算法笔记-贪心算法","date":"2021-04-12T13:48:57.000Z","_content":"\n### 思路\n\n贪心算法的思路即每一次操作都是最优的，那么这些最优操作的最终结果也就是最优解。\n\n<!-- more -->\n\n### 分配问题\n   \n#### 1.问题描述\n\n\t有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多\n\t一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可\n\t以吃饱。\n  \n#### 解题思路\n    \n     根据贪心算法的思路，每一次分配饼干都选择最容易满足的，即饥饿度最小的孩子。选择恰好\n     能满足他的饼干，即饼干大小大于等于其饥饿度中最小的饼干。这样能保证每一次分配都不浪\n     费，能够尽可能多的满足孩子。\n\n{% codeblock lang:go %}\nfunc assignCookies(childs, cookies MyInt) int {\n\tsort.Sort(childs)\n\tsort.Sort(cookies)\n\ti := 0\n\tj := 0\n\tfor ; i < len(childs) && j < len(cookies); j++ {\n\t\tif childs[i] <= cookies[j] {\n\t\t\t// 喂饼干 并切换到下一个小孩\n\t\t\ti++\n\t\t}\n\t}\n\treturn i\n}\n{% endcodeblock %}\n\n#### 2.问题描述\n\n\t一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一\n\t个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果。\n\t所有孩子至少要有一个糖果。求解最少需要多少个糖果。\n\n#### 解题思路\n\n\t1. 因为要求每个孩子至少有一个糖果，所以最理想情况：所有孩子评分一样，那么结果是\n\t   每个孩子都有且只有一个糖果\n\t2. 以理想情况的结果为基础，先从左至右比较，因为要求最少糖果，所以只比评分低的孩\n\t   子多加一个糖果。这一轮比较完以后，可以确定最后一个孩子的糖果数就是最终结果\n\t3. 从最后一个孩子开始，从右至左开始比较，这样就能得到最后的结果\n\n{% codeblock lang:go %}\nfunc candy(childs []int) int {\n\tsize := len(childs)\n\tif size < 2 {\n\t\treturn size\n\t}\n\tresult := make([]int, size, size)\n\tfor i, element := range childs {\n\t\tif result[i] == 0 {\n\t\t\tresult[i] = 1\n\t\t}\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif element > childs[i-1] && result[i] <= result[i-1] {\n\t\t\tresult[i] = result[i-1] + 1\n\t\t}\n\t}\n\tcount := 0\n\tfor i := size - 1; i > 0; i-- {\n\t\tif childs[i] < childs[i-1] && result[i] >= result[i-1] {\n\t\t\tresult[i-1] = result[i] + 1\n\t\t}\n\t\tcount = count + result[i]\n\t}\n\tcount = count + result[0]\n\treturn count\n}\n{% endcodeblock %}\n\n### 区间问题\n\n#### 问题描述\n\n    给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠\n\n#### 解题思路\n\n    需要统计重叠的最少区间，就需要按照一定顺序依次判断确定。\n    1. 将区间集合按照尾端顺序排序\n    2. 设置一个当前区间，初始化为第一个区间\n    3. 从第二个区间开始遍历，与当前区间比较，重叠则统计为移除区间，反之取代当前区间\n    4. 重复3，直至结束\n\n{% codeblock lang:go %}\nfunc eraseOverlapIntervals(param [][]int) int {\n\tsize := len(param)\n\tif size < 2 {\n\t\treturn 0\n\t}\n\t// 按照尾端升序排序\n\tfor block := size / 2; block >= 1; block = block / 2 {\n\t\tfor i := block; i < size; i = i + block {\n\t\t\tcurrent := param[i]\n\t\t\tj := i - block\n\t\t\tfor ; j >= 0; {\n\t\t\t\tloop := param[j]\n\t\t\t\tif loop[1] > current[1] {\n\t\t\t\t\tparam[j+block] = loop\n\t\t\t\t\tj = j - block\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tparam[j+block] = current\n\t\t}\n\t}\t// 筛选\n\tcount := 0\n\tcurrentNum := param[0][1]\n\tfor i := 1; i < size; i++ {\n\t\tif param[i][0] < currentNum {\n\t\t\tcount++\n\t\t\tcontinue\n\t\t}\n\t\tcurrentNum = param[i][1]\n\t}\n\treturn count\n}\n{% endcodeblock %}\n\n### 总结\n    \n    贪心算法的策略是找到一个问题的每次操作的最优解，但对于每个问题的操作最优解的体现是不一样的。\n    饼干分配的最优解是先满足饥饿度最小的孩子，这样能够余留足够多的饼干尽可能多的满足剩下的孩子。\n    糖果分配的问题最优解是先确定一边的孩子糖果满足条件，再确定另一边的。\n    区间问题则只要按照x轴从左到右确定区间，这样就能保证留下的区间是最多的，那么\n 去除的区间自然就是最少的。\n    总体而言，使用贪心算法的前提是能保证每次操作的最优解必然能得出最优的结果，反之则无法使用贪心算\n    法解决问题。通常来看，其比较适合解决一些最大最小值的问题。","source":"_posts/2021/04/greedy-algorithms.md","raw":"---\ntitle: 算法笔记-贪心算法\ndate: 2021-04-12 21:48:57\ntags:\n- 算法笔记\ncategories:\n- 算法\n- 算法笔记\n- 贪心算法\n---\n\n### 思路\n\n贪心算法的思路即每一次操作都是最优的，那么这些最优操作的最终结果也就是最优解。\n\n<!-- more -->\n\n### 分配问题\n   \n#### 1.问题描述\n\n\t有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多\n\t一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可\n\t以吃饱。\n  \n#### 解题思路\n    \n     根据贪心算法的思路，每一次分配饼干都选择最容易满足的，即饥饿度最小的孩子。选择恰好\n     能满足他的饼干，即饼干大小大于等于其饥饿度中最小的饼干。这样能保证每一次分配都不浪\n     费，能够尽可能多的满足孩子。\n\n{% codeblock lang:go %}\nfunc assignCookies(childs, cookies MyInt) int {\n\tsort.Sort(childs)\n\tsort.Sort(cookies)\n\ti := 0\n\tj := 0\n\tfor ; i < len(childs) && j < len(cookies); j++ {\n\t\tif childs[i] <= cookies[j] {\n\t\t\t// 喂饼干 并切换到下一个小孩\n\t\t\ti++\n\t\t}\n\t}\n\treturn i\n}\n{% endcodeblock %}\n\n#### 2.问题描述\n\n\t一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一\n\t个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果。\n\t所有孩子至少要有一个糖果。求解最少需要多少个糖果。\n\n#### 解题思路\n\n\t1. 因为要求每个孩子至少有一个糖果，所以最理想情况：所有孩子评分一样，那么结果是\n\t   每个孩子都有且只有一个糖果\n\t2. 以理想情况的结果为基础，先从左至右比较，因为要求最少糖果，所以只比评分低的孩\n\t   子多加一个糖果。这一轮比较完以后，可以确定最后一个孩子的糖果数就是最终结果\n\t3. 从最后一个孩子开始，从右至左开始比较，这样就能得到最后的结果\n\n{% codeblock lang:go %}\nfunc candy(childs []int) int {\n\tsize := len(childs)\n\tif size < 2 {\n\t\treturn size\n\t}\n\tresult := make([]int, size, size)\n\tfor i, element := range childs {\n\t\tif result[i] == 0 {\n\t\t\tresult[i] = 1\n\t\t}\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif element > childs[i-1] && result[i] <= result[i-1] {\n\t\t\tresult[i] = result[i-1] + 1\n\t\t}\n\t}\n\tcount := 0\n\tfor i := size - 1; i > 0; i-- {\n\t\tif childs[i] < childs[i-1] && result[i] >= result[i-1] {\n\t\t\tresult[i-1] = result[i] + 1\n\t\t}\n\t\tcount = count + result[i]\n\t}\n\tcount = count + result[0]\n\treturn count\n}\n{% endcodeblock %}\n\n### 区间问题\n\n#### 问题描述\n\n    给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠\n\n#### 解题思路\n\n    需要统计重叠的最少区间，就需要按照一定顺序依次判断确定。\n    1. 将区间集合按照尾端顺序排序\n    2. 设置一个当前区间，初始化为第一个区间\n    3. 从第二个区间开始遍历，与当前区间比较，重叠则统计为移除区间，反之取代当前区间\n    4. 重复3，直至结束\n\n{% codeblock lang:go %}\nfunc eraseOverlapIntervals(param [][]int) int {\n\tsize := len(param)\n\tif size < 2 {\n\t\treturn 0\n\t}\n\t// 按照尾端升序排序\n\tfor block := size / 2; block >= 1; block = block / 2 {\n\t\tfor i := block; i < size; i = i + block {\n\t\t\tcurrent := param[i]\n\t\t\tj := i - block\n\t\t\tfor ; j >= 0; {\n\t\t\t\tloop := param[j]\n\t\t\t\tif loop[1] > current[1] {\n\t\t\t\t\tparam[j+block] = loop\n\t\t\t\t\tj = j - block\n\t\t\t\t} else {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tparam[j+block] = current\n\t\t}\n\t}\t// 筛选\n\tcount := 0\n\tcurrentNum := param[0][1]\n\tfor i := 1; i < size; i++ {\n\t\tif param[i][0] < currentNum {\n\t\t\tcount++\n\t\t\tcontinue\n\t\t}\n\t\tcurrentNum = param[i][1]\n\t}\n\treturn count\n}\n{% endcodeblock %}\n\n### 总结\n    \n    贪心算法的策略是找到一个问题的每次操作的最优解，但对于每个问题的操作最优解的体现是不一样的。\n    饼干分配的最优解是先满足饥饿度最小的孩子，这样能够余留足够多的饼干尽可能多的满足剩下的孩子。\n    糖果分配的问题最优解是先确定一边的孩子糖果满足条件，再确定另一边的。\n    区间问题则只要按照x轴从左到右确定区间，这样就能保证留下的区间是最多的，那么\n 去除的区间自然就是最少的。\n    总体而言，使用贪心算法的前提是能保证每次操作的最优解必然能得出最优的结果，反之则无法使用贪心算\n    法解决问题。通常来看，其比较适合解决一些最大最小值的问题。","slug":"greedy-algorithms","published":1,"updated":"2021-04-19T13:58:00.693Z","_id":"cknenrm3a0000vwb51t2w1w9m","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>贪心算法的思路即每一次操作都是最优的，那么这些最优操作的最终结果也就是最优解。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"分配问题\"><a href=\"#分配问题\" class=\"headerlink\" title=\"分配问题\"></a>分配问题</h3><h4 id=\"1-问题描述\"><a href=\"#1-问题描述\" class=\"headerlink\" title=\"1.问题描述\"></a>1.问题描述</h4><pre><code>有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多\n一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可\n以吃饱。</code></pre><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>根据贪心算法的思路，每一次分配饼干都选择最容易满足的，即饥饿度最小的孩子。选择恰好\n能满足他的饼干，即饼干大小大于等于其饥饿度中最小的饼干。这样能保证每一次分配都不浪\n费，能够尽可能多的满足孩子。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">assignCookies</span><span class=\"params\">(childs, cookies MyInt)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsort.Sort(childs)</span><br><span class=\"line\">\tsort.Sort(cookies)</span><br><span class=\"line\">\ti := <span class=\"number\">0</span></span><br><span class=\"line\">\tj := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; i &lt; <span class=\"built_in\">len</span>(childs) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(cookies); j++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> childs[i] &lt;= cookies[j] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 喂饼干 并切换到下一个小孩</span></span><br><span class=\"line\">\t\t\ti++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-问题描述\"><a href=\"#2-问题描述\" class=\"headerlink\" title=\"2.问题描述\"></a>2.问题描述</h4><pre><code>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一\n个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果。\n所有孩子至少要有一个糖果。求解最少需要多少个糖果。</code></pre><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>1. 因为要求每个孩子至少有一个糖果，所以最理想情况：所有孩子评分一样，那么结果是\n   每个孩子都有且只有一个糖果\n2. 以理想情况的结果为基础，先从左至右比较，因为要求最少糖果，所以只比评分低的孩\n   子多加一个糖果。这一轮比较完以后，可以确定最后一个孩子的糖果数就是最终结果\n3. 从最后一个孩子开始，从右至左开始比较，这样就能得到最后的结果</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">candy</span><span class=\"params\">(childs []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(childs)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> size</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tresult := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, size, size)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, element := <span class=\"keyword\">range</span> childs &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> result[i] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tresult[i] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> element &gt; childs[i<span class=\"number\">-1</span>] &amp;&amp; result[i] &lt;= result[i<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">\t\t\tresult[i] = result[i<span class=\"number\">-1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcount := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := size - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> childs[i] &lt; childs[i<span class=\"number\">-1</span>] &amp;&amp; result[i] &gt;= result[i<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">\t\t\tresult[i<span class=\"number\">-1</span>] = result[i] + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcount = count + result[i]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcount = count + result[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> count</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"区间问题\"><a href=\"#区间问题\" class=\"headerlink\" title=\"区间问题\"></a>区间问题</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠</code></pre><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>需要统计重叠的最少区间，就需要按照一定顺序依次判断确定。\n1. 将区间集合按照尾端顺序排序\n2. 设置一个当前区间，初始化为第一个区间\n3. 从第二个区间开始遍历，与当前区间比较，重叠则统计为移除区间，反之取代当前区间\n4. 重复3，直至结束</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">eraseOverlapIntervals</span><span class=\"params\">(param [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(param)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 按照尾端升序排序</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> block := size / <span class=\"number\">2</span>; block &gt;= <span class=\"number\">1</span>; block = block / <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := block; i &lt; size; i = i + block &#123;</span><br><span class=\"line\">\t\t\tcurrent := param[i]</span><br><span class=\"line\">\t\t\tj := i - block</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ; j &gt;= <span class=\"number\">0</span>; &#123;</span><br><span class=\"line\">\t\t\t\tloop := param[j]</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> loop[<span class=\"number\">1</span>] &gt; current[<span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\t\tparam[j+block] = loop</span><br><span class=\"line\">\t\t\t\t\tj = j - block</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tparam[j+block] = current</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;\t<span class=\"comment\">// 筛选</span></span><br><span class=\"line\">\tcount := <span class=\"number\">0</span></span><br><span class=\"line\">\tcurrentNum := param[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; size; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> param[i][<span class=\"number\">0</span>] &lt; currentNum &#123;</span><br><span class=\"line\">\t\t\tcount++</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcurrentNum = param[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> count</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>贪心算法的策略是找到一个问题的每次操作的最优解，但对于每个问题的操作最优解的体现是不一样的。\n饼干分配的最优解是先满足饥饿度最小的孩子，这样能够余留足够多的饼干尽可能多的满足剩下的孩子。\n糖果分配的问题最优解是先确定一边的孩子糖果满足条件，再确定另一边的。\n区间问题则只要按照x轴从左到右确定区间，这样就能保证留下的区间是最多的，那么</code></pre><p> 去除的区间自然就是最少的。<br>    总体而言，使用贪心算法的前提是能保证每次操作的最优解必然能得出最优的结果，反之则无法使用贪心算<br>    法解决问题。通常来看，其比较适合解决一些最大最小值的问题。</p>\n","site":{"data":{}},"length":897,"excerpt":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>贪心算法的思路即每一次操作都是最优的，那么这些最优操作的最终结果也就是最优解。</p>","more":"<h3 id=\"分配问题\"><a href=\"#分配问题\" class=\"headerlink\" title=\"分配问题\"></a>分配问题</h3><h4 id=\"1-问题描述\"><a href=\"#1-问题描述\" class=\"headerlink\" title=\"1.问题描述\"></a>1.问题描述</h4><pre><code>有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃最多\n一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可\n以吃饱。</code></pre><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>根据贪心算法的思路，每一次分配饼干都选择最容易满足的，即饥饿度最小的孩子。选择恰好\n能满足他的饼干，即饼干大小大于等于其饥饿度中最小的饼干。这样能保证每一次分配都不浪\n费，能够尽可能多的满足孩子。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">assignCookies</span><span class=\"params\">(childs, cookies MyInt)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsort.Sort(childs)</span><br><span class=\"line\">\tsort.Sort(cookies)</span><br><span class=\"line\">\ti := <span class=\"number\">0</span></span><br><span class=\"line\">\tj := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; i &lt; <span class=\"built_in\">len</span>(childs) &amp;&amp; j &lt; <span class=\"built_in\">len</span>(cookies); j++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> childs[i] &lt;= cookies[j] &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 喂饼干 并切换到下一个小孩</span></span><br><span class=\"line\">\t\t\ti++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-问题描述\"><a href=\"#2-问题描述\" class=\"headerlink\" title=\"2.问题描述\"></a>2.问题描述</h4><pre><code>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一\n个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果。\n所有孩子至少要有一个糖果。求解最少需要多少个糖果。</code></pre><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>1. 因为要求每个孩子至少有一个糖果，所以最理想情况：所有孩子评分一样，那么结果是\n   每个孩子都有且只有一个糖果\n2. 以理想情况的结果为基础，先从左至右比较，因为要求最少糖果，所以只比评分低的孩\n   子多加一个糖果。这一轮比较完以后，可以确定最后一个孩子的糖果数就是最终结果\n3. 从最后一个孩子开始，从右至左开始比较，这样就能得到最后的结果</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">candy</span><span class=\"params\">(childs []<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(childs)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> size</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tresult := <span class=\"built_in\">make</span>([]<span class=\"keyword\">int</span>, size, size)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i, element := <span class=\"keyword\">range</span> childs &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> result[i] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tresult[i] = <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> i == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> element &gt; childs[i<span class=\"number\">-1</span>] &amp;&amp; result[i] &lt;= result[i<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">\t\t\tresult[i] = result[i<span class=\"number\">-1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcount := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := size - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i-- &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> childs[i] &lt; childs[i<span class=\"number\">-1</span>] &amp;&amp; result[i] &gt;= result[i<span class=\"number\">-1</span>] &#123;</span><br><span class=\"line\">\t\t\tresult[i<span class=\"number\">-1</span>] = result[i] + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcount = count + result[i]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcount = count + result[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> count</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"区间问题\"><a href=\"#区间问题\" class=\"headerlink\" title=\"区间问题\"></a>区间问题</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠</code></pre><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>需要统计重叠的最少区间，就需要按照一定顺序依次判断确定。\n1. 将区间集合按照尾端顺序排序\n2. 设置一个当前区间，初始化为第一个区间\n3. 从第二个区间开始遍历，与当前区间比较，重叠则统计为移除区间，反之取代当前区间\n4. 重复3，直至结束</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">eraseOverlapIntervals</span><span class=\"params\">(param [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(param)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size &lt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 按照尾端升序排序</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> block := size / <span class=\"number\">2</span>; block &gt;= <span class=\"number\">1</span>; block = block / <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i := block; i &lt; size; i = i + block &#123;</span><br><span class=\"line\">\t\t\tcurrent := param[i]</span><br><span class=\"line\">\t\t\tj := i - block</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ; j &gt;= <span class=\"number\">0</span>; &#123;</span><br><span class=\"line\">\t\t\t\tloop := param[j]</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> loop[<span class=\"number\">1</span>] &gt; current[<span class=\"number\">1</span>] &#123;</span><br><span class=\"line\">\t\t\t\t\tparam[j+block] = loop</span><br><span class=\"line\">\t\t\t\t\tj = j - block</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tparam[j+block] = current</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;\t<span class=\"comment\">// 筛选</span></span><br><span class=\"line\">\tcount := <span class=\"number\">0</span></span><br><span class=\"line\">\tcurrentNum := param[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; size; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> param[i][<span class=\"number\">0</span>] &lt; currentNum &#123;</span><br><span class=\"line\">\t\t\tcount++</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcurrentNum = param[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> count</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>贪心算法的策略是找到一个问题的每次操作的最优解，但对于每个问题的操作最优解的体现是不一样的。\n饼干分配的最优解是先满足饥饿度最小的孩子，这样能够余留足够多的饼干尽可能多的满足剩下的孩子。\n糖果分配的问题最优解是先确定一边的孩子糖果满足条件，再确定另一边的。\n区间问题则只要按照x轴从左到右确定区间，这样就能保证留下的区间是最多的，那么</code></pre><p> 去除的区间自然就是最少的。<br>    总体而言，使用贪心算法的前提是能保证每次操作的最优解必然能得出最优的结果，反之则无法使用贪心算<br>    法解决问题。通常来看，其比较适合解决一些最大最小值的问题。</p>"},{"title":"算法笔记-双指针","date":"2021-04-18T12:00:25.000Z","_content":"\n### 思路\n\n双指针，顾名思义，是指在遍历某个数组时用两个指针指向不同元素，协同达成某些目的。\n也可扩展为多数组多指针。\n\n<!-- more -->\n\n### Two Sum II\n\n#### 问题描述\n\n\t在一个增序的整数数组里找到两个数，使它们的和为给定值。\n\t已知有且只有一对解\n\n#### 解题思路\n\n{% codeblock lang:go %}\nfunc twoSum(numbers []int, target int) []int {\n\tleft := 0\n\tright := len(numbers) - 1\n\tfor left < right {\n\t\tleftNum := numbers[left]\n\t\trightNum := numbers[right]\n\t\ttotal := leftNum + rightNum\n\t\tif total == target {\n\t\t\tbreak\n\t\t}\n\t\tif total > target {\n\t\t\tright--\n\t\t\tcontinue\n\t\t}\n\t\tif total < target {\n\t\t\tleft++\n\t\t\tcontinue\n\t\t}\n\t}\n\tresult := [2]int{left + 1, right + 1}\n\treturn result[0:]\n}\n{% endcodeblock %}\n\n\n### Merge Sorted Array\n\n#### 问题描述\n\n    给定两个排序整数数组nums1和nums2，合并nums2成nums1为一个排序后的数组。\n    元件的数量初始化中nums1和nums2是m和n分别。您可以假定nums1大小等于m + n，使其具有足够的空间来容纳\n    中的其他元素nums2。\n\n#### 解题思路\n\n##### 思路1\n\n    因为nums1是有序的，\n    所以可以使用插入排序将nums2中的数据依次插入到nums1中\n\n{% codeblock lang:go %}\nfunc merge(nums1 []int, m int, nums2 []int, n int) {\n\tif m == 0 {\n\t\tcopy(nums1, nums2)\n\t\treturn\n\t}\n\tpointer1 := m - 1\n\tpointer2 := 0\n\tfor ; pointer1 < m+n && pointer2 < n; pointer1++ {\n\t\tif nums2[pointer2] >= nums1[pointer1] {\n\t\t\tnums1[pointer1+1] = nums2[pointer2]\n\t\t} else if nums2[pointer2] < nums1[pointer1] {\n\t\t\tcount := pointer1\n\t\t\tfor ; count >= 0 && nums2[pointer2] < nums1[count]; count-- {\n\t\t\t\tnums1[count+1] = nums1[count]\n\t\t\t}\n\t\t\tnums1[count+1] = nums2[pointer2]\n\t\t}\n\t\tpointer2++\n\t}\n}\n{% endcodeblock %}\n\n##### 思路2\n\n\t但是使用插入排序就浪费了nums2有序的条件，所以这里更好的思路是从两个数组最大的数开始比较，将其中更\n\t大的插入nums1的尾部。\n\n{% codeblock lang:go %}\nfunc merge(nums1 []int, m int, nums2 []int, n int) {\n\t// 指向nums1尾部的指针\n\tlast := m + n - 1\n\t// 遍历nums1的指针\n\tp1 := m - 1\n\t// 遍历nums2的指针\n\tp2 := n - 1\n\tfor p1 >= 0 && p2 >= 0 {\n\t    // 将二者更大的一个放入nums1的尾部\n\t\tif nums1[p1] >= nums2[p2] {\n\t\t\tnums1[last] = nums1[p1]\n\t\t\tp1--\n\t\t} else {\n\t\t\tnums1[last] = nums2[p2]\n\t\t\tp2--\n\t\t}\n\t\t// 尾部指针前移\n\t\tlast--\n\t}\n\t// 若此时nums2还有剩余则依次插入nums1即可\n\tfor ; p2 >= 0; p2-- {\n\t\tnums1[last] = nums2[p2]\n\t\tlast--\n\t}\n}\n{% endcodeblock %}\n\n### Linked List Cycle II\n\n#### 问题描述\n  \n    给定一个链表，返回循环开始的节点。如果没有循环，则返回null。\n    如果列表中有某些节点可以通过连续跟随next 指针再次到达，则链接列表中会有一个循环 。\n    在内部，pos 用于表示尾部next 指针连接到的节点的索引 。\n\n#### 解题思路\n\n    使用快慢指针(Floyd判圈法)就很容易的解决这个问题。\n    首先定义fast,slow两个指针，一个每次遍历两个节点，一个每次遍历一个节点。\n    如果，fast遍历到链表尽头，则表示没有循环；\n    反之，当fast，slow节点第一次相遇时，将fast节点复位到头节点，然后调整\n    fast节点每次也只遍历一个节点，这时，当fast与slow第二次相遇时的节点就是\n    循环的起始节点。\n\n{% codeblock lang:go %}\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc detectCycle(head *ListNode) *ListNode {\n\tif head == nil || head.Next == nil {\n\t\treturn nil\n\t}\n\tfast := head.Next.Next\n\tslow := head.Next\n\tfor fast != slow {\n\t\tif fast == nil || fast.Next == nil {\n\t\t\treturn nil\n\t\t}\n\t\tfast = fast.Next.Next\n\t\tslow = slow.Next\n\t}\n\tfast = head\n\tfor fast != slow {\n\t\tfast = fast.Next\n\t\tslow = slow.Next\n\t}\n\treturn fast\n}\n{% endcodeblock %}\n\n### Minimum Window Substring\n\n#### 问题描述\n\n    给定两个字符串 S 和T，求 S 中包含T 所有字符的最短连续子字符串的长度，同时要求时间\n    复杂度不得超过 O(n)。\n\n#### 解题思路\n\n    使用滑动窗口，定义两个指针start，end。先移动end找到包含目标字符串的子字符串，然后移动将start\n    向end靠近，尝试找到最短的子字符串。\n\n{% codeblock lang:go %}\nfunc minWindow(s string, t string) string {\n\ttSize := len(t)\n\tsSize := len(s)\n\t// 用于判断字符是否存在的map集合\n\t// key为目标字符串的每个字符\n\t// value是字符存在的个数，可能会有重复字符\n\tcheckArray := make(map[uint8]int, tSize)\n\t// 用于统计原字符串字符匹配的情况\n\tcountArray := make(map[uint8]int, tSize)\n\t// start end 指针用于构造窗口\n\t// minS用于记录子字符串的头\n\t// totalCount 目标字符串完全匹配的标识\n\t// countNum 当前匹配的标识\n\tstart, end, minS, totalCount, countNum := 0, 0, 0, 0, 0\n\t// 记录子字符串的最小长度\n\tminLen := sSize + 1\n\t// 初始化判断集合和匹配标识\n\tfor e := range t {\n\t\tif checkArray[t[e]] == 0 {\n\t\t\ttotalCount++\n\t\t}\n\t\tcheckArray[t[e]]++\n\t}\n\t// 找出最短匹配子字符串\n\tfor ; end < sSize; end++ {\n\t    // 找出匹配的子字符串\n\t\tif checkArray[s[end]] > 0 {\n\t\t\tcountArray[s[end]]++\n\t\t\tif countArray[s[end]] == checkArray[s[end]] {\n\t\t\t\tcountNum++\n\t\t\t}\n\t\t}\n\t\t// 滑动窗口，尝试找出更短的子字符串\n\t\tfor ; totalCount == countNum; start++ {\n\t\t\tcurrentLen := end - start + 1\n\t\t\tif minLen > currentLen {\n\t\t\t\tminS = start\n\t\t\t\tminLen = currentLen\n\t\t\t}\n\t\t\tif checkArray[s[start]] > 0 {\n\t\t\t\tcountArray[s[start]]--\n\t\t\t\tif countArray[s[start]] < checkArray[s[start]] {\n\t\t\t\t\tcountNum--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif minLen == sSize+1 {\n\t\treturn \"\"\n\t}\n\treturn s[minS : minS+minLen]\n}\n{% endcodeblock %}\n\n\n### 总结\n\n    双指针算法很显然，适用于对数组这类数据的操作问题。\n    但他的变化比较多，首先会有多指针多数组的情况，不同的问题，解决思路也大同小异，\n    例如上述判圈法和滑动窗口，虽然都是两个指针协作的思路，但具体实现却很不一样。\n    一方面需要把握其通过多个指针协同解决的主题思路，另一方面还是需要多多练习不同的\n    题目。","source":"_posts/2021/04/doublePointer-algorithms.md","raw":"---\ntitle: 算法笔记-双指针\ndate: 2021-04-18 20:00:25\ntags:\n- 算法笔记\ncategories:\n- 算法\n- 算法笔记\n- 双指针\n---\n\n### 思路\n\n双指针，顾名思义，是指在遍历某个数组时用两个指针指向不同元素，协同达成某些目的。\n也可扩展为多数组多指针。\n\n<!-- more -->\n\n### Two Sum II\n\n#### 问题描述\n\n\t在一个增序的整数数组里找到两个数，使它们的和为给定值。\n\t已知有且只有一对解\n\n#### 解题思路\n\n{% codeblock lang:go %}\nfunc twoSum(numbers []int, target int) []int {\n\tleft := 0\n\tright := len(numbers) - 1\n\tfor left < right {\n\t\tleftNum := numbers[left]\n\t\trightNum := numbers[right]\n\t\ttotal := leftNum + rightNum\n\t\tif total == target {\n\t\t\tbreak\n\t\t}\n\t\tif total > target {\n\t\t\tright--\n\t\t\tcontinue\n\t\t}\n\t\tif total < target {\n\t\t\tleft++\n\t\t\tcontinue\n\t\t}\n\t}\n\tresult := [2]int{left + 1, right + 1}\n\treturn result[0:]\n}\n{% endcodeblock %}\n\n\n### Merge Sorted Array\n\n#### 问题描述\n\n    给定两个排序整数数组nums1和nums2，合并nums2成nums1为一个排序后的数组。\n    元件的数量初始化中nums1和nums2是m和n分别。您可以假定nums1大小等于m + n，使其具有足够的空间来容纳\n    中的其他元素nums2。\n\n#### 解题思路\n\n##### 思路1\n\n    因为nums1是有序的，\n    所以可以使用插入排序将nums2中的数据依次插入到nums1中\n\n{% codeblock lang:go %}\nfunc merge(nums1 []int, m int, nums2 []int, n int) {\n\tif m == 0 {\n\t\tcopy(nums1, nums2)\n\t\treturn\n\t}\n\tpointer1 := m - 1\n\tpointer2 := 0\n\tfor ; pointer1 < m+n && pointer2 < n; pointer1++ {\n\t\tif nums2[pointer2] >= nums1[pointer1] {\n\t\t\tnums1[pointer1+1] = nums2[pointer2]\n\t\t} else if nums2[pointer2] < nums1[pointer1] {\n\t\t\tcount := pointer1\n\t\t\tfor ; count >= 0 && nums2[pointer2] < nums1[count]; count-- {\n\t\t\t\tnums1[count+1] = nums1[count]\n\t\t\t}\n\t\t\tnums1[count+1] = nums2[pointer2]\n\t\t}\n\t\tpointer2++\n\t}\n}\n{% endcodeblock %}\n\n##### 思路2\n\n\t但是使用插入排序就浪费了nums2有序的条件，所以这里更好的思路是从两个数组最大的数开始比较，将其中更\n\t大的插入nums1的尾部。\n\n{% codeblock lang:go %}\nfunc merge(nums1 []int, m int, nums2 []int, n int) {\n\t// 指向nums1尾部的指针\n\tlast := m + n - 1\n\t// 遍历nums1的指针\n\tp1 := m - 1\n\t// 遍历nums2的指针\n\tp2 := n - 1\n\tfor p1 >= 0 && p2 >= 0 {\n\t    // 将二者更大的一个放入nums1的尾部\n\t\tif nums1[p1] >= nums2[p2] {\n\t\t\tnums1[last] = nums1[p1]\n\t\t\tp1--\n\t\t} else {\n\t\t\tnums1[last] = nums2[p2]\n\t\t\tp2--\n\t\t}\n\t\t// 尾部指针前移\n\t\tlast--\n\t}\n\t// 若此时nums2还有剩余则依次插入nums1即可\n\tfor ; p2 >= 0; p2-- {\n\t\tnums1[last] = nums2[p2]\n\t\tlast--\n\t}\n}\n{% endcodeblock %}\n\n### Linked List Cycle II\n\n#### 问题描述\n  \n    给定一个链表，返回循环开始的节点。如果没有循环，则返回null。\n    如果列表中有某些节点可以通过连续跟随next 指针再次到达，则链接列表中会有一个循环 。\n    在内部，pos 用于表示尾部next 指针连接到的节点的索引 。\n\n#### 解题思路\n\n    使用快慢指针(Floyd判圈法)就很容易的解决这个问题。\n    首先定义fast,slow两个指针，一个每次遍历两个节点，一个每次遍历一个节点。\n    如果，fast遍历到链表尽头，则表示没有循环；\n    反之，当fast，slow节点第一次相遇时，将fast节点复位到头节点，然后调整\n    fast节点每次也只遍历一个节点，这时，当fast与slow第二次相遇时的节点就是\n    循环的起始节点。\n\n{% codeblock lang:go %}\ntype ListNode struct {\n\tVal  int\n\tNext *ListNode\n}\n\nfunc detectCycle(head *ListNode) *ListNode {\n\tif head == nil || head.Next == nil {\n\t\treturn nil\n\t}\n\tfast := head.Next.Next\n\tslow := head.Next\n\tfor fast != slow {\n\t\tif fast == nil || fast.Next == nil {\n\t\t\treturn nil\n\t\t}\n\t\tfast = fast.Next.Next\n\t\tslow = slow.Next\n\t}\n\tfast = head\n\tfor fast != slow {\n\t\tfast = fast.Next\n\t\tslow = slow.Next\n\t}\n\treturn fast\n}\n{% endcodeblock %}\n\n### Minimum Window Substring\n\n#### 问题描述\n\n    给定两个字符串 S 和T，求 S 中包含T 所有字符的最短连续子字符串的长度，同时要求时间\n    复杂度不得超过 O(n)。\n\n#### 解题思路\n\n    使用滑动窗口，定义两个指针start，end。先移动end找到包含目标字符串的子字符串，然后移动将start\n    向end靠近，尝试找到最短的子字符串。\n\n{% codeblock lang:go %}\nfunc minWindow(s string, t string) string {\n\ttSize := len(t)\n\tsSize := len(s)\n\t// 用于判断字符是否存在的map集合\n\t// key为目标字符串的每个字符\n\t// value是字符存在的个数，可能会有重复字符\n\tcheckArray := make(map[uint8]int, tSize)\n\t// 用于统计原字符串字符匹配的情况\n\tcountArray := make(map[uint8]int, tSize)\n\t// start end 指针用于构造窗口\n\t// minS用于记录子字符串的头\n\t// totalCount 目标字符串完全匹配的标识\n\t// countNum 当前匹配的标识\n\tstart, end, minS, totalCount, countNum := 0, 0, 0, 0, 0\n\t// 记录子字符串的最小长度\n\tminLen := sSize + 1\n\t// 初始化判断集合和匹配标识\n\tfor e := range t {\n\t\tif checkArray[t[e]] == 0 {\n\t\t\ttotalCount++\n\t\t}\n\t\tcheckArray[t[e]]++\n\t}\n\t// 找出最短匹配子字符串\n\tfor ; end < sSize; end++ {\n\t    // 找出匹配的子字符串\n\t\tif checkArray[s[end]] > 0 {\n\t\t\tcountArray[s[end]]++\n\t\t\tif countArray[s[end]] == checkArray[s[end]] {\n\t\t\t\tcountNum++\n\t\t\t}\n\t\t}\n\t\t// 滑动窗口，尝试找出更短的子字符串\n\t\tfor ; totalCount == countNum; start++ {\n\t\t\tcurrentLen := end - start + 1\n\t\t\tif minLen > currentLen {\n\t\t\t\tminS = start\n\t\t\t\tminLen = currentLen\n\t\t\t}\n\t\t\tif checkArray[s[start]] > 0 {\n\t\t\t\tcountArray[s[start]]--\n\t\t\t\tif countArray[s[start]] < checkArray[s[start]] {\n\t\t\t\t\tcountNum--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif minLen == sSize+1 {\n\t\treturn \"\"\n\t}\n\treturn s[minS : minS+minLen]\n}\n{% endcodeblock %}\n\n\n### 总结\n\n    双指针算法很显然，适用于对数组这类数据的操作问题。\n    但他的变化比较多，首先会有多指针多数组的情况，不同的问题，解决思路也大同小异，\n    例如上述判圈法和滑动窗口，虽然都是两个指针协作的思路，但具体实现却很不一样。\n    一方面需要把握其通过多个指针协同解决的主题思路，另一方面还是需要多多练习不同的\n    题目。","slug":"doublePointer-algorithms","published":1,"updated":"2021-04-22T13:08:46.362Z","_id":"cknn4imym0000hgb50wcses7c","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>双指针，顾名思义，是指在遍历某个数组时用两个指针指向不同元素，协同达成某些目的。<br>也可扩展为多数组多指针。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Two-Sum-II\"><a href=\"#Two-Sum-II\" class=\"headerlink\" title=\"Two Sum II\"></a>Two Sum II</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>在一个增序的整数数组里找到两个数，使它们的和为给定值。\n已知有且只有一对解</code></pre><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(numbers []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tleft := <span class=\"number\">0</span></span><br><span class=\"line\">\tright := <span class=\"built_in\">len</span>(numbers) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">\t\tleftNum := numbers[left]</span><br><span class=\"line\">\t\trightNum := numbers[right]</span><br><span class=\"line\">\t\ttotal := leftNum + rightNum</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> total == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> total &gt; target &#123;</span><br><span class=\"line\">\t\t\tright--</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> total &lt; target &#123;</span><br><span class=\"line\">\t\t\tleft++</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tresult := [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;left + <span class=\"number\">1</span>, right + <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result[<span class=\"number\">0</span>:]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Merge-Sorted-Array\"><a href=\"#Merge-Sorted-Array\" class=\"headerlink\" title=\"Merge Sorted Array\"></a>Merge Sorted Array</h3><h4 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定两个排序整数数组nums1和nums2，合并nums2成nums1为一个排序后的数组。\n元件的数量初始化中nums1和nums2是m和n分别。您可以假定nums1大小等于m + n，使其具有足够的空间来容纳\n中的其他元素nums2。</code></pre><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><h5 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h5><pre><code>因为nums1是有序的，\n所以可以使用插入排序将nums2中的数据依次插入到nums1中</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(nums1 []<span class=\"keyword\">int</span>, m <span class=\"keyword\">int</span>, nums2 []<span class=\"keyword\">int</span>, n <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> m == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(nums1, nums2)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpointer1 := m - <span class=\"number\">1</span></span><br><span class=\"line\">\tpointer2 := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; pointer1 &lt; m+n &amp;&amp; pointer2 &lt; n; pointer1++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums2[pointer2] &gt;= nums1[pointer1] &#123;</span><br><span class=\"line\">\t\t\tnums1[pointer1+<span class=\"number\">1</span>] = nums2[pointer2]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> nums2[pointer2] &lt; nums1[pointer1] &#123;</span><br><span class=\"line\">\t\t\tcount := pointer1</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ; count &gt;= <span class=\"number\">0</span> &amp;&amp; nums2[pointer2] &lt; nums1[count]; count-- &#123;</span><br><span class=\"line\">\t\t\t\tnums1[count+<span class=\"number\">1</span>] = nums1[count]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnums1[count+<span class=\"number\">1</span>] = nums2[pointer2]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpointer2++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"思路2\"><a href=\"#思路2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h5><pre><code>但是使用插入排序就浪费了nums2有序的条件，所以这里更好的思路是从两个数组最大的数开始比较，将其中更\n大的插入nums1的尾部。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(nums1 []<span class=\"keyword\">int</span>, m <span class=\"keyword\">int</span>, nums2 []<span class=\"keyword\">int</span>, n <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向nums1尾部的指针</span></span><br><span class=\"line\">\tlast := m + n - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"comment\">// 遍历nums1的指针</span></span><br><span class=\"line\">\tp1 := m - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"comment\">// 遍历nums2的指针</span></span><br><span class=\"line\">\tp2 := n - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> p1 &gt;= <span class=\"number\">0</span> &amp;&amp; p2 &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 将二者更大的一个放入nums1的尾部</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums1[p1] &gt;= nums2[p2] &#123;</span><br><span class=\"line\">\t\t\tnums1[last] = nums1[p1]</span><br><span class=\"line\">\t\t\tp1--</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tnums1[last] = nums2[p2]</span><br><span class=\"line\">\t\t\tp2--</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 尾部指针前移</span></span><br><span class=\"line\">\t\tlast--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 若此时nums2还有剩余则依次插入nums1即可</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; p2 &gt;= <span class=\"number\">0</span>; p2-- &#123;</span><br><span class=\"line\">\t\tnums1[last] = nums2[p2]</span><br><span class=\"line\">\t\tlast--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Linked-List-Cycle-II\"><a href=\"#Linked-List-Cycle-II\" class=\"headerlink\" title=\"Linked List Cycle II\"></a>Linked List Cycle II</h3><h4 id=\"问题描述-2\"><a href=\"#问题描述-2\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定一个链表，返回循环开始的节点。如果没有循环，则返回null。\n如果列表中有某些节点可以通过连续跟随next 指针再次到达，则链接列表中会有一个循环 。\n在内部，pos 用于表示尾部next 指针连接到的节点的索引 。</code></pre><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>使用快慢指针(Floyd判圈法)就很容易的解决这个问题。\n首先定义fast,slow两个指针，一个每次遍历两个节点，一个每次遍历一个节点。\n如果，fast遍历到链表尽头，则表示没有循环；\n反之，当fast，slow节点第一次相遇时，将fast节点复位到头节点，然后调整\nfast节点每次也只遍历一个节点，这时，当fast与slow第二次相遇时的节点就是\n循环的起始节点。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tVal  <span class=\"keyword\">int</span></span><br><span class=\"line\">\tNext *ListNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">detectCycle</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfast := head.Next.Next</span><br><span class=\"line\">\tslow := head.Next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> fast != slow &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> fast == <span class=\"literal\">nil</span> || fast.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfast = fast.Next.Next</span><br><span class=\"line\">\t\tslow = slow.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfast = head</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> fast != slow &#123;</span><br><span class=\"line\">\t\tfast = fast.Next</span><br><span class=\"line\">\t\tslow = slow.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fast</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Minimum-Window-Substring\"><a href=\"#Minimum-Window-Substring\" class=\"headerlink\" title=\"Minimum Window Substring\"></a>Minimum Window Substring</h3><h4 id=\"问题描述-3\"><a href=\"#问题描述-3\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定两个字符串 S 和T，求 S 中包含T 所有字符的最短连续子字符串的长度，同时要求时间\n复杂度不得超过 O(n)。</code></pre><h4 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>使用滑动窗口，定义两个指针start，end。先移动end找到包含目标字符串的子字符串，然后移动将start\n向end靠近，尝试找到最短的子字符串。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minWindow</span><span class=\"params\">(s <span class=\"keyword\">string</span>, t <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\ttSize := <span class=\"built_in\">len</span>(t)</span><br><span class=\"line\">\tsSize := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">\t<span class=\"comment\">// 用于判断字符是否存在的map集合</span></span><br><span class=\"line\">\t<span class=\"comment\">// key为目标字符串的每个字符</span></span><br><span class=\"line\">\t<span class=\"comment\">// value是字符存在的个数，可能会有重复字符</span></span><br><span class=\"line\">\tcheckArray := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">uint8</span>]<span class=\"keyword\">int</span>, tSize)</span><br><span class=\"line\">\t<span class=\"comment\">// 用于统计原字符串字符匹配的情况</span></span><br><span class=\"line\">\tcountArray := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">uint8</span>]<span class=\"keyword\">int</span>, tSize)</span><br><span class=\"line\">\t<span class=\"comment\">// start end 指针用于构造窗口</span></span><br><span class=\"line\">\t<span class=\"comment\">// minS用于记录子字符串的头</span></span><br><span class=\"line\">\t<span class=\"comment\">// totalCount 目标字符串完全匹配的标识</span></span><br><span class=\"line\">\t<span class=\"comment\">// countNum 当前匹配的标识</span></span><br><span class=\"line\">\tstart, end, minS, totalCount, countNum := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"comment\">// 记录子字符串的最小长度</span></span><br><span class=\"line\">\tminLen := sSize + <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化判断集合和匹配标识</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> e := <span class=\"keyword\">range</span> t &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> checkArray[t[e]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ttotalCount++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcheckArray[t[e]]++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找出最短匹配子字符串</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; end &lt; sSize; end++ &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 找出匹配的子字符串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> checkArray[s[end]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tcountArray[s[end]]++</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> countArray[s[end]] == checkArray[s[end]] &#123;</span><br><span class=\"line\">\t\t\t\tcountNum++</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 滑动窗口，尝试找出更短的子字符串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; totalCount == countNum; start++ &#123;</span><br><span class=\"line\">\t\t\tcurrentLen := end - start + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> minLen &gt; currentLen &#123;</span><br><span class=\"line\">\t\t\t\tminS = start</span><br><span class=\"line\">\t\t\t\tminLen = currentLen</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> checkArray[s[start]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tcountArray[s[start]]--</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> countArray[s[start]] &lt; checkArray[s[start]] &#123;</span><br><span class=\"line\">\t\t\t\t\tcountNum--</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> minLen == sSize+<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[minS : minS+minLen]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>双指针算法很显然，适用于对数组这类数据的操作问题。\n但他的变化比较多，首先会有多指针多数组的情况，不同的问题，解决思路也大同小异，\n例如上述判圈法和滑动窗口，虽然都是两个指针协作的思路，但具体实现却很不一样。\n一方面需要把握其通过多个指针协同解决的主题思路，另一方面还是需要多多练习不同的\n题目。</code></pre>","site":{"data":{}},"length":966,"excerpt":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>双指针，顾名思义，是指在遍历某个数组时用两个指针指向不同元素，协同达成某些目的。<br>也可扩展为多数组多指针。</p>","more":"<h3 id=\"Two-Sum-II\"><a href=\"#Two-Sum-II\" class=\"headerlink\" title=\"Two Sum II\"></a>Two Sum II</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>在一个增序的整数数组里找到两个数，使它们的和为给定值。\n已知有且只有一对解</code></pre><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">twoSum</span><span class=\"params\">(numbers []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tleft := <span class=\"number\">0</span></span><br><span class=\"line\">\tright := <span class=\"built_in\">len</span>(numbers) - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> left &lt; right &#123;</span><br><span class=\"line\">\t\tleftNum := numbers[left]</span><br><span class=\"line\">\t\trightNum := numbers[right]</span><br><span class=\"line\">\t\ttotal := leftNum + rightNum</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> total == target &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> total &gt; target &#123;</span><br><span class=\"line\">\t\t\tright--</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> total &lt; target &#123;</span><br><span class=\"line\">\t\t\tleft++</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tresult := [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;left + <span class=\"number\">1</span>, right + <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result[<span class=\"number\">0</span>:]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Merge-Sorted-Array\"><a href=\"#Merge-Sorted-Array\" class=\"headerlink\" title=\"Merge Sorted Array\"></a>Merge Sorted Array</h3><h4 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定两个排序整数数组nums1和nums2，合并nums2成nums1为一个排序后的数组。\n元件的数量初始化中nums1和nums2是m和n分别。您可以假定nums1大小等于m + n，使其具有足够的空间来容纳\n中的其他元素nums2。</code></pre><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><h5 id=\"思路1\"><a href=\"#思路1\" class=\"headerlink\" title=\"思路1\"></a>思路1</h5><pre><code>因为nums1是有序的，\n所以可以使用插入排序将nums2中的数据依次插入到nums1中</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(nums1 []<span class=\"keyword\">int</span>, m <span class=\"keyword\">int</span>, nums2 []<span class=\"keyword\">int</span>, n <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> m == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">copy</span>(nums1, nums2)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpointer1 := m - <span class=\"number\">1</span></span><br><span class=\"line\">\tpointer2 := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; pointer1 &lt; m+n &amp;&amp; pointer2 &lt; n; pointer1++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums2[pointer2] &gt;= nums1[pointer1] &#123;</span><br><span class=\"line\">\t\t\tnums1[pointer1+<span class=\"number\">1</span>] = nums2[pointer2]</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> nums2[pointer2] &lt; nums1[pointer1] &#123;</span><br><span class=\"line\">\t\t\tcount := pointer1</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> ; count &gt;= <span class=\"number\">0</span> &amp;&amp; nums2[pointer2] &lt; nums1[count]; count-- &#123;</span><br><span class=\"line\">\t\t\t\tnums1[count+<span class=\"number\">1</span>] = nums1[count]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tnums1[count+<span class=\"number\">1</span>] = nums2[pointer2]</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tpointer2++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"思路2\"><a href=\"#思路2\" class=\"headerlink\" title=\"思路2\"></a>思路2</h5><pre><code>但是使用插入排序就浪费了nums2有序的条件，所以这里更好的思路是从两个数组最大的数开始比较，将其中更\n大的插入nums1的尾部。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(nums1 []<span class=\"keyword\">int</span>, m <span class=\"keyword\">int</span>, nums2 []<span class=\"keyword\">int</span>, n <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 指向nums1尾部的指针</span></span><br><span class=\"line\">\tlast := m + n - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"comment\">// 遍历nums1的指针</span></span><br><span class=\"line\">\tp1 := m - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"comment\">// 遍历nums2的指针</span></span><br><span class=\"line\">\tp2 := n - <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> p1 &gt;= <span class=\"number\">0</span> &amp;&amp; p2 &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 将二者更大的一个放入nums1的尾部</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums1[p1] &gt;= nums2[p2] &#123;</span><br><span class=\"line\">\t\t\tnums1[last] = nums1[p1]</span><br><span class=\"line\">\t\t\tp1--</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tnums1[last] = nums2[p2]</span><br><span class=\"line\">\t\t\tp2--</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 尾部指针前移</span></span><br><span class=\"line\">\t\tlast--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 若此时nums2还有剩余则依次插入nums1即可</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; p2 &gt;= <span class=\"number\">0</span>; p2-- &#123;</span><br><span class=\"line\">\t\tnums1[last] = nums2[p2]</span><br><span class=\"line\">\t\tlast--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Linked-List-Cycle-II\"><a href=\"#Linked-List-Cycle-II\" class=\"headerlink\" title=\"Linked List Cycle II\"></a>Linked List Cycle II</h3><h4 id=\"问题描述-2\"><a href=\"#问题描述-2\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定一个链表，返回循环开始的节点。如果没有循环，则返回null。\n如果列表中有某些节点可以通过连续跟随next 指针再次到达，则链接列表中会有一个循环 。\n在内部，pos 用于表示尾部next 指针连接到的节点的索引 。</code></pre><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>使用快慢指针(Floyd判圈法)就很容易的解决这个问题。\n首先定义fast,slow两个指针，一个每次遍历两个节点，一个每次遍历一个节点。\n如果，fast遍历到链表尽头，则表示没有循环；\n反之，当fast，slow节点第一次相遇时，将fast节点复位到头节点，然后调整\nfast节点每次也只遍历一个节点，这时，当fast与slow第二次相遇时的节点就是\n循环的起始节点。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ListNode <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tVal  <span class=\"keyword\">int</span></span><br><span class=\"line\">\tNext *ListNode</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">detectCycle</span><span class=\"params\">(head *ListNode)</span> *<span class=\"title\">ListNode</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> head == <span class=\"literal\">nil</span> || head.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfast := head.Next.Next</span><br><span class=\"line\">\tslow := head.Next</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> fast != slow &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> fast == <span class=\"literal\">nil</span> || fast.Next == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tfast = fast.Next.Next</span><br><span class=\"line\">\t\tslow = slow.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tfast = head</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> fast != slow &#123;</span><br><span class=\"line\">\t\tfast = fast.Next</span><br><span class=\"line\">\t\tslow = slow.Next</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fast</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Minimum-Window-Substring\"><a href=\"#Minimum-Window-Substring\" class=\"headerlink\" title=\"Minimum Window Substring\"></a>Minimum Window Substring</h3><h4 id=\"问题描述-3\"><a href=\"#问题描述-3\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定两个字符串 S 和T，求 S 中包含T 所有字符的最短连续子字符串的长度，同时要求时间\n复杂度不得超过 O(n)。</code></pre><h4 id=\"解题思路-3\"><a href=\"#解题思路-3\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>使用滑动窗口，定义两个指针start，end。先移动end找到包含目标字符串的子字符串，然后移动将start\n向end靠近，尝试找到最短的子字符串。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minWindow</span><span class=\"params\">(s <span class=\"keyword\">string</span>, t <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\ttSize := <span class=\"built_in\">len</span>(t)</span><br><span class=\"line\">\tsSize := <span class=\"built_in\">len</span>(s)</span><br><span class=\"line\">\t<span class=\"comment\">// 用于判断字符是否存在的map集合</span></span><br><span class=\"line\">\t<span class=\"comment\">// key为目标字符串的每个字符</span></span><br><span class=\"line\">\t<span class=\"comment\">// value是字符存在的个数，可能会有重复字符</span></span><br><span class=\"line\">\tcheckArray := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">uint8</span>]<span class=\"keyword\">int</span>, tSize)</span><br><span class=\"line\">\t<span class=\"comment\">// 用于统计原字符串字符匹配的情况</span></span><br><span class=\"line\">\tcountArray := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">uint8</span>]<span class=\"keyword\">int</span>, tSize)</span><br><span class=\"line\">\t<span class=\"comment\">// start end 指针用于构造窗口</span></span><br><span class=\"line\">\t<span class=\"comment\">// minS用于记录子字符串的头</span></span><br><span class=\"line\">\t<span class=\"comment\">// totalCount 目标字符串完全匹配的标识</span></span><br><span class=\"line\">\t<span class=\"comment\">// countNum 当前匹配的标识</span></span><br><span class=\"line\">\tstart, end, minS, totalCount, countNum := <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"comment\">// 记录子字符串的最小长度</span></span><br><span class=\"line\">\tminLen := sSize + <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化判断集合和匹配标识</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> e := <span class=\"keyword\">range</span> t &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> checkArray[t[e]] == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\ttotalCount++</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcheckArray[t[e]]++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 找出最短匹配子字符串</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; end &lt; sSize; end++ &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// 找出匹配的子字符串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> checkArray[s[end]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\tcountArray[s[end]]++</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> countArray[s[end]] == checkArray[s[end]] &#123;</span><br><span class=\"line\">\t\t\t\tcountNum++</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 滑动窗口，尝试找出更短的子字符串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ; totalCount == countNum; start++ &#123;</span><br><span class=\"line\">\t\t\tcurrentLen := end - start + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> minLen &gt; currentLen &#123;</span><br><span class=\"line\">\t\t\t\tminS = start</span><br><span class=\"line\">\t\t\t\tminLen = currentLen</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> checkArray[s[start]] &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\tcountArray[s[start]]--</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> countArray[s[start]] &lt; checkArray[s[start]] &#123;</span><br><span class=\"line\">\t\t\t\t\tcountNum--</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> minLen == sSize+<span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> s[minS : minS+minLen]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>双指针算法很显然，适用于对数组这类数据的操作问题。\n但他的变化比较多，首先会有多指针多数组的情况，不同的问题，解决思路也大同小异，\n例如上述判圈法和滑动窗口，虽然都是两个指针协作的思路，但具体实现却很不一样。\n一方面需要把握其通过多个指针协同解决的主题思路，另一方面还是需要多多练习不同的\n题目。</code></pre>"},{"title":"算法笔记-二分查找","date":"2021-04-22T13:26:49.000Z","_content":"\n### 思路\n\n     二分查找，也可以称作折半查找。\n     即在一个有序序列中，通过每次对中间位置元素的判断来逐步缩小查找范围。\n<!-- more -->\n\n### Sqrt(x)\n\n#### 问题描述\n\n    给定一个非负整数，求它的开方，向下取整。\n\n#### 解题思路\n\n    这个问题比较简单，一个非负整数的开发必然是小于等于他本身的。\n    所以我们可以将[0,x]看做一个有序序列，用二分查找的思想确定结果\n\n{% codeblock lang:go %}\nfunc mySqrt(x int) int {\n\tif x <= 1 {\n\t\treturn x\n\t}\n\tstart := 0\n\tend := x\n\ti := start + (end-start)/2\n\tfor ; i != start; i = start + (end-start)/2 {\n\t\ttemp := i * i\n\t\tif temp == x {\n\t\t\treturn i\n\t\t}\n\t\tif temp < x {\n\t\t\tstart = i\n\t\t}\n\t\tif temp > x {\n\t\t\tend = i\n\t\t}\n\t}\n\treturn i\n}\n{% endcodeblock %}\n\n### Find First and Last Position of Element in Sorted Array\n\n#### 问题描述\n\n\t给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置。\n\n#### 解题思路\n\n    因为数组是增序的，那么目标值肯定是连续的，只需要先找到任意一个目标值的位置，\n    然后向两边遍历就能找到其第一次和最后一次出现的位置。\n\n{% codeblock lang:go %}\nfunc searchRange(nums []int, target int) []int {\n\tresult := []int{-1, -1}\n\tsize := len(nums)\n\tif size == 0 {\n\t\treturn result\n\t}\n\tstart := 0\n\tend := size - 1\n\tmid := start + (end-start)/2\n\t// 使用二分查找查找目标值的任意一个位置\n\tfor start < end && nums[mid] != target {\n\t\tif nums[mid] > target {\n\t\t\tend = mid - 1\n\t\t} else {\n\t\t\tstart = mid + 1\n\t\t}\n\t\tmid = start + (end-start)/2\n\t}\n\tif nums[mid] != target {\n\t\treturn result\n\t}\n\t// 向两侧遍历找出第一次和最后一次出现的位置\n\tmin, max := mid-1, mid+1\n\tfor min >= start && nums[min] == target {\n\t\tmin--\n\t}\n\tfor max <= end && nums[max] == target {\n\t\tmax++\n\t}\n\tresult = []int{min + 1, max - 1}\n\treturn result\n}\n\n{% endcodeblock %}\n\n### Search in Rotated Sorted Array II\n\n#### 问题描述\n\n      一个原本增序的数组被首尾相连后按某个位置断开（如 [1,2,2,3,4,5] → [2,3,4,5,1,2]，在第\n    一位和第二位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。\n\n#### 解题思路\n\n    虽然数组不是整体有序，但是以断开点为准分为左右两个子集，都是各自增序的。只要在二分查找中判断\n    当前所在是左子集还是右子集就行。\n\n{% codeblock lang:go %}\nfunc search(nums []int, target int) bool {\n\tstart := 0\n\tend := len(nums) - 1\n\tmid := start + (end - start)/2\n\tfor ;start < end; mid = start + (end - start)/2{\n\t\tif target == nums[mid]{\n\t\t\treturn true\n\t\t}\n\t\tif nums[mid] == nums[start]{\n\t\t\t// 无法判断哪个子集，头指针向右移\n\t\t\tstart++\n\t\t}else{\n\t\t\tif nums[mid] > nums[start]{\n\t\t\t    // 中间节点在左子集\n\t\t\t\tif target == nums[start]{\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tif target < nums[mid] && target > nums[start]{\n\t\t\t\t    // 判断目标在左子集范围\n\t\t\t\t\tend = mid-1\n\t\t\t\t}else {\n\t\t\t\t    // 无法判断 头指针右移\n\t\t\t\t\tstart = mid+1\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t    // 中间节点右子集\n\t\t\t\tif target == nums[end]{\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tif target > nums[mid] && target < nums[end]{\n\t\t\t\t\t// 判断目标在右子集范围\n\t\t\t\t\tstart = mid+1\n\t\t\t\t}else {\n\t\t\t\t    // 无法判断 头指针右移\n\t\t\t\t\tend = mid-1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif target == nums[mid]{\n\t\treturn true\n\t}\n\treturn false\n}\n{% endcodeblock %}\n\n\n### 总结\n   \n    二分查找很好理解，十分依赖集合有序这个点。但并不一定是整体有序，就如旋转数组一样。\n    所以在使用二分查找时，需要找出目标集合的有序性，依据其有序性做为二分查找的依据。","source":"_posts/2021/04/binarySearch-algorithms.md","raw":"---\ntitle: 算法笔记-二分查找\ndate: 2021-04-22 21:26:49\ntags:\n- 算法笔记\ncategories:\n- 算法\n- 算法笔记\n- 二分查找\n---\n\n### 思路\n\n     二分查找，也可以称作折半查找。\n     即在一个有序序列中，通过每次对中间位置元素的判断来逐步缩小查找范围。\n<!-- more -->\n\n### Sqrt(x)\n\n#### 问题描述\n\n    给定一个非负整数，求它的开方，向下取整。\n\n#### 解题思路\n\n    这个问题比较简单，一个非负整数的开发必然是小于等于他本身的。\n    所以我们可以将[0,x]看做一个有序序列，用二分查找的思想确定结果\n\n{% codeblock lang:go %}\nfunc mySqrt(x int) int {\n\tif x <= 1 {\n\t\treturn x\n\t}\n\tstart := 0\n\tend := x\n\ti := start + (end-start)/2\n\tfor ; i != start; i = start + (end-start)/2 {\n\t\ttemp := i * i\n\t\tif temp == x {\n\t\t\treturn i\n\t\t}\n\t\tif temp < x {\n\t\t\tstart = i\n\t\t}\n\t\tif temp > x {\n\t\t\tend = i\n\t\t}\n\t}\n\treturn i\n}\n{% endcodeblock %}\n\n### Find First and Last Position of Element in Sorted Array\n\n#### 问题描述\n\n\t给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置。\n\n#### 解题思路\n\n    因为数组是增序的，那么目标值肯定是连续的，只需要先找到任意一个目标值的位置，\n    然后向两边遍历就能找到其第一次和最后一次出现的位置。\n\n{% codeblock lang:go %}\nfunc searchRange(nums []int, target int) []int {\n\tresult := []int{-1, -1}\n\tsize := len(nums)\n\tif size == 0 {\n\t\treturn result\n\t}\n\tstart := 0\n\tend := size - 1\n\tmid := start + (end-start)/2\n\t// 使用二分查找查找目标值的任意一个位置\n\tfor start < end && nums[mid] != target {\n\t\tif nums[mid] > target {\n\t\t\tend = mid - 1\n\t\t} else {\n\t\t\tstart = mid + 1\n\t\t}\n\t\tmid = start + (end-start)/2\n\t}\n\tif nums[mid] != target {\n\t\treturn result\n\t}\n\t// 向两侧遍历找出第一次和最后一次出现的位置\n\tmin, max := mid-1, mid+1\n\tfor min >= start && nums[min] == target {\n\t\tmin--\n\t}\n\tfor max <= end && nums[max] == target {\n\t\tmax++\n\t}\n\tresult = []int{min + 1, max - 1}\n\treturn result\n}\n\n{% endcodeblock %}\n\n### Search in Rotated Sorted Array II\n\n#### 问题描述\n\n      一个原本增序的数组被首尾相连后按某个位置断开（如 [1,2,2,3,4,5] → [2,3,4,5,1,2]，在第\n    一位和第二位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。\n\n#### 解题思路\n\n    虽然数组不是整体有序，但是以断开点为准分为左右两个子集，都是各自增序的。只要在二分查找中判断\n    当前所在是左子集还是右子集就行。\n\n{% codeblock lang:go %}\nfunc search(nums []int, target int) bool {\n\tstart := 0\n\tend := len(nums) - 1\n\tmid := start + (end - start)/2\n\tfor ;start < end; mid = start + (end - start)/2{\n\t\tif target == nums[mid]{\n\t\t\treturn true\n\t\t}\n\t\tif nums[mid] == nums[start]{\n\t\t\t// 无法判断哪个子集，头指针向右移\n\t\t\tstart++\n\t\t}else{\n\t\t\tif nums[mid] > nums[start]{\n\t\t\t    // 中间节点在左子集\n\t\t\t\tif target == nums[start]{\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tif target < nums[mid] && target > nums[start]{\n\t\t\t\t    // 判断目标在左子集范围\n\t\t\t\t\tend = mid-1\n\t\t\t\t}else {\n\t\t\t\t    // 无法判断 头指针右移\n\t\t\t\t\tstart = mid+1\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t    // 中间节点右子集\n\t\t\t\tif target == nums[end]{\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tif target > nums[mid] && target < nums[end]{\n\t\t\t\t\t// 判断目标在右子集范围\n\t\t\t\t\tstart = mid+1\n\t\t\t\t}else {\n\t\t\t\t    // 无法判断 头指针右移\n\t\t\t\t\tend = mid-1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif target == nums[mid]{\n\t\treturn true\n\t}\n\treturn false\n}\n{% endcodeblock %}\n\n\n### 总结\n   \n    二分查找很好理解，十分依赖集合有序这个点。但并不一定是整体有序，就如旋转数组一样。\n    所以在使用二分查找时，需要找出目标集合的有序性，依据其有序性做为二分查找的依据。","slug":"binarySearch-algorithms","published":1,"updated":"2021-04-25T14:27:11.616Z","_id":"cknsy278g0000cwb50q7j4867","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><pre><code>二分查找，也可以称作折半查找。\n即在一个有序序列中，通过每次对中间位置元素的判断来逐步缩小查找范围。</code></pre><a id=\"more\"></a>\n\n<h3 id=\"Sqrt-x\"><a href=\"#Sqrt-x\" class=\"headerlink\" title=\"Sqrt(x)\"></a>Sqrt(x)</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定一个非负整数，求它的开方，向下取整。</code></pre><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>这个问题比较简单，一个非负整数的开发必然是小于等于他本身的。\n所以我们可以将[0,x]看做一个有序序列，用二分查找的思想确定结果</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mySqrt</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstart := <span class=\"number\">0</span></span><br><span class=\"line\">\tend := x</span><br><span class=\"line\">\ti := start + (end-start)/<span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; i != start; i = start + (end-start)/<span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\ttemp := i * i</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> temp == x &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> temp &lt; x &#123;</span><br><span class=\"line\">\t\t\tstart = i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> temp &gt; x &#123;</span><br><span class=\"line\">\t\t\tend = i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"#Find-First-and-Last-Position-of-Element-in-Sorted-Array\" class=\"headerlink\" title=\"Find First and Last Position of Element in Sorted Array\"></a>Find First and Last Position of Element in Sorted Array</h3><h4 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置。</code></pre><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>因为数组是增序的，那么目标值肯定是连续的，只需要先找到任意一个目标值的位置，\n然后向两边遍历就能找到其第一次和最后一次出现的位置。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchRange</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tresult := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstart := <span class=\"number\">0</span></span><br><span class=\"line\">\tend := size - <span class=\"number\">1</span></span><br><span class=\"line\">\tmid := start + (end-start)/<span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"comment\">// 使用二分查找查找目标值的任意一个位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> start &lt; end &amp;&amp; nums[mid] != target &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt; target &#123;</span><br><span class=\"line\">\t\t\tend = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tstart = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmid = start + (end-start)/<span class=\"number\">2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> nums[mid] != target &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 向两侧遍历找出第一次和最后一次出现的位置</span></span><br><span class=\"line\">\tmin, max := mid<span class=\"number\">-1</span>, mid+<span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> min &gt;= start &amp;&amp; nums[min] == target &#123;</span><br><span class=\"line\">\t\tmin--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> max &lt;= end &amp;&amp; nums[max] == target &#123;</span><br><span class=\"line\">\t\tmax++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tresult = []<span class=\"keyword\">int</span>&#123;min + <span class=\"number\">1</span>, max - <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Search-in-Rotated-Sorted-Array-II\"><a href=\"#Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"Search in Rotated Sorted Array II\"></a>Search in Rotated Sorted Array II</h3><h4 id=\"问题描述-2\"><a href=\"#问题描述-2\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>  一个原本增序的数组被首尾相连后按某个位置断开（如 [1,2,2,3,4,5] → [2,3,4,5,1,2]，在第\n一位和第二位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。</code></pre><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>虽然数组不是整体有序，但是以断开点为准分为左右两个子集，都是各自增序的。只要在二分查找中判断\n当前所在是左子集还是右子集就行。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\tstart := <span class=\"number\">0</span></span><br><span class=\"line\">\tend := <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\tmid := start + (end - start)/<span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ;start &lt; end; mid = start + (end - start)/<span class=\"number\">2</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> target == nums[mid]&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] == nums[start]&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 无法判断哪个子集，头指针向右移</span></span><br><span class=\"line\">\t\t\tstart++</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> nums[mid] &gt; nums[start]&#123;</span><br><span class=\"line\">\t\t\t    <span class=\"comment\">// 中间节点在左子集</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> target == nums[start]&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> target &lt; nums[mid] &amp;&amp; target &gt; nums[start]&#123;</span><br><span class=\"line\">\t\t\t\t    <span class=\"comment\">// 判断目标在左子集范围</span></span><br><span class=\"line\">\t\t\t\t\tend = mid<span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t    <span class=\"comment\">// 无法判断 头指针右移</span></span><br><span class=\"line\">\t\t\t\t\tstart = mid+<span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t    <span class=\"comment\">// 中间节点右子集</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> target == nums[end]&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> target &gt; nums[mid] &amp;&amp; target &lt; nums[end]&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 判断目标在右子集范围</span></span><br><span class=\"line\">\t\t\t\t\tstart = mid+<span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t    <span class=\"comment\">// 无法判断 头指针右移</span></span><br><span class=\"line\">\t\t\t\t\tend = mid<span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> target == nums[mid]&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>二分查找很好理解，十分依赖集合有序这个点。但并不一定是整体有序，就如旋转数组一样。\n所以在使用二分查找时，需要找出目标集合的有序性，依据其有序性做为二分查找的依据。</code></pre>","site":{"data":{}},"length":527,"excerpt":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><pre><code>二分查找，也可以称作折半查找。\n即在一个有序序列中，通过每次对中间位置元素的判断来逐步缩小查找范围。</code></pre>","more":"<h3 id=\"Sqrt-x\"><a href=\"#Sqrt-x\" class=\"headerlink\" title=\"Sqrt(x)\"></a>Sqrt(x)</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定一个非负整数，求它的开方，向下取整。</code></pre><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>这个问题比较简单，一个非负整数的开发必然是小于等于他本身的。\n所以我们可以将[0,x]看做一个有序序列，用二分查找的思想确定结果</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mySqrt</span><span class=\"params\">(x <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x &lt;= <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> x</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstart := <span class=\"number\">0</span></span><br><span class=\"line\">\tend := x</span><br><span class=\"line\">\ti := start + (end-start)/<span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; i != start; i = start + (end-start)/<span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\ttemp := i * i</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> temp == x &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> temp &lt; x &#123;</span><br><span class=\"line\">\t\t\tstart = i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> temp &gt; x &#123;</span><br><span class=\"line\">\t\t\tend = i</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> i</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Find-First-and-Last-Position-of-Element-in-Sorted-Array\"><a href=\"#Find-First-and-Last-Position-of-Element-in-Sorted-Array\" class=\"headerlink\" title=\"Find First and Last Position of Element in Sorted Array\"></a>Find First and Last Position of Element in Sorted Array</h3><h4 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置。</code></pre><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>因为数组是增序的，那么目标值肯定是连续的，只需要先找到任意一个目标值的位置，\n然后向两边遍历就能找到其第一次和最后一次出现的位置。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchRange</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tresult := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(nums)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstart := <span class=\"number\">0</span></span><br><span class=\"line\">\tend := size - <span class=\"number\">1</span></span><br><span class=\"line\">\tmid := start + (end-start)/<span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"comment\">// 使用二分查找查找目标值的任意一个位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> start &lt; end &amp;&amp; nums[mid] != target &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] &gt; target &#123;</span><br><span class=\"line\">\t\t\tend = mid - <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\tstart = mid + <span class=\"number\">1</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tmid = start + (end-start)/<span class=\"number\">2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> nums[mid] != target &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 向两侧遍历找出第一次和最后一次出现的位置</span></span><br><span class=\"line\">\tmin, max := mid<span class=\"number\">-1</span>, mid+<span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> min &gt;= start &amp;&amp; nums[min] == target &#123;</span><br><span class=\"line\">\t\tmin--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> max &lt;= end &amp;&amp; nums[max] == target &#123;</span><br><span class=\"line\">\t\tmax++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tresult = []<span class=\"keyword\">int</span>&#123;min + <span class=\"number\">1</span>, max - <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Search-in-Rotated-Sorted-Array-II\"><a href=\"#Search-in-Rotated-Sorted-Array-II\" class=\"headerlink\" title=\"Search in Rotated Sorted Array II\"></a>Search in Rotated Sorted Array II</h3><h4 id=\"问题描述-2\"><a href=\"#问题描述-2\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>  一个原本增序的数组被首尾相连后按某个位置断开（如 [1,2,2,3,4,5] → [2,3,4,5,1,2]，在第\n一位和第二位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。</code></pre><h4 id=\"解题思路-2\"><a href=\"#解题思路-2\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>虽然数组不是整体有序，但是以断开点为准分为左右两个子集，都是各自增序的。只要在二分查找中判断\n当前所在是左子集还是右子集就行。</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">search</span><span class=\"params\">(nums []<span class=\"keyword\">int</span>, target <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\tstart := <span class=\"number\">0</span></span><br><span class=\"line\">\tend := <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">\tmid := start + (end - start)/<span class=\"number\">2</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ;start &lt; end; mid = start + (end - start)/<span class=\"number\">2</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> target == nums[mid]&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[mid] == nums[start]&#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 无法判断哪个子集，头指针向右移</span></span><br><span class=\"line\">\t\t\tstart++</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> nums[mid] &gt; nums[start]&#123;</span><br><span class=\"line\">\t\t\t    <span class=\"comment\">// 中间节点在左子集</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> target == nums[start]&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> target &lt; nums[mid] &amp;&amp; target &gt; nums[start]&#123;</span><br><span class=\"line\">\t\t\t\t    <span class=\"comment\">// 判断目标在左子集范围</span></span><br><span class=\"line\">\t\t\t\t\tend = mid<span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t    <span class=\"comment\">// 无法判断 头指针右移</span></span><br><span class=\"line\">\t\t\t\t\tstart = mid+<span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t    <span class=\"comment\">// 中间节点右子集</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> target == nums[end]&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> target &gt; nums[mid] &amp;&amp; target &lt; nums[end]&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 判断目标在右子集范围</span></span><br><span class=\"line\">\t\t\t\t\tstart = mid+<span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t    <span class=\"comment\">// 无法判断 头指针右移</span></span><br><span class=\"line\">\t\t\t\t\tend = mid<span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> target == nums[mid]&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>二分查找很好理解，十分依赖集合有序这个点。但并不一定是整体有序，就如旋转数组一样。\n所以在使用二分查找时，需要找出目标集合的有序性，依据其有序性做为二分查找的依据。</code></pre>"},{"title":"算法笔记-深度优先搜索","date":"2021-04-27T12:54:21.000Z","_content":"\n### 思路\n  \n    深度优先搜索是一种遍历思路，因为总是优先遍历新节点，所以其遍历路径看起来是向着深处进行。\n    例如：在遍历一个树的所有节点时，先遍历完根节点某个子节点下所有节点，以这种方式依次遍历各个\n    子节点。\n<!-- more -->\n\n### Max Area of Island\n\n#### 问题描述\n\n\t  给定一个二维的 0-1 矩阵，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛\n\t屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。\n\n#### 解题思路\n\n\t1.从任意节点开始，使用深度优先搜索进行遍历，直到没有陆地节点\n\t2.因为是个矩阵结构，要判断是否相邻，则需要遍历该节点上下左右四个节点\n\t3.会存在节点被重复遍历到的情况，只需将值置为0，表示该节点被统计过\n\n{% codeblock lang:go %}\nimport \"container/list\"\n\nfunc maxAreaOfIsland(grid [][]int) int {\n\tsize := len(grid)\n\tif size == 0 {\n\t\treturn 0\n\t}\n\teSize := len(grid[0])\n\t// 定义栈\n\tstack := list.New()\n\tresult := 0\n\tchange := []int{-1, 0, 1, 0, -1}\n\t// 遍历矩阵的每个节点\n\tfor x := 0; x < size; x++ {\n\t\tfor y := 0; y < eSize; y++ {\n\t\t\t// 若节点为陆地，则从该节点开始使用深度优先搜索\n\t\t\tif grid[x][y] == 1 {\n\t\t\t\t// 入栈\n\t\t\t\tstack.PushBack([2]int{x, y})\n\t\t\t\tgrid[x][y] = 0\n\t\t\t\tcurrentCount := 1\n\t\t\t\t// 遍历栈\n\t\t\t\tfor stack.Len() > 0 {\n\t\t\t\t\t// 出栈\n\t\t\t\t\tcurrent := stack.Front()\n\t\t\t\t\tstack.Remove(current)\n\t\t\t\t\t// 需要使用断言转换类型\n\t\t\t\t\tvalue, _ := current.Value.([2]int)\n\t\t\t\t\t// 弹出元素的数组下标\n\t\t\t\t\tv1 := value[0]\n\t\t\t\t\tv2 := value[1]\n\t\t\t\t\t// 遍历上下左右四个节点，并将最新节点压入栈中\n\t\t\t\t\tfor e := 0; e < 4; e++ {\n\t\t\t\t\t\tev1 := v1 + change[e]\n\t\t\t\t\t\tev2 := v2 + change[e+1]\n\t\t\t\t\t\tif ev1 >= 0 && ev1 < size && ev2 >= 0 && ev2 < eSize {\n\t\t\t\t\t\t\tif grid[ev1][ev2] == 1 {\n\t\t\t\t\t\t\t\tstack.PushBack([2]int{ev1, ev2})\n\t\t\t\t\t\t\t\tgrid[ev1][ev2] = 0\n\t\t\t\t\t\t\t\tcurrentCount++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif currentCount > result {\n\t\t\t\t\tresult = currentCount\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n{% endcodeblock %}\n\n###  Friend Circles\n\n#### 问题描述\n\n      给定一个二维的 0-1 矩阵，如果第 (i, j) 位置是 1，则表示第 i 个人和第 j 个人是朋友。已知\n    朋友关系是可以传递的，即如果 a 是 b 的朋友，b 是 c 的朋友，那么 a 和 c 也是朋友，换言之这\n    三个人处于同一个朋友圈之内。求一共有多少个朋友圈。\n\n#### 解题思路\n\n    1.每个节点代表两个人，所以不用遍历到每个节点，而是遍历每个人。\n    2.为了防止重复计算，当[a,b]==1，即a，b为朋友时，需要将[a,b]，[b,a]，[b,b]都置为0\n\n{% codeblock lang:go %}\nfunc findCircleNum(isConnected [][]int) int {\n\tsize := len(isConnected)\n\tif size == 0 {\n\t\treturn 0\n\t}\n\t// 定义栈\n\tstack := list.New()\n\tresult := 0\n\tfor x := 0; x < size; x++ {\n\t\tif isConnected[x][x] == 1 {\n\t\t\tresult++\n\t\t\tisConnected[x][x] = 0\n\t\t\tstack.PushBack(x)\n\t\t\tfor stack.Len() > 0 {\n\t\t\t\telement := stack.Front()\n\t\t\t\tstack.Remove(element)\n\t\t\t\tvalue, _ := element.Value.(int)\n\t\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\t\tif isConnected[value][i] == 1 {\n\t\t\t\t\t\tstack.PushBack(i)\n\t\t\t\t\t\tisConnected[value][i] = 0\n\t\t\t\t\t\tisConnected[i][value] = 0\n\t\t\t\t\t\tisConnected[i][i] = 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n{% endcodeblock %}\n\n### 总结\n\n    深度优先遍历适用于树，图这种数据结构。他可以满足特定条件的目标搜索。\n    例如在最大陆地问题中，以某个节点开始用深度优先搜索与其相连的陆地，统计个数。\n    通常，深度优先搜索都是结合递归或者栈配合进行，为了防止重复遍历，会需要\n    记录或者修改节点的值。","source":"_posts/2021/04/dfs-algorithms.md","raw":"---\ntitle: 算法笔记-深度优先搜索\ndate: 2021-04-27 20:54:21\ntags:\n- 算法笔记\ncategories:\n- 算法\n- 算法笔记\n- 深度优先搜索\n---\n\n### 思路\n  \n    深度优先搜索是一种遍历思路，因为总是优先遍历新节点，所以其遍历路径看起来是向着深处进行。\n    例如：在遍历一个树的所有节点时，先遍历完根节点某个子节点下所有节点，以这种方式依次遍历各个\n    子节点。\n<!-- more -->\n\n### Max Area of Island\n\n#### 问题描述\n\n\t  给定一个二维的 0-1 矩阵，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛\n\t屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。\n\n#### 解题思路\n\n\t1.从任意节点开始，使用深度优先搜索进行遍历，直到没有陆地节点\n\t2.因为是个矩阵结构，要判断是否相邻，则需要遍历该节点上下左右四个节点\n\t3.会存在节点被重复遍历到的情况，只需将值置为0，表示该节点被统计过\n\n{% codeblock lang:go %}\nimport \"container/list\"\n\nfunc maxAreaOfIsland(grid [][]int) int {\n\tsize := len(grid)\n\tif size == 0 {\n\t\treturn 0\n\t}\n\teSize := len(grid[0])\n\t// 定义栈\n\tstack := list.New()\n\tresult := 0\n\tchange := []int{-1, 0, 1, 0, -1}\n\t// 遍历矩阵的每个节点\n\tfor x := 0; x < size; x++ {\n\t\tfor y := 0; y < eSize; y++ {\n\t\t\t// 若节点为陆地，则从该节点开始使用深度优先搜索\n\t\t\tif grid[x][y] == 1 {\n\t\t\t\t// 入栈\n\t\t\t\tstack.PushBack([2]int{x, y})\n\t\t\t\tgrid[x][y] = 0\n\t\t\t\tcurrentCount := 1\n\t\t\t\t// 遍历栈\n\t\t\t\tfor stack.Len() > 0 {\n\t\t\t\t\t// 出栈\n\t\t\t\t\tcurrent := stack.Front()\n\t\t\t\t\tstack.Remove(current)\n\t\t\t\t\t// 需要使用断言转换类型\n\t\t\t\t\tvalue, _ := current.Value.([2]int)\n\t\t\t\t\t// 弹出元素的数组下标\n\t\t\t\t\tv1 := value[0]\n\t\t\t\t\tv2 := value[1]\n\t\t\t\t\t// 遍历上下左右四个节点，并将最新节点压入栈中\n\t\t\t\t\tfor e := 0; e < 4; e++ {\n\t\t\t\t\t\tev1 := v1 + change[e]\n\t\t\t\t\t\tev2 := v2 + change[e+1]\n\t\t\t\t\t\tif ev1 >= 0 && ev1 < size && ev2 >= 0 && ev2 < eSize {\n\t\t\t\t\t\t\tif grid[ev1][ev2] == 1 {\n\t\t\t\t\t\t\t\tstack.PushBack([2]int{ev1, ev2})\n\t\t\t\t\t\t\t\tgrid[ev1][ev2] = 0\n\t\t\t\t\t\t\t\tcurrentCount++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif currentCount > result {\n\t\t\t\t\tresult = currentCount\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n{% endcodeblock %}\n\n###  Friend Circles\n\n#### 问题描述\n\n      给定一个二维的 0-1 矩阵，如果第 (i, j) 位置是 1，则表示第 i 个人和第 j 个人是朋友。已知\n    朋友关系是可以传递的，即如果 a 是 b 的朋友，b 是 c 的朋友，那么 a 和 c 也是朋友，换言之这\n    三个人处于同一个朋友圈之内。求一共有多少个朋友圈。\n\n#### 解题思路\n\n    1.每个节点代表两个人，所以不用遍历到每个节点，而是遍历每个人。\n    2.为了防止重复计算，当[a,b]==1，即a，b为朋友时，需要将[a,b]，[b,a]，[b,b]都置为0\n\n{% codeblock lang:go %}\nfunc findCircleNum(isConnected [][]int) int {\n\tsize := len(isConnected)\n\tif size == 0 {\n\t\treturn 0\n\t}\n\t// 定义栈\n\tstack := list.New()\n\tresult := 0\n\tfor x := 0; x < size; x++ {\n\t\tif isConnected[x][x] == 1 {\n\t\t\tresult++\n\t\t\tisConnected[x][x] = 0\n\t\t\tstack.PushBack(x)\n\t\t\tfor stack.Len() > 0 {\n\t\t\t\telement := stack.Front()\n\t\t\t\tstack.Remove(element)\n\t\t\t\tvalue, _ := element.Value.(int)\n\t\t\t\tfor i := 0; i < size; i++ {\n\t\t\t\t\tif isConnected[value][i] == 1 {\n\t\t\t\t\t\tstack.PushBack(i)\n\t\t\t\t\t\tisConnected[value][i] = 0\n\t\t\t\t\t\tisConnected[i][value] = 0\n\t\t\t\t\t\tisConnected[i][i] = 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n{% endcodeblock %}\n\n### 总结\n\n    深度优先遍历适用于树，图这种数据结构。他可以满足特定条件的目标搜索。\n    例如在最大陆地问题中，以某个节点开始用深度优先搜索与其相连的陆地，统计个数。\n    通常，深度优先搜索都是结合递归或者栈配合进行，为了防止重复遍历，会需要\n    记录或者修改节点的值。","slug":"dfs-algorithms","published":1,"updated":"2021-04-28T14:00:25.435Z","_id":"cko04d9qp00004gb54yhq664y","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><pre><code>深度优先搜索是一种遍历思路，因为总是优先遍历新节点，所以其遍历路径看起来是向着深处进行。\n例如：在遍历一个树的所有节点时，先遍历完根节点某个子节点下所有节点，以这种方式依次遍历各个\n子节点。</code></pre><a id=\"more\"></a>\n\n<h3 id=\"Max-Area-of-Island\"><a href=\"#Max-Area-of-Island\" class=\"headerlink\" title=\"Max Area of Island\"></a>Max Area of Island</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>  给定一个二维的 0-1 矩阵，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛\n屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。</code></pre><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>1.从任意节点开始，使用深度优先搜索进行遍历，直到没有陆地节点\n2.因为是个矩阵结构，要判断是否相邻，则需要遍历该节点上下左右四个节点\n3.会存在节点被重复遍历到的情况，只需将值置为0，表示该节点被统计过</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"container/list\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(grid [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(grid)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\teSize := <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">\t<span class=\"comment\">// 定义栈</span></span><br><span class=\"line\">\tstack := list.New()</span><br><span class=\"line\">\tresult := <span class=\"number\">0</span></span><br><span class=\"line\">\tchange := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 遍历矩阵的每个节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> x := <span class=\"number\">0</span>; x &lt; size; x++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> y := <span class=\"number\">0</span>; y &lt; eSize; y++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 若节点为陆地，则从该节点开始使用深度优先搜索</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> grid[x][y] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 入栈</span></span><br><span class=\"line\">\t\t\t\tstack.PushBack([<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;x, y&#125;)</span><br><span class=\"line\">\t\t\t\tgrid[x][y] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\tcurrentCount := <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 遍历栈</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> stack.Len() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 出栈</span></span><br><span class=\"line\">\t\t\t\t\tcurrent := stack.Front()</span><br><span class=\"line\">\t\t\t\t\tstack.Remove(current)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 需要使用断言转换类型</span></span><br><span class=\"line\">\t\t\t\t\tvalue, _ := current.Value.([<span class=\"number\">2</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 弹出元素的数组下标</span></span><br><span class=\"line\">\t\t\t\t\tv1 := value[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t\t\tv2 := value[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 遍历上下左右四个节点，并将最新节点压入栈中</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> e := <span class=\"number\">0</span>; e &lt; <span class=\"number\">4</span>; e++ &#123;</span><br><span class=\"line\">\t\t\t\t\t\tev1 := v1 + change[e]</span><br><span class=\"line\">\t\t\t\t\t\tev2 := v2 + change[e+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ev1 &gt;= <span class=\"number\">0</span> &amp;&amp; ev1 &lt; size &amp;&amp; ev2 &gt;= <span class=\"number\">0</span> &amp;&amp; ev2 &lt; eSize &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span> grid[ev1][ev2] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tstack.PushBack([<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;ev1, ev2&#125;)</span><br><span class=\"line\">\t\t\t\t\t\t\t\tgrid[ev1][ev2] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\tcurrentCount++</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> currentCount &gt; result &#123;</span><br><span class=\"line\">\t\t\t\t\tresult = currentCount</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Friend-Circles\"><a href=\"#Friend-Circles\" class=\"headerlink\" title=\"Friend Circles\"></a>Friend Circles</h3><h4 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>  给定一个二维的 0-1 矩阵，如果第 (i, j) 位置是 1，则表示第 i 个人和第 j 个人是朋友。已知\n朋友关系是可以传递的，即如果 a 是 b 的朋友，b 是 c 的朋友，那么 a 和 c 也是朋友，换言之这\n三个人处于同一个朋友圈之内。求一共有多少个朋友圈。</code></pre><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>1.每个节点代表两个人，所以不用遍历到每个节点，而是遍历每个人。\n2.为了防止重复计算，当[a,b]==1，即a，b为朋友时，需要将[a,b]，[b,a]，[b,b]都置为0</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(isConnected [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(isConnected)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义栈</span></span><br><span class=\"line\">\tstack := list.New()</span><br><span class=\"line\">\tresult := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> x := <span class=\"number\">0</span>; x &lt; size; x++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> isConnected[x][x] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\tresult++</span><br><span class=\"line\">\t\t\tisConnected[x][x] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\tstack.PushBack(x)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> stack.Len() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\telement := stack.Front()</span><br><span class=\"line\">\t\t\t\tstack.Remove(element)</span><br><span class=\"line\">\t\t\t\tvalue, _ := element.Value.(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; size; i++ &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> isConnected[value][i] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\tstack.PushBack(i)</span><br><span class=\"line\">\t\t\t\t\t\tisConnected[value][i] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t\t\tisConnected[i][value] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t\t\tisConnected[i][i] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>深度优先遍历适用于树，图这种数据结构。他可以满足特定条件的目标搜索。\n例如在最大陆地问题中，以某个节点开始用深度优先搜索与其相连的陆地，统计个数。\n通常，深度优先搜索都是结合递归或者栈配合进行，为了防止重复遍历，会需要\n记录或者修改节点的值。</code></pre>","site":{"data":{}},"length":626,"excerpt":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><pre><code>深度优先搜索是一种遍历思路，因为总是优先遍历新节点，所以其遍历路径看起来是向着深处进行。\n例如：在遍历一个树的所有节点时，先遍历完根节点某个子节点下所有节点，以这种方式依次遍历各个\n子节点。</code></pre>","more":"<h3 id=\"Max-Area-of-Island\"><a href=\"#Max-Area-of-Island\" class=\"headerlink\" title=\"Max Area of Island\"></a>Max Area of Island</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>  给定一个二维的 0-1 矩阵，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛\n屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。</code></pre><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>1.从任意节点开始，使用深度优先搜索进行遍历，直到没有陆地节点\n2.因为是个矩阵结构，要判断是否相邻，则需要遍历该节点上下左右四个节点\n3.会存在节点被重复遍历到的情况，只需将值置为0，表示该节点被统计过</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"container/list\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(grid [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(grid)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\teSize := <span class=\"built_in\">len</span>(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">\t<span class=\"comment\">// 定义栈</span></span><br><span class=\"line\">\tstack := list.New()</span><br><span class=\"line\">\tresult := <span class=\"number\">0</span></span><br><span class=\"line\">\tchange := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 遍历矩阵的每个节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> x := <span class=\"number\">0</span>; x &lt; size; x++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> y := <span class=\"number\">0</span>; y &lt; eSize; y++ &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 若节点为陆地，则从该节点开始使用深度优先搜索</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> grid[x][y] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 入栈</span></span><br><span class=\"line\">\t\t\t\tstack.PushBack([<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;x, y&#125;)</span><br><span class=\"line\">\t\t\t\tgrid[x][y] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\tcurrentCount := <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 遍历栈</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> stack.Len() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 出栈</span></span><br><span class=\"line\">\t\t\t\t\tcurrent := stack.Front()</span><br><span class=\"line\">\t\t\t\t\tstack.Remove(current)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 需要使用断言转换类型</span></span><br><span class=\"line\">\t\t\t\t\tvalue, _ := current.Value.([<span class=\"number\">2</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 弹出元素的数组下标</span></span><br><span class=\"line\">\t\t\t\t\tv1 := value[<span class=\"number\">0</span>]</span><br><span class=\"line\">\t\t\t\t\tv2 := value[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 遍历上下左右四个节点，并将最新节点压入栈中</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span> e := <span class=\"number\">0</span>; e &lt; <span class=\"number\">4</span>; e++ &#123;</span><br><span class=\"line\">\t\t\t\t\t\tev1 := v1 + change[e]</span><br><span class=\"line\">\t\t\t\t\t\tev2 := v2 + change[e+<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span> ev1 &gt;= <span class=\"number\">0</span> &amp;&amp; ev1 &lt; size &amp;&amp; ev2 &gt;= <span class=\"number\">0</span> &amp;&amp; ev2 &lt; eSize &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">if</span> grid[ev1][ev2] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\tstack.PushBack([<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;ev1, ev2&#125;)</span><br><span class=\"line\">\t\t\t\t\t\t\t\tgrid[ev1][ev2] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t\t\t\t\tcurrentCount++</span><br><span class=\"line\">\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> currentCount &gt; result &#123;</span><br><span class=\"line\">\t\t\t\t\tresult = currentCount</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Friend-Circles\"><a href=\"#Friend-Circles\" class=\"headerlink\" title=\"Friend Circles\"></a>Friend Circles</h3><h4 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><pre><code>  给定一个二维的 0-1 矩阵，如果第 (i, j) 位置是 1，则表示第 i 个人和第 j 个人是朋友。已知\n朋友关系是可以传递的，即如果 a 是 b 的朋友，b 是 c 的朋友，那么 a 和 c 也是朋友，换言之这\n三个人处于同一个朋友圈之内。求一共有多少个朋友圈。</code></pre><h4 id=\"解题思路-1\"><a href=\"#解题思路-1\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><pre><code>1.每个节点代表两个人，所以不用遍历到每个节点，而是遍历每个人。\n2.为了防止重复计算，当[a,b]==1，即a，b为朋友时，需要将[a,b]，[b,a]，[b,b]都置为0</code></pre><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findCircleNum</span><span class=\"params\">(isConnected [][]<span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\tsize := <span class=\"built_in\">len</span>(isConnected)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> size == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义栈</span></span><br><span class=\"line\">\tstack := list.New()</span><br><span class=\"line\">\tresult := <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> x := <span class=\"number\">0</span>; x &lt; size; x++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> isConnected[x][x] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\tresult++</span><br><span class=\"line\">\t\t\tisConnected[x][x] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\tstack.PushBack(x)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> stack.Len() &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">\t\t\t\telement := stack.Front()</span><br><span class=\"line\">\t\t\t\tstack.Remove(element)</span><br><span class=\"line\">\t\t\t\tvalue, _ := element.Value.(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; size; i++ &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> isConnected[value][i] == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t\tstack.PushBack(i)</span><br><span class=\"line\">\t\t\t\t\t\tisConnected[value][i] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t\t\tisConnected[i][value] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t\t\tisConnected[i][i] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>深度优先遍历适用于树，图这种数据结构。他可以满足特定条件的目标搜索。\n例如在最大陆地问题中，以某个节点开始用深度优先搜索与其相连的陆地，统计个数。\n通常，深度优先搜索都是结合递归或者栈配合进行，为了防止重复遍历，会需要\n记录或者修改节点的值。</code></pre>"},{"title":"reids-分布式锁","date":"2021-05-01T02:09:09.000Z","_content":"\n### 前言\n\n\t本章来谈谈如何使用redis实现分布式锁\n<!-- more -->\n\n### 常规方案\n\n#### 方案一\n    \n    最简单的方案就是利用redis的set NX命令去获取锁，用delete命令释放锁。\n    这种实现简单直接，但其有以下弊端：\n    1. setnx命令后需要执行expire设置锁的过期时间，否则，持有锁的线程down掉，锁永远无法释放\n       而这两个命令是非原子性的，无法保证一起成功\n    2. delete释放锁，在持有锁的线程还未结束，但是已超过锁的过期时间，这时第二个获取到锁的线程\n       正准备执行，第一个线程执行完毕执行delete，释放的就是第二个线程持有的锁\n    3. 无法实现重入\n\n#### 方案二\n\n    有问题自然就要解决，针对方案一的问题1和2，有以下解决方案：\n    1. 使用redis set命令的参数EX PX，可以同时设置过期时间，而spring的redisremplate也封装了\n       setIfAbsent(K key, V value, long timeout, TimeUnit unit) 方法实现该功能\n    2. 为了防止释放锁时误删不属于自己的锁，可以对缓存的value设置一个自定义值，在释放时进行\n       判断，如果属于自己才执行delete操作\n    3. 为保证释放锁操作的原子性，可以借用lua脚本提交释放锁的命令\n\n    相对方案一，方案二仍然存在几个问题\n    1. 在服务挂掉时，只能依赖锁超时来释放锁，在一些场景下并不友好\n    2. 若redis有多个节点，可能存在主节点挂掉，锁信息还未同步到从节点导致锁丢失的情况\n    3. 依然不能重入\n\n### Redlock算法\n\n    常规方案只适合于redis单点部署的情况，就如方案二中提到的，若redis存在多个节点就可能因为主节点挂掉\n    且锁信息未及时复制到从节点而导致锁失效。\n    所幸，redis提供了解决这种问题的方案，那就是Redlock算法\n\n#### 算法思路\n\n    总的看来，Redlock的思路是将锁存在N个主节点中，这样减小主节点挂掉对锁的影响。\n    而为了较为安全搞笑实现这一过程，他的具体思路如下：\n    1. 获取当前毫秒级的时间\n    2. 依次用相同的key和随机值去每个redis实例中获取锁\n       设置一个超时时间，某个实例获取锁的时间超过就放弃，去下个实例\n    3. 当超过一半(至少达到N/2+1个)的锁获取成功，且获取锁所花费的时间小于设置的锁有效时间，则视为\n       获取锁成功\n    4. 获取锁成功后，线程能够持有的时间=最初有效时长-获取锁消耗的时间\n    5. 若最终获取失败(获取的实例个数小于一半，或最终有效时间无意义)，则会解除所有实例的锁\n\n### redisson\n\n    redisson是基于redis实现的一个Java驻内存数据网格。\n    其根据redlock实现了分布式锁。\n\n#### RLock类\n\n{% codeblock lang:java %}\n// 分布式锁接口\npublic interface RLock extends Lock, RExpirable, RLockAsync {\n    // 获取锁的三个方式，leaseTime表示获取到锁后的有效时间\n    void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException;\n    boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException;\n    void lock(long leaseTime, TimeUnit unit);\n\n    void forceUnlock();\n\n    boolean isLocked();\n\n    boolean isHeldByCurrentThread();\n    // 重入次数的获取\n    int getHoldCount();\n\n}\n{% endcodeblock %}\n   \n#### RedissonLock类\n\n{% codeblock lang:java %}\n// 具体的实现类\npublic class RedissonLock extends RedissonExpirable implements RLock {\n\t\n}\n// 核心方法\n// 加锁逻辑 这里的threadId为当前线程id\n<T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {\n    internalLockLeaseTime = unit.toMillis(leaseTime);\n    // 通过lua提交redis命令保证原子性\n    // KEYS[1] 指 getName()的值也就是创建锁对象时设置的key\n    // ARGV[1] 指 internalLockLeaseTime 也就是锁的有效时间\n    // ARGV[2] 指 threadId 当前线程id\n    // 第一段lua命令是 如果key不存在就设置一个hash类型缓存，\n    //                hash中元素的key为当前线程id，value为1\n    // 第二段命令则是重入锁判断 用当前线程id去hash里判断是否存在\n    //                        若存在，则将value+1\n    // 最后返回此时锁的剩余有效时间\n    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,\n              \"if (redis.call('exists', KEYS[1]) == 0) then \" +\n                  \"redis.call('hset', KEYS[1], ARGV[2], 1); \" +\n                  \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                  \"return nil; \" +\n              \"end; \" +\n              \"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \" +\n                  \"redis.call('hincrby', KEYS[1], ARGV[2], 1); \" +\n                  \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                  \"return nil; \" +\n              \"end; \" +\n              \"return redis.call('pttl', KEYS[1]);\",\n                Collections.<Object>singletonList(getName()), internalLockLeaseTime, getLockName(threadId));\n}\n// 锁释放的逻辑\nprotected RFuture<Boolean> unlockInnerAsync(long threadId) {\n    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,\n    \t\t// 锁不存在，发布unlockMessage消息\n            \"if (redis.call('exists', KEYS[1]) == 0) then \" +\n                \"redis.call('publish', KEYS[2], ARGV[1]); \" +\n                \"return 1; \" +\n            \"end;\" +\n            // 锁存在，但hash获取不到对应key的值，表示锁被其他线程占用，直接返回\n            \"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then \" +\n                \"return nil;\" +\n            \"end; \" +\n            // 当前线程释放锁，锁重入-1\n            \"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); \" +\n            // 还未完全释放，重置有效时间\n            \"if (counter > 0) then \" +\n                \"redis.call('pexpire', KEYS[1], ARGV[2]); \" +\n                \"return 0; \" +\n            // 释放锁 并发布消息\n            \"else \" +\n                \"redis.call('del', KEYS[1]); \" +\n                \"redis.call('publish', KEYS[2], ARGV[1]); \" +\n                \"return 1; \"+\n            \"end; \" +\n            \"return nil;\",\n            Arrays.<Object>asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));\n}\n{% endcodeblock %}\n\n#### RedissonRedLock类\n\n{% codeblock lang:java %}\n// redlock的实现，将多个锁当作一个锁管理\npublic class RedissonRedLock extends RedissonMultiLock {\n    // 构造方法是传入多个RLock对象，表示多个redis节点获取锁\t\n    public RedissonRedLock(RLock... locks) {\n        super(locks);\n    }\n    // 允许获取失败的最大节点数\n    @Override\n    protected int failedLocksLimit() {\n        return locks.size() - minLocksAmount(locks);\n    }\n    // 获取锁成功要求的最小节点数\n    protected int minLocksAmount(final List<RLock> locks) {\n        return locks.size()/2 + 1;\n    }\n    @Override\n    public void unlock() {\n        unlockInner(locks);\n    }\n    @Override\n    protected boolean isLockFailed(Future<Boolean> future) {\n        return false;\n    }\n    @Override\n    protected boolean isAllLocksAcquired(AtomicReference<RLock> lockedLockHolder, AtomicReference<Throwable> failed, Queue<RLock> lockedLocks) {\n        return (lockedLockHolder.get() == null && failed.get() == null) || lockedLocks.size() >= minLocksAmount(locks);\n    }\n}\n{% endcodeblock %}\n\n#### RedissonMultiLock\n\n\n{% codeblock lang:java %}\n// 将多个锁作为一个锁管理\npublic class RedissonMultiLock implements Lock {\n    // 锁集合\n    final List<RLock> locks = new ArrayList<RLock>();\n    // 构造方法\n    public RedissonMultiLock(RLock... locks) {\n        if (locks.length == 0) {\n            throw new IllegalArgumentException(\"Lock objects are not defined\");\n        }\n        this.locks.addAll(Arrays.asList(locks));\n    }\n    // other code\n}\n// 获取锁逻辑\npublic boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {\n    long newLeaseTime = -1;\n    if (leaseTime != -1) {\n        // 将锁的有效时长设置为2倍的等待时长\n        // 真正传入的有效时长最后设置\n        newLeaseTime = waitTime * 2;\n    }\n    // 当前时间点\n    long time = System.currentTimeMillis();\n    long remainTime = -1;\n    if (waitTime != -1) {\n        remainTime = unit.toMillis(waitTime);\n    }\n    // 允许获取失败的最大节点数\n    int failedLocksLimit = failedLocksLimit();\n    // 成功获取到锁的集合\n    List<RLock> lockedLocks = new ArrayList<RLock>(locks.size());\n    // 遍历锁对象\n    for (ListIterator<RLock> iterator = locks.listIterator(); iterator.hasNext();) {\n        RLock lock = iterator.next();\n        boolean lockAcquired;\n        try {\n            if (waitTime == -1 && leaseTime == -1) {\n                // 无有效时间要求的锁获取\n                lockAcquired = lock.tryLock();\n            } else {\n                // 设置等待时间\n                long awaitTime = unit.convert(remainTime, TimeUnit.MILLISECONDS);\n                // 实际调用RedissonLock的tryLock方法\n                // 当获取锁后的时间点与初识时间点的差小于awaitTime 便视作获取锁失败\n                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, unit);\n            }\n        } catch (Exception e) {\n            lockAcquired = false;\n        }\n        if (lockAcquired) {\n            // 获取锁成功则加入集合\n            lockedLocks.add(lock);\n        } else {\n            // 获取锁失败\n            // 获取成功的节点已达到要求，不再尝试\n            if (locks.size() - lockedLocks.size() == failedLocksLimit()) {\n                break;\n            }\n            if (failedLocksLimit == 0) {\n                // 允许获取失败的节点为0，则此时整个获取锁的操作失败\n                unlockInner(lockedLocks);\n                if (waitTime == -1 && leaseTime == -1) {\n                    return false;\n                }\n                failedLocksLimit = failedLocksLimit();\n                lockedLocks.clear();\n                // reset iterator\n                while (iterator.hasPrevious()) {\n                    iterator.previous();\n                }\n            } else {\n                // 一个节点失败，允许的失败节点数减1\n                failedLocksLimit--;\n            }\n        }\n        if (remainTime != -1) {\n            // 计算剩余可等待时长\n            remainTime -= (System.currentTimeMillis() - time);\n            // 重置开始时间点\n            time = System.currentTimeMillis();\n            // 超出可等待时长\n            if (remainTime <= 0) {\n                unlockInner(lockedLocks);\n                return false;\n            }\n        }\n    }\n    // 要求的锁有效时间不为永久\n    if (leaseTime != -1) {\n        List<RFuture<Boolean>> futures = new ArrayList<RFuture<Boolean>>(lockedLocks.size());\n        // 遍历设置锁的有效时间\n        for (RLock rLock : lockedLocks) {\n            RFuture<Boolean> future = rLock.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);\n            futures.add(future);\n        }\n        for (RFuture<Boolean> rFuture : futures) {\n            rFuture.syncUninterruptibly();\n        }\n    }\n    return true;\n}\n{% endcodeblock %}\n\n### 总结\n    \n    可以看到，redisson不仅实现了常规方案的分布式锁，还根据redlock算法实现了进一步更有效安\n    全的分布式锁。所以想用redis实现分布式锁，其实直接用redisson就行了。\n    当然，redlock算法其实也有争议，主要是因为多个节点获取锁虽然能够避免单节点服务挂掉及主从\n    复制导致的锁信息丢失，但也有可能出现节点间锁信息不一致的问题。具体可以看看参考链接。\n\n### 参考\n\n> [Distributed locks with Redis](https://redis.io/topics/distlock)\n> [How to do distributed locking](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)\n> [Is Redlock safe?](http://antirez.com/news/101)\n> [Redlock：Redis分布式锁最牛逼的实现](https://www.jianshu.com/p/7e47a4503b87)\n\n\n","source":"_posts/2021/05/redis-distributed-lock.md","raw":"---\ntitle: reids-分布式锁\ndate: 2021-05-01 10:09:09\ntags:\n- 分布式锁\n- redis\ncategories:\n- redis\n---\n\n### 前言\n\n\t本章来谈谈如何使用redis实现分布式锁\n<!-- more -->\n\n### 常规方案\n\n#### 方案一\n    \n    最简单的方案就是利用redis的set NX命令去获取锁，用delete命令释放锁。\n    这种实现简单直接，但其有以下弊端：\n    1. setnx命令后需要执行expire设置锁的过期时间，否则，持有锁的线程down掉，锁永远无法释放\n       而这两个命令是非原子性的，无法保证一起成功\n    2. delete释放锁，在持有锁的线程还未结束，但是已超过锁的过期时间，这时第二个获取到锁的线程\n       正准备执行，第一个线程执行完毕执行delete，释放的就是第二个线程持有的锁\n    3. 无法实现重入\n\n#### 方案二\n\n    有问题自然就要解决，针对方案一的问题1和2，有以下解决方案：\n    1. 使用redis set命令的参数EX PX，可以同时设置过期时间，而spring的redisremplate也封装了\n       setIfAbsent(K key, V value, long timeout, TimeUnit unit) 方法实现该功能\n    2. 为了防止释放锁时误删不属于自己的锁，可以对缓存的value设置一个自定义值，在释放时进行\n       判断，如果属于自己才执行delete操作\n    3. 为保证释放锁操作的原子性，可以借用lua脚本提交释放锁的命令\n\n    相对方案一，方案二仍然存在几个问题\n    1. 在服务挂掉时，只能依赖锁超时来释放锁，在一些场景下并不友好\n    2. 若redis有多个节点，可能存在主节点挂掉，锁信息还未同步到从节点导致锁丢失的情况\n    3. 依然不能重入\n\n### Redlock算法\n\n    常规方案只适合于redis单点部署的情况，就如方案二中提到的，若redis存在多个节点就可能因为主节点挂掉\n    且锁信息未及时复制到从节点而导致锁失效。\n    所幸，redis提供了解决这种问题的方案，那就是Redlock算法\n\n#### 算法思路\n\n    总的看来，Redlock的思路是将锁存在N个主节点中，这样减小主节点挂掉对锁的影响。\n    而为了较为安全搞笑实现这一过程，他的具体思路如下：\n    1. 获取当前毫秒级的时间\n    2. 依次用相同的key和随机值去每个redis实例中获取锁\n       设置一个超时时间，某个实例获取锁的时间超过就放弃，去下个实例\n    3. 当超过一半(至少达到N/2+1个)的锁获取成功，且获取锁所花费的时间小于设置的锁有效时间，则视为\n       获取锁成功\n    4. 获取锁成功后，线程能够持有的时间=最初有效时长-获取锁消耗的时间\n    5. 若最终获取失败(获取的实例个数小于一半，或最终有效时间无意义)，则会解除所有实例的锁\n\n### redisson\n\n    redisson是基于redis实现的一个Java驻内存数据网格。\n    其根据redlock实现了分布式锁。\n\n#### RLock类\n\n{% codeblock lang:java %}\n// 分布式锁接口\npublic interface RLock extends Lock, RExpirable, RLockAsync {\n    // 获取锁的三个方式，leaseTime表示获取到锁后的有效时间\n    void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException;\n    boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException;\n    void lock(long leaseTime, TimeUnit unit);\n\n    void forceUnlock();\n\n    boolean isLocked();\n\n    boolean isHeldByCurrentThread();\n    // 重入次数的获取\n    int getHoldCount();\n\n}\n{% endcodeblock %}\n   \n#### RedissonLock类\n\n{% codeblock lang:java %}\n// 具体的实现类\npublic class RedissonLock extends RedissonExpirable implements RLock {\n\t\n}\n// 核心方法\n// 加锁逻辑 这里的threadId为当前线程id\n<T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {\n    internalLockLeaseTime = unit.toMillis(leaseTime);\n    // 通过lua提交redis命令保证原子性\n    // KEYS[1] 指 getName()的值也就是创建锁对象时设置的key\n    // ARGV[1] 指 internalLockLeaseTime 也就是锁的有效时间\n    // ARGV[2] 指 threadId 当前线程id\n    // 第一段lua命令是 如果key不存在就设置一个hash类型缓存，\n    //                hash中元素的key为当前线程id，value为1\n    // 第二段命令则是重入锁判断 用当前线程id去hash里判断是否存在\n    //                        若存在，则将value+1\n    // 最后返回此时锁的剩余有效时间\n    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,\n              \"if (redis.call('exists', KEYS[1]) == 0) then \" +\n                  \"redis.call('hset', KEYS[1], ARGV[2], 1); \" +\n                  \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                  \"return nil; \" +\n              \"end; \" +\n              \"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \" +\n                  \"redis.call('hincrby', KEYS[1], ARGV[2], 1); \" +\n                  \"redis.call('pexpire', KEYS[1], ARGV[1]); \" +\n                  \"return nil; \" +\n              \"end; \" +\n              \"return redis.call('pttl', KEYS[1]);\",\n                Collections.<Object>singletonList(getName()), internalLockLeaseTime, getLockName(threadId));\n}\n// 锁释放的逻辑\nprotected RFuture<Boolean> unlockInnerAsync(long threadId) {\n    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,\n    \t\t// 锁不存在，发布unlockMessage消息\n            \"if (redis.call('exists', KEYS[1]) == 0) then \" +\n                \"redis.call('publish', KEYS[2], ARGV[1]); \" +\n                \"return 1; \" +\n            \"end;\" +\n            // 锁存在，但hash获取不到对应key的值，表示锁被其他线程占用，直接返回\n            \"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then \" +\n                \"return nil;\" +\n            \"end; \" +\n            // 当前线程释放锁，锁重入-1\n            \"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); \" +\n            // 还未完全释放，重置有效时间\n            \"if (counter > 0) then \" +\n                \"redis.call('pexpire', KEYS[1], ARGV[2]); \" +\n                \"return 0; \" +\n            // 释放锁 并发布消息\n            \"else \" +\n                \"redis.call('del', KEYS[1]); \" +\n                \"redis.call('publish', KEYS[2], ARGV[1]); \" +\n                \"return 1; \"+\n            \"end; \" +\n            \"return nil;\",\n            Arrays.<Object>asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));\n}\n{% endcodeblock %}\n\n#### RedissonRedLock类\n\n{% codeblock lang:java %}\n// redlock的实现，将多个锁当作一个锁管理\npublic class RedissonRedLock extends RedissonMultiLock {\n    // 构造方法是传入多个RLock对象，表示多个redis节点获取锁\t\n    public RedissonRedLock(RLock... locks) {\n        super(locks);\n    }\n    // 允许获取失败的最大节点数\n    @Override\n    protected int failedLocksLimit() {\n        return locks.size() - minLocksAmount(locks);\n    }\n    // 获取锁成功要求的最小节点数\n    protected int minLocksAmount(final List<RLock> locks) {\n        return locks.size()/2 + 1;\n    }\n    @Override\n    public void unlock() {\n        unlockInner(locks);\n    }\n    @Override\n    protected boolean isLockFailed(Future<Boolean> future) {\n        return false;\n    }\n    @Override\n    protected boolean isAllLocksAcquired(AtomicReference<RLock> lockedLockHolder, AtomicReference<Throwable> failed, Queue<RLock> lockedLocks) {\n        return (lockedLockHolder.get() == null && failed.get() == null) || lockedLocks.size() >= minLocksAmount(locks);\n    }\n}\n{% endcodeblock %}\n\n#### RedissonMultiLock\n\n\n{% codeblock lang:java %}\n// 将多个锁作为一个锁管理\npublic class RedissonMultiLock implements Lock {\n    // 锁集合\n    final List<RLock> locks = new ArrayList<RLock>();\n    // 构造方法\n    public RedissonMultiLock(RLock... locks) {\n        if (locks.length == 0) {\n            throw new IllegalArgumentException(\"Lock objects are not defined\");\n        }\n        this.locks.addAll(Arrays.asList(locks));\n    }\n    // other code\n}\n// 获取锁逻辑\npublic boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {\n    long newLeaseTime = -1;\n    if (leaseTime != -1) {\n        // 将锁的有效时长设置为2倍的等待时长\n        // 真正传入的有效时长最后设置\n        newLeaseTime = waitTime * 2;\n    }\n    // 当前时间点\n    long time = System.currentTimeMillis();\n    long remainTime = -1;\n    if (waitTime != -1) {\n        remainTime = unit.toMillis(waitTime);\n    }\n    // 允许获取失败的最大节点数\n    int failedLocksLimit = failedLocksLimit();\n    // 成功获取到锁的集合\n    List<RLock> lockedLocks = new ArrayList<RLock>(locks.size());\n    // 遍历锁对象\n    for (ListIterator<RLock> iterator = locks.listIterator(); iterator.hasNext();) {\n        RLock lock = iterator.next();\n        boolean lockAcquired;\n        try {\n            if (waitTime == -1 && leaseTime == -1) {\n                // 无有效时间要求的锁获取\n                lockAcquired = lock.tryLock();\n            } else {\n                // 设置等待时间\n                long awaitTime = unit.convert(remainTime, TimeUnit.MILLISECONDS);\n                // 实际调用RedissonLock的tryLock方法\n                // 当获取锁后的时间点与初识时间点的差小于awaitTime 便视作获取锁失败\n                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, unit);\n            }\n        } catch (Exception e) {\n            lockAcquired = false;\n        }\n        if (lockAcquired) {\n            // 获取锁成功则加入集合\n            lockedLocks.add(lock);\n        } else {\n            // 获取锁失败\n            // 获取成功的节点已达到要求，不再尝试\n            if (locks.size() - lockedLocks.size() == failedLocksLimit()) {\n                break;\n            }\n            if (failedLocksLimit == 0) {\n                // 允许获取失败的节点为0，则此时整个获取锁的操作失败\n                unlockInner(lockedLocks);\n                if (waitTime == -1 && leaseTime == -1) {\n                    return false;\n                }\n                failedLocksLimit = failedLocksLimit();\n                lockedLocks.clear();\n                // reset iterator\n                while (iterator.hasPrevious()) {\n                    iterator.previous();\n                }\n            } else {\n                // 一个节点失败，允许的失败节点数减1\n                failedLocksLimit--;\n            }\n        }\n        if (remainTime != -1) {\n            // 计算剩余可等待时长\n            remainTime -= (System.currentTimeMillis() - time);\n            // 重置开始时间点\n            time = System.currentTimeMillis();\n            // 超出可等待时长\n            if (remainTime <= 0) {\n                unlockInner(lockedLocks);\n                return false;\n            }\n        }\n    }\n    // 要求的锁有效时间不为永久\n    if (leaseTime != -1) {\n        List<RFuture<Boolean>> futures = new ArrayList<RFuture<Boolean>>(lockedLocks.size());\n        // 遍历设置锁的有效时间\n        for (RLock rLock : lockedLocks) {\n            RFuture<Boolean> future = rLock.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);\n            futures.add(future);\n        }\n        for (RFuture<Boolean> rFuture : futures) {\n            rFuture.syncUninterruptibly();\n        }\n    }\n    return true;\n}\n{% endcodeblock %}\n\n### 总结\n    \n    可以看到，redisson不仅实现了常规方案的分布式锁，还根据redlock算法实现了进一步更有效安\n    全的分布式锁。所以想用redis实现分布式锁，其实直接用redisson就行了。\n    当然，redlock算法其实也有争议，主要是因为多个节点获取锁虽然能够避免单节点服务挂掉及主从\n    复制导致的锁信息丢失，但也有可能出现节点间锁信息不一致的问题。具体可以看看参考链接。\n\n### 参考\n\n> [Distributed locks with Redis](https://redis.io/topics/distlock)\n> [How to do distributed locking](https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)\n> [Is Redlock safe?](http://antirez.com/news/101)\n> [Redlock：Redis分布式锁最牛逼的实现](https://www.jianshu.com/p/7e47a4503b87)\n\n\n","slug":"redis-distributed-lock","published":1,"updated":"2021-05-03T02:32:16.223Z","_id":"cko54q05m0000nsb5dtq27jad","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><pre><code>本章来谈谈如何使用redis实现分布式锁</code></pre><a id=\"more\"></a>\n\n<h3 id=\"常规方案\"><a href=\"#常规方案\" class=\"headerlink\" title=\"常规方案\"></a>常规方案</h3><h4 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h4><pre><code>最简单的方案就是利用redis的set NX命令去获取锁，用delete命令释放锁。\n这种实现简单直接，但其有以下弊端：\n1. setnx命令后需要执行expire设置锁的过期时间，否则，持有锁的线程down掉，锁永远无法释放\n   而这两个命令是非原子性的，无法保证一起成功\n2. delete释放锁，在持有锁的线程还未结束，但是已超过锁的过期时间，这时第二个获取到锁的线程\n   正准备执行，第一个线程执行完毕执行delete，释放的就是第二个线程持有的锁\n3. 无法实现重入</code></pre><h4 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h4><pre><code>有问题自然就要解决，针对方案一的问题1和2，有以下解决方案：\n1. 使用redis set命令的参数EX PX，可以同时设置过期时间，而spring的redisremplate也封装了\n   setIfAbsent(K key, V value, long timeout, TimeUnit unit) 方法实现该功能\n2. 为了防止释放锁时误删不属于自己的锁，可以对缓存的value设置一个自定义值，在释放时进行\n   判断，如果属于自己才执行delete操作\n3. 为保证释放锁操作的原子性，可以借用lua脚本提交释放锁的命令\n\n相对方案一，方案二仍然存在几个问题\n1. 在服务挂掉时，只能依赖锁超时来释放锁，在一些场景下并不友好\n2. 若redis有多个节点，可能存在主节点挂掉，锁信息还未同步到从节点导致锁丢失的情况\n3. 依然不能重入</code></pre><h3 id=\"Redlock算法\"><a href=\"#Redlock算法\" class=\"headerlink\" title=\"Redlock算法\"></a>Redlock算法</h3><pre><code>常规方案只适合于redis单点部署的情况，就如方案二中提到的，若redis存在多个节点就可能因为主节点挂掉\n且锁信息未及时复制到从节点而导致锁失效。\n所幸，redis提供了解决这种问题的方案，那就是Redlock算法</code></pre><h4 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h4><pre><code>总的看来，Redlock的思路是将锁存在N个主节点中，这样减小主节点挂掉对锁的影响。\n而为了较为安全搞笑实现这一过程，他的具体思路如下：\n1. 获取当前毫秒级的时间\n2. 依次用相同的key和随机值去每个redis实例中获取锁\n   设置一个超时时间，某个实例获取锁的时间超过就放弃，去下个实例\n3. 当超过一半(至少达到N/2+1个)的锁获取成功，且获取锁所花费的时间小于设置的锁有效时间，则视为\n   获取锁成功\n4. 获取锁成功后，线程能够持有的时间=最初有效时长-获取锁消耗的时间\n5. 若最终获取失败(获取的实例个数小于一半，或最终有效时间无意义)，则会解除所有实例的锁</code></pre><h3 id=\"redisson\"><a href=\"#redisson\" class=\"headerlink\" title=\"redisson\"></a>redisson</h3><pre><code>redisson是基于redis实现的一个Java驻内存数据网格。\n其根据redlock实现了分布式锁。</code></pre><h4 id=\"RLock类\"><a href=\"#RLock类\" class=\"headerlink\" title=\"RLock类\"></a>RLock类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分布式锁接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RLock</span> <span class=\"keyword\">extends</span> <span class=\"title\">Lock</span>, <span class=\"title\">RExpirable</span>, <span class=\"title\">RLockAsync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取锁的三个方式，leaseTime表示获取到锁后的有效时间</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">(<span class=\"keyword\">long</span> leaseTime, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> waitTime, <span class=\"keyword\">long</span> leaseTime, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">(<span class=\"keyword\">long</span> leaseTime, TimeUnit unit)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forceUnlock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isHeldByCurrentThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 重入次数的获取</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getHoldCount</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RedissonLock类\"><a href=\"#RedissonLock类\" class=\"headerlink\" title=\"RedissonLock类\"></a>RedissonLock类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具体的实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedissonLock</span> <span class=\"keyword\">extends</span> <span class=\"title\">RedissonExpirable</span> <span class=\"keyword\">implements</span> <span class=\"title\">RLock</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 核心方法</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁逻辑 这里的threadId为当前线程id</span></span><br><span class=\"line\">&lt;T&gt; <span class=\"function\">RFuture&lt;T&gt; <span class=\"title\">tryLockInnerAsync</span><span class=\"params\">(<span class=\"keyword\">long</span> leaseTime, TimeUnit unit, <span class=\"keyword\">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class=\"line\">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class=\"line\">    <span class=\"comment\">// 通过lua提交redis命令保证原子性</span></span><br><span class=\"line\">    <span class=\"comment\">// KEYS[1] 指 getName()的值也就是创建锁对象时设置的key</span></span><br><span class=\"line\">    <span class=\"comment\">// ARGV[1] 指 internalLockLeaseTime 也就是锁的有效时间</span></span><br><span class=\"line\">    <span class=\"comment\">// ARGV[2] 指 threadId 当前线程id</span></span><br><span class=\"line\">    <span class=\"comment\">// 第一段lua命令是 如果key不存在就设置一个hash类型缓存，</span></span><br><span class=\"line\">    <span class=\"comment\">//                hash中元素的key为当前线程id，value为1</span></span><br><span class=\"line\">    <span class=\"comment\">// 第二段命令则是重入锁判断 用当前线程id去hash里判断是否存在</span></span><br><span class=\"line\">    <span class=\"comment\">//                        若存在，则将value+1</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后返回此时锁的剩余有效时间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class=\"line\">              <span class=\"string\">\"if (redis.call('exists', KEYS[1]) == 0) then \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"redis.call('hset', KEYS[1], ARGV[2], 1); \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"redis.call('pexpire', KEYS[1], ARGV[1]); \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"return nil; \"</span> +</span><br><span class=\"line\">              <span class=\"string\">\"end; \"</span> +</span><br><span class=\"line\">              <span class=\"string\">\"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"redis.call('hincrby', KEYS[1], ARGV[2], 1); \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"redis.call('pexpire', KEYS[1], ARGV[1]); \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"return nil; \"</span> +</span><br><span class=\"line\">              <span class=\"string\">\"end; \"</span> +</span><br><span class=\"line\">              <span class=\"string\">\"return redis.call('pttl', KEYS[1]);\"</span>,</span><br><span class=\"line\">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 锁释放的逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> RFuture&lt;Boolean&gt; <span class=\"title\">unlockInnerAsync</span><span class=\"params\">(<span class=\"keyword\">long</span> threadId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 锁不存在，发布unlockMessage消息</span></span><br><span class=\"line\">            <span class=\"string\">\"if (redis.call('exists', KEYS[1]) == 0) then \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"redis.call('publish', KEYS[2], ARGV[1]); \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"return 1; \"</span> +</span><br><span class=\"line\">            <span class=\"string\">\"end;\"</span> +</span><br><span class=\"line\">            <span class=\"comment\">// 锁存在，但hash获取不到对应key的值，表示锁被其他线程占用，直接返回</span></span><br><span class=\"line\">            <span class=\"string\">\"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"return nil;\"</span> +</span><br><span class=\"line\">            <span class=\"string\">\"end; \"</span> +</span><br><span class=\"line\">            <span class=\"comment\">// 当前线程释放锁，锁重入-1</span></span><br><span class=\"line\">            <span class=\"string\">\"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); \"</span> +</span><br><span class=\"line\">            <span class=\"comment\">// 还未完全释放，重置有效时间</span></span><br><span class=\"line\">            <span class=\"string\">\"if (counter &gt; 0) then \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"redis.call('pexpire', KEYS[1], ARGV[2]); \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"return 0; \"</span> +</span><br><span class=\"line\">            <span class=\"comment\">// 释放锁 并发布消息</span></span><br><span class=\"line\">            <span class=\"string\">\"else \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"redis.call('del', KEYS[1]); \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"redis.call('publish', KEYS[2], ARGV[1]); \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"return 1; \"</span>+</span><br><span class=\"line\">            <span class=\"string\">\"end; \"</span> +</span><br><span class=\"line\">            <span class=\"string\">\"return nil;\"</span>,</span><br><span class=\"line\">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RedissonRedLock类\"><a href=\"#RedissonRedLock类\" class=\"headerlink\" title=\"RedissonRedLock类\"></a>RedissonRedLock类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// redlock的实现，将多个锁当作一个锁管理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedissonRedLock</span> <span class=\"keyword\">extends</span> <span class=\"title\">RedissonMultiLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造方法是传入多个RLock对象，表示多个redis节点获取锁\t</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedissonRedLock</span><span class=\"params\">(RLock... locks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(locks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 允许获取失败的最大节点数</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">failedLocksLimit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> locks.size() - minLocksAmount(locks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取锁成功要求的最小节点数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">minLocksAmount</span><span class=\"params\">(<span class=\"keyword\">final</span> List&lt;RLock&gt; locks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> locks.size()/<span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        unlockInner(locks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLockFailed</span><span class=\"params\">(Future&lt;Boolean&gt; future)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAllLocksAcquired</span><span class=\"params\">(AtomicReference&lt;RLock&gt; lockedLockHolder, AtomicReference&lt;Throwable&gt; failed, Queue&lt;RLock&gt; lockedLocks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (lockedLockHolder.get() == <span class=\"keyword\">null</span> &amp;&amp; failed.get() == <span class=\"keyword\">null</span>) || lockedLocks.size() &gt;= minLocksAmount(locks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RedissonMultiLock\"><a href=\"#RedissonMultiLock\" class=\"headerlink\" title=\"RedissonMultiLock\"></a>RedissonMultiLock</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将多个锁作为一个锁管理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedissonMultiLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 锁集合</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;RLock&gt; locks = <span class=\"keyword\">new</span> ArrayList&lt;RLock&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedissonMultiLock</span><span class=\"params\">(RLock... locks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (locks.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Lock objects are not defined\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.locks.addAll(Arrays.asList(locks));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// other code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取锁逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> waitTime, <span class=\"keyword\">long</span> leaseTime, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> newLeaseTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leaseTime != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将锁的有效时长设置为2倍的等待时长</span></span><br><span class=\"line\">        <span class=\"comment\">// 真正传入的有效时长最后设置</span></span><br><span class=\"line\">        newLeaseTime = waitTime * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当前时间点</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> time = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> remainTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (waitTime != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        remainTime = unit.toMillis(waitTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 允许获取失败的最大节点数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> failedLocksLimit = failedLocksLimit();</span><br><span class=\"line\">    <span class=\"comment\">// 成功获取到锁的集合</span></span><br><span class=\"line\">    List&lt;RLock&gt; lockedLocks = <span class=\"keyword\">new</span> ArrayList&lt;RLock&gt;(locks.size());</span><br><span class=\"line\">    <span class=\"comment\">// 遍历锁对象</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><br><span class=\"line\">        RLock lock = iterator.next();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> lockAcquired;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime == -<span class=\"number\">1</span> &amp;&amp; leaseTime == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 无有效时间要求的锁获取</span></span><br><span class=\"line\">                lockAcquired = lock.tryLock();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置等待时间</span></span><br><span class=\"line\">                <span class=\"keyword\">long</span> awaitTime = unit.convert(remainTime, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">                <span class=\"comment\">// 实际调用RedissonLock的tryLock方法</span></span><br><span class=\"line\">                <span class=\"comment\">// 当获取锁后的时间点与初识时间点的差小于awaitTime 便视作获取锁失败</span></span><br><span class=\"line\">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, unit);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            lockAcquired = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lockAcquired) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取锁成功则加入集合</span></span><br><span class=\"line\">            lockedLocks.add(lock);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取锁失败</span></span><br><span class=\"line\">            <span class=\"comment\">// 获取成功的节点已达到要求，不再尝试</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (locks.size() - lockedLocks.size() == failedLocksLimit()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (failedLocksLimit == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 允许获取失败的节点为0，则此时整个获取锁的操作失败</span></span><br><span class=\"line\">                unlockInner(lockedLocks);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (waitTime == -<span class=\"number\">1</span> &amp;&amp; leaseTime == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                failedLocksLimit = failedLocksLimit();</span><br><span class=\"line\">                lockedLocks.clear();</span><br><span class=\"line\">                <span class=\"comment\">// reset iterator</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (iterator.hasPrevious()) &#123;</span><br><span class=\"line\">                    iterator.previous();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 一个节点失败，允许的失败节点数减1</span></span><br><span class=\"line\">                failedLocksLimit--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainTime != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算剩余可等待时长</span></span><br><span class=\"line\">            remainTime -= (System.currentTimeMillis() - time);</span><br><span class=\"line\">            <span class=\"comment\">// 重置开始时间点</span></span><br><span class=\"line\">            time = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"comment\">// 超出可等待时长</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remainTime &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                unlockInner(lockedLocks);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 要求的锁有效时间不为永久</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leaseTime != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class=\"keyword\">new</span> ArrayList&lt;RFuture&lt;Boolean&gt;&gt;(lockedLocks.size());</span><br><span class=\"line\">        <span class=\"comment\">// 遍历设置锁的有效时间</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (RLock rLock : lockedLocks) &#123;</span><br><span class=\"line\">            RFuture&lt;Boolean&gt; future = rLock.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">            futures.add(future);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span><br><span class=\"line\">            rFuture.syncUninterruptibly();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>可以看到，redisson不仅实现了常规方案的分布式锁，还根据redlock算法实现了进一步更有效安\n全的分布式锁。所以想用redis实现分布式锁，其实直接用redisson就行了。\n当然，redlock算法其实也有争议，主要是因为多个节点获取锁虽然能够避免单节点服务挂掉及主从\n复制导致的锁信息丢失，但也有可能出现节点间锁信息不一致的问题。具体可以看看参考链接。</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://redis.io/topics/distlock\" target=\"_blank\" rel=\"noopener\">Distributed locks with Redis</a><br><a href=\"https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html\" target=\"_blank\" rel=\"noopener\">How to do distributed locking</a><br><a href=\"http://antirez.com/news/101\" target=\"_blank\" rel=\"noopener\">Is Redlock safe?</a><br><a href=\"https://www.jianshu.com/p/7e47a4503b87\" target=\"_blank\" rel=\"noopener\">Redlock：Redis分布式锁最牛逼的实现</a></p>\n</blockquote>\n","site":{"data":{}},"length":1348,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><pre><code>本章来谈谈如何使用redis实现分布式锁</code></pre>","more":"<h3 id=\"常规方案\"><a href=\"#常规方案\" class=\"headerlink\" title=\"常规方案\"></a>常规方案</h3><h4 id=\"方案一\"><a href=\"#方案一\" class=\"headerlink\" title=\"方案一\"></a>方案一</h4><pre><code>最简单的方案就是利用redis的set NX命令去获取锁，用delete命令释放锁。\n这种实现简单直接，但其有以下弊端：\n1. setnx命令后需要执行expire设置锁的过期时间，否则，持有锁的线程down掉，锁永远无法释放\n   而这两个命令是非原子性的，无法保证一起成功\n2. delete释放锁，在持有锁的线程还未结束，但是已超过锁的过期时间，这时第二个获取到锁的线程\n   正准备执行，第一个线程执行完毕执行delete，释放的就是第二个线程持有的锁\n3. 无法实现重入</code></pre><h4 id=\"方案二\"><a href=\"#方案二\" class=\"headerlink\" title=\"方案二\"></a>方案二</h4><pre><code>有问题自然就要解决，针对方案一的问题1和2，有以下解决方案：\n1. 使用redis set命令的参数EX PX，可以同时设置过期时间，而spring的redisremplate也封装了\n   setIfAbsent(K key, V value, long timeout, TimeUnit unit) 方法实现该功能\n2. 为了防止释放锁时误删不属于自己的锁，可以对缓存的value设置一个自定义值，在释放时进行\n   判断，如果属于自己才执行delete操作\n3. 为保证释放锁操作的原子性，可以借用lua脚本提交释放锁的命令\n\n相对方案一，方案二仍然存在几个问题\n1. 在服务挂掉时，只能依赖锁超时来释放锁，在一些场景下并不友好\n2. 若redis有多个节点，可能存在主节点挂掉，锁信息还未同步到从节点导致锁丢失的情况\n3. 依然不能重入</code></pre><h3 id=\"Redlock算法\"><a href=\"#Redlock算法\" class=\"headerlink\" title=\"Redlock算法\"></a>Redlock算法</h3><pre><code>常规方案只适合于redis单点部署的情况，就如方案二中提到的，若redis存在多个节点就可能因为主节点挂掉\n且锁信息未及时复制到从节点而导致锁失效。\n所幸，redis提供了解决这种问题的方案，那就是Redlock算法</code></pre><h4 id=\"算法思路\"><a href=\"#算法思路\" class=\"headerlink\" title=\"算法思路\"></a>算法思路</h4><pre><code>总的看来，Redlock的思路是将锁存在N个主节点中，这样减小主节点挂掉对锁的影响。\n而为了较为安全搞笑实现这一过程，他的具体思路如下：\n1. 获取当前毫秒级的时间\n2. 依次用相同的key和随机值去每个redis实例中获取锁\n   设置一个超时时间，某个实例获取锁的时间超过就放弃，去下个实例\n3. 当超过一半(至少达到N/2+1个)的锁获取成功，且获取锁所花费的时间小于设置的锁有效时间，则视为\n   获取锁成功\n4. 获取锁成功后，线程能够持有的时间=最初有效时长-获取锁消耗的时间\n5. 若最终获取失败(获取的实例个数小于一半，或最终有效时间无意义)，则会解除所有实例的锁</code></pre><h3 id=\"redisson\"><a href=\"#redisson\" class=\"headerlink\" title=\"redisson\"></a>redisson</h3><pre><code>redisson是基于redis实现的一个Java驻内存数据网格。\n其根据redlock实现了分布式锁。</code></pre><h4 id=\"RLock类\"><a href=\"#RLock类\" class=\"headerlink\" title=\"RLock类\"></a>RLock类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分布式锁接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RLock</span> <span class=\"keyword\">extends</span> <span class=\"title\">Lock</span>, <span class=\"title\">RExpirable</span>, <span class=\"title\">RLockAsync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取锁的三个方式，leaseTime表示获取到锁后的有效时间</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">(<span class=\"keyword\">long</span> leaseTime, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> waitTime, <span class=\"keyword\">long</span> leaseTime, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">(<span class=\"keyword\">long</span> leaseTime, TimeUnit unit)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forceUnlock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isHeldByCurrentThread</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 重入次数的获取</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getHoldCount</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RedissonLock类\"><a href=\"#RedissonLock类\" class=\"headerlink\" title=\"RedissonLock类\"></a>RedissonLock类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 具体的实现类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedissonLock</span> <span class=\"keyword\">extends</span> <span class=\"title\">RedissonExpirable</span> <span class=\"keyword\">implements</span> <span class=\"title\">RLock</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 核心方法</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁逻辑 这里的threadId为当前线程id</span></span><br><span class=\"line\">&lt;T&gt; <span class=\"function\">RFuture&lt;T&gt; <span class=\"title\">tryLockInnerAsync</span><span class=\"params\">(<span class=\"keyword\">long</span> leaseTime, TimeUnit unit, <span class=\"keyword\">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class=\"line\">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class=\"line\">    <span class=\"comment\">// 通过lua提交redis命令保证原子性</span></span><br><span class=\"line\">    <span class=\"comment\">// KEYS[1] 指 getName()的值也就是创建锁对象时设置的key</span></span><br><span class=\"line\">    <span class=\"comment\">// ARGV[1] 指 internalLockLeaseTime 也就是锁的有效时间</span></span><br><span class=\"line\">    <span class=\"comment\">// ARGV[2] 指 threadId 当前线程id</span></span><br><span class=\"line\">    <span class=\"comment\">// 第一段lua命令是 如果key不存在就设置一个hash类型缓存，</span></span><br><span class=\"line\">    <span class=\"comment\">//                hash中元素的key为当前线程id，value为1</span></span><br><span class=\"line\">    <span class=\"comment\">// 第二段命令则是重入锁判断 用当前线程id去hash里判断是否存在</span></span><br><span class=\"line\">    <span class=\"comment\">//                        若存在，则将value+1</span></span><br><span class=\"line\">    <span class=\"comment\">// 最后返回此时锁的剩余有效时间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class=\"line\">              <span class=\"string\">\"if (redis.call('exists', KEYS[1]) == 0) then \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"redis.call('hset', KEYS[1], ARGV[2], 1); \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"redis.call('pexpire', KEYS[1], ARGV[1]); \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"return nil; \"</span> +</span><br><span class=\"line\">              <span class=\"string\">\"end; \"</span> +</span><br><span class=\"line\">              <span class=\"string\">\"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"redis.call('hincrby', KEYS[1], ARGV[2], 1); \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"redis.call('pexpire', KEYS[1], ARGV[1]); \"</span> +</span><br><span class=\"line\">                  <span class=\"string\">\"return nil; \"</span> +</span><br><span class=\"line\">              <span class=\"string\">\"end; \"</span> +</span><br><span class=\"line\">              <span class=\"string\">\"return redis.call('pttl', KEYS[1]);\"</span>,</span><br><span class=\"line\">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 锁释放的逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> RFuture&lt;Boolean&gt; <span class=\"title\">unlockInnerAsync</span><span class=\"params\">(<span class=\"keyword\">long</span> threadId)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class=\"line\">    \t\t<span class=\"comment\">// 锁不存在，发布unlockMessage消息</span></span><br><span class=\"line\">            <span class=\"string\">\"if (redis.call('exists', KEYS[1]) == 0) then \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"redis.call('publish', KEYS[2], ARGV[1]); \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"return 1; \"</span> +</span><br><span class=\"line\">            <span class=\"string\">\"end;\"</span> +</span><br><span class=\"line\">            <span class=\"comment\">// 锁存在，但hash获取不到对应key的值，表示锁被其他线程占用，直接返回</span></span><br><span class=\"line\">            <span class=\"string\">\"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"return nil;\"</span> +</span><br><span class=\"line\">            <span class=\"string\">\"end; \"</span> +</span><br><span class=\"line\">            <span class=\"comment\">// 当前线程释放锁，锁重入-1</span></span><br><span class=\"line\">            <span class=\"string\">\"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); \"</span> +</span><br><span class=\"line\">            <span class=\"comment\">// 还未完全释放，重置有效时间</span></span><br><span class=\"line\">            <span class=\"string\">\"if (counter &gt; 0) then \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"redis.call('pexpire', KEYS[1], ARGV[2]); \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"return 0; \"</span> +</span><br><span class=\"line\">            <span class=\"comment\">// 释放锁 并发布消息</span></span><br><span class=\"line\">            <span class=\"string\">\"else \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"redis.call('del', KEYS[1]); \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"redis.call('publish', KEYS[2], ARGV[1]); \"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"return 1; \"</span>+</span><br><span class=\"line\">            <span class=\"string\">\"end; \"</span> +</span><br><span class=\"line\">            <span class=\"string\">\"return nil;\"</span>,</span><br><span class=\"line\">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RedissonRedLock类\"><a href=\"#RedissonRedLock类\" class=\"headerlink\" title=\"RedissonRedLock类\"></a>RedissonRedLock类</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// redlock的实现，将多个锁当作一个锁管理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedissonRedLock</span> <span class=\"keyword\">extends</span> <span class=\"title\">RedissonMultiLock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构造方法是传入多个RLock对象，表示多个redis节点获取锁\t</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedissonRedLock</span><span class=\"params\">(RLock... locks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(locks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 允许获取失败的最大节点数</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">failedLocksLimit</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> locks.size() - minLocksAmount(locks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 获取锁成功要求的最小节点数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">minLocksAmount</span><span class=\"params\">(<span class=\"keyword\">final</span> List&lt;RLock&gt; locks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> locks.size()/<span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        unlockInner(locks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLockFailed</span><span class=\"params\">(Future&lt;Boolean&gt; future)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAllLocksAcquired</span><span class=\"params\">(AtomicReference&lt;RLock&gt; lockedLockHolder, AtomicReference&lt;Throwable&gt; failed, Queue&lt;RLock&gt; lockedLocks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (lockedLockHolder.get() == <span class=\"keyword\">null</span> &amp;&amp; failed.get() == <span class=\"keyword\">null</span>) || lockedLocks.size() &gt;= minLocksAmount(locks);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RedissonMultiLock\"><a href=\"#RedissonMultiLock\" class=\"headerlink\" title=\"RedissonMultiLock\"></a>RedissonMultiLock</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将多个锁作为一个锁管理</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedissonMultiLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 锁集合</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> List&lt;RLock&gt; locks = <span class=\"keyword\">new</span> ArrayList&lt;RLock&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedissonMultiLock</span><span class=\"params\">(RLock... locks)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (locks.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Lock objects are not defined\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.locks.addAll(Arrays.asList(locks));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// other code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取锁逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> waitTime, <span class=\"keyword\">long</span> leaseTime, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> newLeaseTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leaseTime != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将锁的有效时长设置为2倍的等待时长</span></span><br><span class=\"line\">        <span class=\"comment\">// 真正传入的有效时长最后设置</span></span><br><span class=\"line\">        newLeaseTime = waitTime * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当前时间点</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> time = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> remainTime = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (waitTime != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        remainTime = unit.toMillis(waitTime);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 允许获取失败的最大节点数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> failedLocksLimit = failedLocksLimit();</span><br><span class=\"line\">    <span class=\"comment\">// 成功获取到锁的集合</span></span><br><span class=\"line\">    List&lt;RLock&gt; lockedLocks = <span class=\"keyword\">new</span> ArrayList&lt;RLock&gt;(locks.size());</span><br><span class=\"line\">    <span class=\"comment\">// 遍历锁对象</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;</span><br><span class=\"line\">        RLock lock = iterator.next();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> lockAcquired;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime == -<span class=\"number\">1</span> &amp;&amp; leaseTime == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 无有效时间要求的锁获取</span></span><br><span class=\"line\">                lockAcquired = lock.tryLock();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 设置等待时间</span></span><br><span class=\"line\">                <span class=\"keyword\">long</span> awaitTime = unit.convert(remainTime, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">                <span class=\"comment\">// 实际调用RedissonLock的tryLock方法</span></span><br><span class=\"line\">                <span class=\"comment\">// 当获取锁后的时间点与初识时间点的差小于awaitTime 便视作获取锁失败</span></span><br><span class=\"line\">                lockAcquired = lock.tryLock(awaitTime, newLeaseTime, unit);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            lockAcquired = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lockAcquired) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取锁成功则加入集合</span></span><br><span class=\"line\">            lockedLocks.add(lock);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取锁失败</span></span><br><span class=\"line\">            <span class=\"comment\">// 获取成功的节点已达到要求，不再尝试</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (locks.size() - lockedLocks.size() == failedLocksLimit()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (failedLocksLimit == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 允许获取失败的节点为0，则此时整个获取锁的操作失败</span></span><br><span class=\"line\">                unlockInner(lockedLocks);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (waitTime == -<span class=\"number\">1</span> &amp;&amp; leaseTime == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                failedLocksLimit = failedLocksLimit();</span><br><span class=\"line\">                lockedLocks.clear();</span><br><span class=\"line\">                <span class=\"comment\">// reset iterator</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (iterator.hasPrevious()) &#123;</span><br><span class=\"line\">                    iterator.previous();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 一个节点失败，允许的失败节点数减1</span></span><br><span class=\"line\">                failedLocksLimit--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (remainTime != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 计算剩余可等待时长</span></span><br><span class=\"line\">            remainTime -= (System.currentTimeMillis() - time);</span><br><span class=\"line\">            <span class=\"comment\">// 重置开始时间点</span></span><br><span class=\"line\">            time = System.currentTimeMillis();</span><br><span class=\"line\">            <span class=\"comment\">// 超出可等待时长</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remainTime &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                unlockInner(lockedLocks);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 要求的锁有效时间不为永久</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leaseTime != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class=\"keyword\">new</span> ArrayList&lt;RFuture&lt;Boolean&gt;&gt;(lockedLocks.size());</span><br><span class=\"line\">        <span class=\"comment\">// 遍历设置锁的有效时间</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (RLock rLock : lockedLocks) &#123;</span><br><span class=\"line\">            RFuture&lt;Boolean&gt; future = rLock.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><br><span class=\"line\">            futures.add(future);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span><br><span class=\"line\">            rFuture.syncUninterruptibly();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>可以看到，redisson不仅实现了常规方案的分布式锁，还根据redlock算法实现了进一步更有效安\n全的分布式锁。所以想用redis实现分布式锁，其实直接用redisson就行了。\n当然，redlock算法其实也有争议，主要是因为多个节点获取锁虽然能够避免单节点服务挂掉及主从\n复制导致的锁信息丢失，但也有可能出现节点间锁信息不一致的问题。具体可以看看参考链接。</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://redis.io/topics/distlock\" target=\"_blank\" rel=\"noopener\">Distributed locks with Redis</a><br><a href=\"https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html\" target=\"_blank\" rel=\"noopener\">How to do distributed locking</a><br><a href=\"http://antirez.com/news/101\" target=\"_blank\" rel=\"noopener\">Is Redlock safe?</a><br><a href=\"https://www.jianshu.com/p/7e47a4503b87\" target=\"_blank\" rel=\"noopener\">Redlock：Redis分布式锁最牛逼的实现</a></p>\n</blockquote>"},{"title":"redis持久化总结","date":"2021-05-03T09:22:01.000Z","_content":"\n### 前言\n\n    本章对redis持久化相关内容进行一下总结。\n\n<!-- more -->\n\n### 持久化方案\n\n1. RDB：Redis DataBase redis数据库，会按指定的时间间隔将数据生成快照文件存储在硬盘等介质中\n2. AOF：Append Only File 仅附加文件，记录服务器接受的写指令，可以在服务器重启时执行这些命令用以恢复数据。\n3. 无持久化\n4. 混合持久化：仅4.0版本后支持\n\n### RDB\n\n#### 执行方式\n\n    redis会fork一个子进程按照时间间隔来进行持久化操作，主进程不受影响，所以可以保证redis本身\n    的性能。\n\n#### 优点\n\n1. RDB可以按照时间间隔备份不同时间点的数据，可以更灵活的选择数据还原的版本\n2. 其执行方式决定了他可以更好的保证redis本身的高性能\n3. 相比AOF，在恢复数据时可以在保证速度的前提下恢复大规模的数据\n\n#### 缺点\n\n1. RDB是按照时间间隔生成快照文件的，所以其必然会存在数据丢失的情况，无法保证数据的完整性\n2. RDB的fork操作可能会阻塞主进程\n\n### AOF\n\n#### 执行方式\n    \n    在开启AOF后，redis先将写命令放入缓存区，然后按照配置的策略将写命令追加到AOF文件中。\n    redis提供了不同的AOF策略：\n    1. 无fsync\n    2. 每秒fsync(默认)\n    3. 每个查询fsync\n    fsync即将命令从缓存追加到文件的操作\n\n    相比于RDB，AOF不可避免的问题是其文件会因为追加的命令越来越大，所以AOF提供了重写的操作\n    以控制文件大小。\n    其操作步骤如下：\n    1. fork一个子进程创建新的文件，然后将旧文件的命令进行分析压缩存入新文件，会剔除或者合\n       并一些命令信息以减小文件大小\n    2. 在1执行的过程中，主进程依然会将命令存入缓存区及追加到旧文件中，以保证数据的完整\n    3. 待新文件处理完毕后，用新文件替代旧文件，然后将缓存区的命令追加到新文件中\n\n#### 优点\n\n1. 相比RDB，AOF最明显的优点就是能保证数据的完整，不会丢失\n2. 如果遇到磁盘已满或其他原因导致文件写入数据不完整，redis也提供了redis-check-aof修复\n3. AOF文件作为一个日志文件可以很方便的导出\n\n#### 缺点\n\n1. AOF文件通常会大于RDB的文件\n2. 恢复数据时的加载速度也会慢于RDB\n\n### 混合模式\n\n   混合持久化是4.0版本后出现的新的持久化方式。其结合RDB和AOF，生成前半部分是RDB后半部分是AOF\n   的文件。结合了二者优点，保证加载速度的前提下，兼容了增量数据的持久化。\n\n#### 执行方式\n\n    混合模式的执行方式与AOF大致相同，不同的是会先将全量副本以RDB形式写入aof文件\n    具体过程如下：\n    1. fork一个子进程\n    2. 将全量副本数据以RDB格式写入aof文件\n    3. 将缓冲区的命令一次写入aof文件中\n    4. 写入完成后通知主进程，覆盖旧文件\n\n    此时，新的aof文件前半部分是RDB格式的数据副本，后半部分是增量的命令。在恢复数据时，兼顾了\n    两者的优点。既能保证恢复的速度(RDB的优势)，也能避免数据的丢失(AOF的优点)。\n    其唯一的缺点或许是只能在4.0版本后使用。","source":"_posts/2021/05/redis-persistence.md","raw":"---\ntitle: redis持久化总结\ndate: 2021-05-03 17:22:01\ntags:\n- redis\ncategories:\n- redis\n---\n\n### 前言\n\n    本章对redis持久化相关内容进行一下总结。\n\n<!-- more -->\n\n### 持久化方案\n\n1. RDB：Redis DataBase redis数据库，会按指定的时间间隔将数据生成快照文件存储在硬盘等介质中\n2. AOF：Append Only File 仅附加文件，记录服务器接受的写指令，可以在服务器重启时执行这些命令用以恢复数据。\n3. 无持久化\n4. 混合持久化：仅4.0版本后支持\n\n### RDB\n\n#### 执行方式\n\n    redis会fork一个子进程按照时间间隔来进行持久化操作，主进程不受影响，所以可以保证redis本身\n    的性能。\n\n#### 优点\n\n1. RDB可以按照时间间隔备份不同时间点的数据，可以更灵活的选择数据还原的版本\n2. 其执行方式决定了他可以更好的保证redis本身的高性能\n3. 相比AOF，在恢复数据时可以在保证速度的前提下恢复大规模的数据\n\n#### 缺点\n\n1. RDB是按照时间间隔生成快照文件的，所以其必然会存在数据丢失的情况，无法保证数据的完整性\n2. RDB的fork操作可能会阻塞主进程\n\n### AOF\n\n#### 执行方式\n    \n    在开启AOF后，redis先将写命令放入缓存区，然后按照配置的策略将写命令追加到AOF文件中。\n    redis提供了不同的AOF策略：\n    1. 无fsync\n    2. 每秒fsync(默认)\n    3. 每个查询fsync\n    fsync即将命令从缓存追加到文件的操作\n\n    相比于RDB，AOF不可避免的问题是其文件会因为追加的命令越来越大，所以AOF提供了重写的操作\n    以控制文件大小。\n    其操作步骤如下：\n    1. fork一个子进程创建新的文件，然后将旧文件的命令进行分析压缩存入新文件，会剔除或者合\n       并一些命令信息以减小文件大小\n    2. 在1执行的过程中，主进程依然会将命令存入缓存区及追加到旧文件中，以保证数据的完整\n    3. 待新文件处理完毕后，用新文件替代旧文件，然后将缓存区的命令追加到新文件中\n\n#### 优点\n\n1. 相比RDB，AOF最明显的优点就是能保证数据的完整，不会丢失\n2. 如果遇到磁盘已满或其他原因导致文件写入数据不完整，redis也提供了redis-check-aof修复\n3. AOF文件作为一个日志文件可以很方便的导出\n\n#### 缺点\n\n1. AOF文件通常会大于RDB的文件\n2. 恢复数据时的加载速度也会慢于RDB\n\n### 混合模式\n\n   混合持久化是4.0版本后出现的新的持久化方式。其结合RDB和AOF，生成前半部分是RDB后半部分是AOF\n   的文件。结合了二者优点，保证加载速度的前提下，兼容了增量数据的持久化。\n\n#### 执行方式\n\n    混合模式的执行方式与AOF大致相同，不同的是会先将全量副本以RDB形式写入aof文件\n    具体过程如下：\n    1. fork一个子进程\n    2. 将全量副本数据以RDB格式写入aof文件\n    3. 将缓冲区的命令一次写入aof文件中\n    4. 写入完成后通知主进程，覆盖旧文件\n\n    此时，新的aof文件前半部分是RDB格式的数据副本，后半部分是增量的命令。在恢复数据时，兼顾了\n    两者的优点。既能保证恢复的速度(RDB的优势)，也能避免数据的丢失(AOF的优点)。\n    其唯一的缺点或许是只能在4.0版本后使用。","slug":"redis-persistence","published":1,"updated":"2021-07-02T01:33:02.858Z","_id":"cko8eg3fq0000kkb553iohf2m","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><pre><code>本章对redis持久化相关内容进行一下总结。</code></pre><a id=\"more\"></a>\n\n<h3 id=\"持久化方案\"><a href=\"#持久化方案\" class=\"headerlink\" title=\"持久化方案\"></a>持久化方案</h3><ol>\n<li>RDB：Redis DataBase redis数据库，会按指定的时间间隔将数据生成快照文件存储在硬盘等介质中</li>\n<li>AOF：Append Only File 仅附加文件，记录服务器接受的写指令，可以在服务器重启时执行这些命令用以恢复数据。</li>\n<li>无持久化</li>\n<li>混合持久化：仅4.0版本后支持</li>\n</ol>\n<h3 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h3><h4 id=\"执行方式\"><a href=\"#执行方式\" class=\"headerlink\" title=\"执行方式\"></a>执行方式</h4><pre><code>redis会fork一个子进程按照时间间隔来进行持久化操作，主进程不受影响，所以可以保证redis本身\n的性能。</code></pre><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>RDB可以按照时间间隔备份不同时间点的数据，可以更灵活的选择数据还原的版本</li>\n<li>其执行方式决定了他可以更好的保证redis本身的高性能</li>\n<li>相比AOF，在恢复数据时可以在保证速度的前提下恢复大规模的数据</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li>RDB是按照时间间隔生成快照文件的，所以其必然会存在数据丢失的情况，无法保证数据的完整性</li>\n<li>RDB的fork操作可能会阻塞主进程</li>\n</ol>\n<h3 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h3><h4 id=\"执行方式-1\"><a href=\"#执行方式-1\" class=\"headerlink\" title=\"执行方式\"></a>执行方式</h4><pre><code>在开启AOF后，redis先将写命令放入缓存区，然后按照配置的策略将写命令追加到AOF文件中。\nredis提供了不同的AOF策略：\n1. 无fsync\n2. 每秒fsync(默认)\n3. 每个查询fsync\nfsync即将命令从缓存追加到文件的操作\n\n相比于RDB，AOF不可避免的问题是其文件会因为追加的命令越来越大，所以AOF提供了重写的操作\n以控制文件大小。\n其操作步骤如下：\n1. fork一个子进程创建新的文件，然后将旧文件的命令进行分析压缩存入新文件，会剔除或者合\n   并一些命令信息以减小文件大小\n2. 在1执行的过程中，主进程依然会将命令存入缓存区及追加到旧文件中，以保证数据的完整\n3. 待新文件处理完毕后，用新文件替代旧文件，然后将缓存区的命令追加到新文件中</code></pre><h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>相比RDB，AOF最明显的优点就是能保证数据的完整，不会丢失</li>\n<li>如果遇到磁盘已满或其他原因导致文件写入数据不完整，redis也提供了redis-check-aof修复</li>\n<li>AOF文件作为一个日志文件可以很方便的导出</li>\n</ol>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li>AOF文件通常会大于RDB的文件</li>\n<li>恢复数据时的加载速度也会慢于RDB</li>\n</ol>\n<h3 id=\"混合模式\"><a href=\"#混合模式\" class=\"headerlink\" title=\"混合模式\"></a>混合模式</h3><p>   混合持久化是4.0版本后出现的新的持久化方式。其结合RDB和AOF，生成前半部分是RDB后半部分是AOF<br>   的文件。结合了二者优点，保证加载速度的前提下，兼容了增量数据的持久化。</p>\n<h4 id=\"执行方式-2\"><a href=\"#执行方式-2\" class=\"headerlink\" title=\"执行方式\"></a>执行方式</h4><pre><code>混合模式的执行方式与AOF大致相同，不同的是会先将全量副本以RDB形式写入aof文件\n具体过程如下：\n1. fork一个子进程\n2. 将全量副本数据以RDB格式写入aof文件\n3. 将缓冲区的命令一次写入aof文件中\n4. 写入完成后通知主进程，覆盖旧文件\n\n此时，新的aof文件前半部分是RDB格式的数据副本，后半部分是增量的命令。在恢复数据时，兼顾了\n两者的优点。既能保证恢复的速度(RDB的优势)，也能避免数据的丢失(AOF的优点)。\n其唯一的缺点或许是只能在4.0版本后使用。</code></pre>","site":{"data":{}},"length":1148,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><pre><code>本章对redis持久化相关内容进行一下总结。</code></pre>","more":"<h3 id=\"持久化方案\"><a href=\"#持久化方案\" class=\"headerlink\" title=\"持久化方案\"></a>持久化方案</h3><ol>\n<li>RDB：Redis DataBase redis数据库，会按指定的时间间隔将数据生成快照文件存储在硬盘等介质中</li>\n<li>AOF：Append Only File 仅附加文件，记录服务器接受的写指令，可以在服务器重启时执行这些命令用以恢复数据。</li>\n<li>无持久化</li>\n<li>混合持久化：仅4.0版本后支持</li>\n</ol>\n<h3 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h3><h4 id=\"执行方式\"><a href=\"#执行方式\" class=\"headerlink\" title=\"执行方式\"></a>执行方式</h4><pre><code>redis会fork一个子进程按照时间间隔来进行持久化操作，主进程不受影响，所以可以保证redis本身\n的性能。</code></pre><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>RDB可以按照时间间隔备份不同时间点的数据，可以更灵活的选择数据还原的版本</li>\n<li>其执行方式决定了他可以更好的保证redis本身的高性能</li>\n<li>相比AOF，在恢复数据时可以在保证速度的前提下恢复大规模的数据</li>\n</ol>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li>RDB是按照时间间隔生成快照文件的，所以其必然会存在数据丢失的情况，无法保证数据的完整性</li>\n<li>RDB的fork操作可能会阻塞主进程</li>\n</ol>\n<h3 id=\"AOF\"><a href=\"#AOF\" class=\"headerlink\" title=\"AOF\"></a>AOF</h3><h4 id=\"执行方式-1\"><a href=\"#执行方式-1\" class=\"headerlink\" title=\"执行方式\"></a>执行方式</h4><pre><code>在开启AOF后，redis先将写命令放入缓存区，然后按照配置的策略将写命令追加到AOF文件中。\nredis提供了不同的AOF策略：\n1. 无fsync\n2. 每秒fsync(默认)\n3. 每个查询fsync\nfsync即将命令从缓存追加到文件的操作\n\n相比于RDB，AOF不可避免的问题是其文件会因为追加的命令越来越大，所以AOF提供了重写的操作\n以控制文件大小。\n其操作步骤如下：\n1. fork一个子进程创建新的文件，然后将旧文件的命令进行分析压缩存入新文件，会剔除或者合\n   并一些命令信息以减小文件大小\n2. 在1执行的过程中，主进程依然会将命令存入缓存区及追加到旧文件中，以保证数据的完整\n3. 待新文件处理完毕后，用新文件替代旧文件，然后将缓存区的命令追加到新文件中</code></pre><h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><ol>\n<li>相比RDB，AOF最明显的优点就是能保证数据的完整，不会丢失</li>\n<li>如果遇到磁盘已满或其他原因导致文件写入数据不完整，redis也提供了redis-check-aof修复</li>\n<li>AOF文件作为一个日志文件可以很方便的导出</li>\n</ol>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><ol>\n<li>AOF文件通常会大于RDB的文件</li>\n<li>恢复数据时的加载速度也会慢于RDB</li>\n</ol>\n<h3 id=\"混合模式\"><a href=\"#混合模式\" class=\"headerlink\" title=\"混合模式\"></a>混合模式</h3><p>   混合持久化是4.0版本后出现的新的持久化方式。其结合RDB和AOF，生成前半部分是RDB后半部分是AOF<br>   的文件。结合了二者优点，保证加载速度的前提下，兼容了增量数据的持久化。</p>\n<h4 id=\"执行方式-2\"><a href=\"#执行方式-2\" class=\"headerlink\" title=\"执行方式\"></a>执行方式</h4><pre><code>混合模式的执行方式与AOF大致相同，不同的是会先将全量副本以RDB形式写入aof文件\n具体过程如下：\n1. fork一个子进程\n2. 将全量副本数据以RDB格式写入aof文件\n3. 将缓冲区的命令一次写入aof文件中\n4. 写入完成后通知主进程，覆盖旧文件\n\n此时，新的aof文件前半部分是RDB格式的数据副本，后半部分是增量的命令。在恢复数据时，兼顾了\n两者的优点。既能保证恢复的速度(RDB的优势)，也能避免数据的丢失(AOF的优点)。\n其唯一的缺点或许是只能在4.0版本后使用。</code></pre>"},{"title":"HashMap(jdk1.8)数组下标计算分析","date":"2021-05-15T13:15:39.000Z","_content":"\n### 前言\n\n   本章分析下HashMap在新增元素时为什么要选择这么计算数组下标。\n<!-- more -->\n\n### 计算数组下标\n\n   首先，复习下数组下标的定位逻辑：\n\n{% codeblock lang:java %}\n// 计算key的hash值\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n// 计算数组下标 数组长度为2的倍数\n(n - 1) & hash\n{% endcodeblock %}\n\n  总结其逻辑就是三步：\n  1. 获取key的hashCode值 h，获取h的无符号位移16的结果\n  2. 1中的结果做异或运算\n  3. 2中重新计算hash值与数组长度n-1做与运算\n\n#### 为何要 h>>>16\n\n  HashMap中数组的初始长度是16，换成二进制的话就是 \n> 0000 0000 0000 0000 0000 0000 0001 0000\n\n  那么在执行 *h & (n-1)* 时候，如下：\n\n> 0000 0000 0000 0000 0000 0000 0000 1111  （n-1）\n> 0000 0000 1010 0101 1010 0101 1100 0110  （h）\n\n  会发现这里h只有低位参与了运算，结果会相对集中\n  所以，先将h无符号位移16位，这样可以让其高位参加运算，计算下标时会更随机\n\n#### 为何使用 ^ 计算hash\n\n  接下来看第二步，是将h的高低位做异或运算，这里为何选择异或呢？\n  先复习下位运算的知识：\n> a&b 先将a,b转化为二进制数，当且仅当相同位数都为1时，结果是1，否则为0\n   即 1&1 = 1； 0&1，1&0，0&0 = 0\n  a|b 先将a,b转化为二进制数，当且仅当相同位数都为0时，结果是0，否则为1\n   即 0|0 = 0；  0|1，1|0，1|1 = 1\n  a^b 先将a,b转化为二进制数，当且仅当相同位数只有一个为1时，结果是1，否则为0\n   即 1^1，0^0 = 0； 0&1，1&0 = 1\n\n  很容易看出，异或的计算结果相对更加平均，而重新计算hash的目的就是为了使结果更随机，\n  所以或运算和与运算都不太适合。\n\n#### 为何数组长度是2的N次方\n\n  一个数字是2的N次方，那么其二进制只有一位是1，其他位都是0.\n  而当其减去1后，比之前1所在低的位都会为0，以16为例\n> 0000 0000 0000 0000 0000 0000 0001 0000 ->16\n  0000 0000 0000 0000 0000 0000 0000 1111 ->15\n\n  当15作为二进制参与运算时，会发现不论参与计算的hash值是多少，其结果范围被限制在低位\n  的四个1中，其效果与取模有异曲同工之妙。\n  但是位运算的优势在于其计算速度更快，所以HashMap的数组要保持2的N次方。\n\n### 总结\n  \n    在一番分析后，感觉对HashMap计算数组下标的逻辑有了清晰的理解。\n    也很佩服源码作者的智慧，设计得十分巧妙，且合理。","source":"_posts/2021/05/hashMap2.md","raw":"---\ntitle: HashMap(jdk1.8)数组下标计算分析\ndate: 2021-05-15 21:15:39\ntags:\n- Java容器\ncategories:\n- Java\n- Map\n---\n\n### 前言\n\n   本章分析下HashMap在新增元素时为什么要选择这么计算数组下标。\n<!-- more -->\n\n### 计算数组下标\n\n   首先，复习下数组下标的定位逻辑：\n\n{% codeblock lang:java %}\n// 计算key的hash值\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n// 计算数组下标 数组长度为2的倍数\n(n - 1) & hash\n{% endcodeblock %}\n\n  总结其逻辑就是三步：\n  1. 获取key的hashCode值 h，获取h的无符号位移16的结果\n  2. 1中的结果做异或运算\n  3. 2中重新计算hash值与数组长度n-1做与运算\n\n#### 为何要 h>>>16\n\n  HashMap中数组的初始长度是16，换成二进制的话就是 \n> 0000 0000 0000 0000 0000 0000 0001 0000\n\n  那么在执行 *h & (n-1)* 时候，如下：\n\n> 0000 0000 0000 0000 0000 0000 0000 1111  （n-1）\n> 0000 0000 1010 0101 1010 0101 1100 0110  （h）\n\n  会发现这里h只有低位参与了运算，结果会相对集中\n  所以，先将h无符号位移16位，这样可以让其高位参加运算，计算下标时会更随机\n\n#### 为何使用 ^ 计算hash\n\n  接下来看第二步，是将h的高低位做异或运算，这里为何选择异或呢？\n  先复习下位运算的知识：\n> a&b 先将a,b转化为二进制数，当且仅当相同位数都为1时，结果是1，否则为0\n   即 1&1 = 1； 0&1，1&0，0&0 = 0\n  a|b 先将a,b转化为二进制数，当且仅当相同位数都为0时，结果是0，否则为1\n   即 0|0 = 0；  0|1，1|0，1|1 = 1\n  a^b 先将a,b转化为二进制数，当且仅当相同位数只有一个为1时，结果是1，否则为0\n   即 1^1，0^0 = 0； 0&1，1&0 = 1\n\n  很容易看出，异或的计算结果相对更加平均，而重新计算hash的目的就是为了使结果更随机，\n  所以或运算和与运算都不太适合。\n\n#### 为何数组长度是2的N次方\n\n  一个数字是2的N次方，那么其二进制只有一位是1，其他位都是0.\n  而当其减去1后，比之前1所在低的位都会为0，以16为例\n> 0000 0000 0000 0000 0000 0000 0001 0000 ->16\n  0000 0000 0000 0000 0000 0000 0000 1111 ->15\n\n  当15作为二进制参与运算时，会发现不论参与计算的hash值是多少，其结果范围被限制在低位\n  的四个1中，其效果与取模有异曲同工之妙。\n  但是位运算的优势在于其计算速度更快，所以HashMap的数组要保持2的N次方。\n\n### 总结\n  \n    在一番分析后，感觉对HashMap计算数组下标的逻辑有了清晰的理解。\n    也很佩服源码作者的智慧，设计得十分巧妙，且合理。","slug":"hashMap2","published":1,"updated":"2021-05-15T14:43:24.804Z","_id":"ckopu6fjs00000kb5e9e0ctrs","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   本章分析下HashMap在新增元素时为什么要选择这么计算数组下标。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"计算数组下标\"><a href=\"#计算数组下标\" class=\"headerlink\" title=\"计算数组下标\"></a>计算数组下标</h3><p>   首先，复习下数组下标的定位逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算key的hash值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 计算数组下标 数组长度为2的倍数</span></span><br><span class=\"line\">(n - <span class=\"number\">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>\n\n<p>  总结其逻辑就是三步：</p>\n<ol>\n<li>获取key的hashCode值 h，获取h的无符号位移16的结果</li>\n<li>1中的结果做异或运算</li>\n<li>2中重新计算hash值与数组长度n-1做与运算</li>\n</ol>\n<h4 id=\"为何要-h-gt-gt-gt-16\"><a href=\"#为何要-h-gt-gt-gt-16\" class=\"headerlink\" title=\"为何要 h&gt;&gt;&gt;16\"></a>为何要 h&gt;&gt;&gt;16</h4><p>  HashMap中数组的初始长度是16，换成二进制的话就是 </p>\n<blockquote>\n<p>0000 0000 0000 0000 0000 0000 0001 0000</p>\n</blockquote>\n<p>  那么在执行 <em>h &amp; (n-1)</em> 时候，如下：</p>\n<blockquote>\n<p>0000 0000 0000 0000 0000 0000 0000 1111  （n-1）<br>0000 0000 1010 0101 1010 0101 1100 0110  （h）</p>\n</blockquote>\n<p>  会发现这里h只有低位参与了运算，结果会相对集中<br>  所以，先将h无符号位移16位，这样可以让其高位参加运算，计算下标时会更随机</p>\n<h4 id=\"为何使用-计算hash\"><a href=\"#为何使用-计算hash\" class=\"headerlink\" title=\"为何使用 ^ 计算hash\"></a>为何使用 ^ 计算hash</h4><p>  接下来看第二步，是将h的高低位做异或运算，这里为何选择异或呢？<br>  先复习下位运算的知识：</p>\n<blockquote>\n<p>a&amp;b 先将a,b转化为二进制数，当且仅当相同位数都为1时，结果是1，否则为0<br>   即 1&amp;1 = 1； 0&amp;1，1&amp;0，0&amp;0 = 0<br>  a|b 先将a,b转化为二进制数，当且仅当相同位数都为0时，结果是0，否则为1<br>   即 0|0 = 0；  0|1，1|0，1|1 = 1<br>  a^b 先将a,b转化为二进制数，当且仅当相同位数只有一个为1时，结果是1，否则为0<br>   即 1^1，0^0 = 0； 0&amp;1，1&amp;0 = 1</p>\n</blockquote>\n<p>  很容易看出，异或的计算结果相对更加平均，而重新计算hash的目的就是为了使结果更随机，<br>  所以或运算和与运算都不太适合。</p>\n<h4 id=\"为何数组长度是2的N次方\"><a href=\"#为何数组长度是2的N次方\" class=\"headerlink\" title=\"为何数组长度是2的N次方\"></a>为何数组长度是2的N次方</h4><p>  一个数字是2的N次方，那么其二进制只有一位是1，其他位都是0.<br>  而当其减去1后，比之前1所在低的位都会为0，以16为例</p>\n<blockquote>\n<p>0000 0000 0000 0000 0000 0000 0001 0000 -&gt;16<br>  0000 0000 0000 0000 0000 0000 0000 1111 -&gt;15</p>\n</blockquote>\n<p>  当15作为二进制参与运算时，会发现不论参与计算的hash值是多少，其结果范围被限制在低位<br>  的四个1中，其效果与取模有异曲同工之妙。<br>  但是位运算的优势在于其计算速度更快，所以HashMap的数组要保持2的N次方。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>在一番分析后，感觉对HashMap计算数组下标的逻辑有了清晰的理解。\n也很佩服源码作者的智慧，设计得十分巧妙，且合理。</code></pre>","site":{"data":{}},"length":990,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   本章分析下HashMap在新增元素时为什么要选择这么计算数组下标。</p>","more":"<h3 id=\"计算数组下标\"><a href=\"#计算数组下标\" class=\"headerlink\" title=\"计算数组下标\"></a>计算数组下标</h3><p>   首先，复习下数组下标的定位逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算key的hash值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 计算数组下标 数组长度为2的倍数</span></span><br><span class=\"line\">(n - <span class=\"number\">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>\n\n<p>  总结其逻辑就是三步：</p>\n<ol>\n<li>获取key的hashCode值 h，获取h的无符号位移16的结果</li>\n<li>1中的结果做异或运算</li>\n<li>2中重新计算hash值与数组长度n-1做与运算</li>\n</ol>\n<h4 id=\"为何要-h-gt-gt-gt-16\"><a href=\"#为何要-h-gt-gt-gt-16\" class=\"headerlink\" title=\"为何要 h&gt;&gt;&gt;16\"></a>为何要 h&gt;&gt;&gt;16</h4><p>  HashMap中数组的初始长度是16，换成二进制的话就是 </p>\n<blockquote>\n<p>0000 0000 0000 0000 0000 0000 0001 0000</p>\n</blockquote>\n<p>  那么在执行 <em>h &amp; (n-1)</em> 时候，如下：</p>\n<blockquote>\n<p>0000 0000 0000 0000 0000 0000 0000 1111  （n-1）<br>0000 0000 1010 0101 1010 0101 1100 0110  （h）</p>\n</blockquote>\n<p>  会发现这里h只有低位参与了运算，结果会相对集中<br>  所以，先将h无符号位移16位，这样可以让其高位参加运算，计算下标时会更随机</p>\n<h4 id=\"为何使用-计算hash\"><a href=\"#为何使用-计算hash\" class=\"headerlink\" title=\"为何使用 ^ 计算hash\"></a>为何使用 ^ 计算hash</h4><p>  接下来看第二步，是将h的高低位做异或运算，这里为何选择异或呢？<br>  先复习下位运算的知识：</p>\n<blockquote>\n<p>a&amp;b 先将a,b转化为二进制数，当且仅当相同位数都为1时，结果是1，否则为0<br>   即 1&amp;1 = 1； 0&amp;1，1&amp;0，0&amp;0 = 0<br>  a|b 先将a,b转化为二进制数，当且仅当相同位数都为0时，结果是0，否则为1<br>   即 0|0 = 0；  0|1，1|0，1|1 = 1<br>  a^b 先将a,b转化为二进制数，当且仅当相同位数只有一个为1时，结果是1，否则为0<br>   即 1^1，0^0 = 0； 0&amp;1，1&amp;0 = 1</p>\n</blockquote>\n<p>  很容易看出，异或的计算结果相对更加平均，而重新计算hash的目的就是为了使结果更随机，<br>  所以或运算和与运算都不太适合。</p>\n<h4 id=\"为何数组长度是2的N次方\"><a href=\"#为何数组长度是2的N次方\" class=\"headerlink\" title=\"为何数组长度是2的N次方\"></a>为何数组长度是2的N次方</h4><p>  一个数字是2的N次方，那么其二进制只有一位是1，其他位都是0.<br>  而当其减去1后，比之前1所在低的位都会为0，以16为例</p>\n<blockquote>\n<p>0000 0000 0000 0000 0000 0000 0001 0000 -&gt;16<br>  0000 0000 0000 0000 0000 0000 0000 1111 -&gt;15</p>\n</blockquote>\n<p>  当15作为二进制参与运算时，会发现不论参与计算的hash值是多少，其结果范围被限制在低位<br>  的四个1中，其效果与取模有异曲同工之妙。<br>  但是位运算的优势在于其计算速度更快，所以HashMap的数组要保持2的N次方。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>在一番分析后，感觉对HashMap计算数组下标的逻辑有了清晰的理解。\n也很佩服源码作者的智慧，设计得十分巧妙，且合理。</code></pre>"},{"title":"AQS独占共享模式","date":"2021-05-10T13:15:52.000Z","_content":"\n### 前言\n   \n   本章针对AQS的独占共享两种模式，通过源码分析其具体的实现逻辑。\n<!-- more -->\n\n### 独占模式\n\n   独占模式即同一时间，只能允许一个线程获取锁资源。\n   这里结合ReentrantLock分析:\n{% codeblock lang:java %}\n// AQS中响应中断的独占模式获取方法\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        // 获取锁失败\n        doAcquireInterruptibly(arg);\n}\n// ReentrantLock中tryAcquire的具体实现(非公平锁)\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n}\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n// AQS获取锁失败后的方法\nprivate void doAcquireInterruptibly(int arg)\n    throws InterruptedException {\n    // 新建独占节点 使用尾插法插入队列尾部\n    // Node.EXCLUSIVE作为新节点nextWaiter属性的值 用于标识独占节点\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n        \t// 前置节点\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                // 当前置节点为头节点且获取锁成功 表明锁被释放\n                // 将当前节点设置为头节点\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n{% endcodeblock %}\n{% img  /image/xxxx/xxxxx.png  '\"xxxx\"' %}","source":"_posts/2021/05/AQS2.md","raw":"---\ntitle: AQS独占共享模式\ndate: 2021-05-10 21:15:52\ntags:\n- JUC\ncategories:\n- Java\n- JUC\n---\n\n### 前言\n   \n   本章针对AQS的独占共享两种模式，通过源码分析其具体的实现逻辑。\n<!-- more -->\n\n### 独占模式\n\n   独占模式即同一时间，只能允许一个线程获取锁资源。\n   这里结合ReentrantLock分析:\n{% codeblock lang:java %}\n// AQS中响应中断的独占模式获取方法\npublic final void acquireInterruptibly(int arg)\n        throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        // 获取锁失败\n        doAcquireInterruptibly(arg);\n}\n// ReentrantLock中tryAcquire的具体实现(非公平锁)\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n}\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n// AQS获取锁失败后的方法\nprivate void doAcquireInterruptibly(int arg)\n    throws InterruptedException {\n    // 新建独占节点 使用尾插法插入队列尾部\n    // Node.EXCLUSIVE作为新节点nextWaiter属性的值 用于标识独占节点\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n        \t// 前置节点\n            final Node p = node.predecessor();\n            if (p == head && tryAcquire(arg)) {\n                // 当前置节点为头节点且获取锁成功 表明锁被释放\n                // 将当前节点设置为头节点\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n{% endcodeblock %}\n{% img  /image/xxxx/xxxxx.png  '\"xxxx\"' %}","slug":"AQS2","published":1,"updated":"2021-05-10T14:08:52.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckopu6fjy00010kb5gqa7ebt6","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   本章针对AQS的独占共享两种模式，通过源码分析其具体的实现逻辑。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"独占模式\"><a href=\"#独占模式\" class=\"headerlink\" title=\"独占模式\"></a>独占模式</h3><p>   独占模式即同一时间，只能允许一个线程获取锁资源。<br>   这里结合ReentrantLock分析:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AQS中响应中断的独占模式获取方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg))</span><br><span class=\"line\">        <span class=\"comment\">// 获取锁失败</span></span><br><span class=\"line\">        doAcquireInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ReentrantLock中tryAcquire的具体实现(非公平锁)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AQS获取锁失败后的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新建独占节点 使用尾插法插入队列尾部</span></span><br><span class=\"line\">    <span class=\"comment\">// Node.EXCLUSIVE作为新节点nextWaiter属性的值 用于标识独占节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当前置节点为头节点且获取锁成功 表明锁被释放</span></span><br><span class=\"line\">                <span class=\"comment\">// 将当前节点设置为头节点</span></span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/xxxx/xxxxx.png\" class=\"\" title=\"xxxx\">","site":{"data":{}},"length":82,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>   本章针对AQS的独占共享两种模式，通过源码分析其具体的实现逻辑。</p>","more":"<h3 id=\"独占模式\"><a href=\"#独占模式\" class=\"headerlink\" title=\"独占模式\"></a>独占模式</h3><p>   独占模式即同一时间，只能允许一个线程获取锁资源。<br>   这里结合ReentrantLock分析:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// AQS中响应中断的独占模式获取方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg))</span><br><span class=\"line\">        <span class=\"comment\">// 获取锁失败</span></span><br><span class=\"line\">        doAcquireInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// ReentrantLock中tryAcquire的具体实现(非公平锁)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(current);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AQS获取锁失败后的方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doAcquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 新建独占节点 使用尾插法插入队列尾部</span></span><br><span class=\"line\">    <span class=\"comment\">// Node.EXCLUSIVE作为新节点nextWaiter属性的值 用于标识独占节点</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">// 前置节点</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当前置节点为头节点且获取锁成功 表明锁被释放</span></span><br><span class=\"line\">                <span class=\"comment\">// 将当前节点设置为头节点</span></span><br><span class=\"line\">                setHead(node);</span><br><span class=\"line\">                p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/image/xxxx/xxxxx.png\" class=\"\" title=\"xxxx\">"},{"title":"http请求过程分析","date":"2021-05-16T12:44:46.000Z","_content":"\n### 前言\n\n  本章想通过一次http请求过程，分析总结下相关的知识点。\n<!-- more -->\n\n### 请求过程\n\n  先概括一下整个请求过程：\n  1. 当输入一个网址后，浏览器会进行域名解析，找到对应的IP地址\n  2. 浏览器通过IP找到对应服务器请求建立连接\n  3. 建立连接后就会发送请求给服务器\n  4. 服务器返回响应结果\n  5. 断开连接\n\n### DNS解析\n\n  DNS解析会把输入的域名映射到对应的IP地址上，然后通过IP地址找到服务器。\n  其目的就是为了方便大众使用，有规律的域名更方便用户记忆。\n\n> 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。\n  它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。\n  DNS使用UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。\n  --- 摘自百度百科\n\n### TCP三次握手\n\n  在得到服务器IP地址后，客户端就需要发起请求连接，通过TCP三次握手与服务器建立连接。\n  \n    第一次握手：客户端发送请求，\n               标志位SYN=1，seq=seqC(随机数)\n    第二次握手：服务端响应新建连接请求，\n               标志位SYN=1，标志位ACK=1，ack=seqC+1，seq=seqS(随机数)\n    第三次握手：客户端确认报文(检查ack是否正确)，确认无误后，响应请求\n               标志位ACK=1，ack=seqS+1，seq=seqC+1\n               服务端接收到报文后，同样会检查ack是否正确，无误后建立连接\n\n#### 示意图\n  \n  {% img  /image/HTTP/http-request1.png  '\"三次握手\"' %}\n\n#### 为何要三次握手\n\n> 如果只依赖两次握手建立连接，那么会有以下几个问题：\n  1. 客户端延迟的连接请求发送到服务端，导致重复建立连接\n  2. 如果客户端没有收到服务端的确认，此时进入连接状态的服务端会一直等待客户端传输数据，浪费资源\n\n> 而三次握手能实现以下目的：\n  1. 第一次握手请求连接\n  此时，服务端确认自己接收消息的功能完好\n  2. 第二次握手服务端响应第一次握手\n  此时，客户端可以确认自己发送消息和接收消息的功能完好\n  3. 第三次客户端响应第二次握手\n  此时，服务端确认自己发送消息的功能完好\n  至此，双发互相确认了发送，接收功能的完好，可以创建连接开始通信\n\n\n### TCP四次挥手\n  \n  在请求完成后，需要断开客户端与服务端建立的连接。类似于三次握手创立连接，此时需要经过四次挥手去完成断开连接的过程(因为可能还有数据没传送完，所以多一次确认请求)。\n\n    第一次挥手：发起方发起断开请求，\n               标志位FIN=1，seq=seqC(随机数)\n    第二次挥手：接收方返回确认，\n               标志位ACK=1，ack=seqC+1，seq=seqS1(随机数)\n    第三次挥手：待接收方完成传输处理，会向发起方发送确认断开的请求\n               标志位FIN=1，ACK=1，ack=seqC+1，seq=seqS2(随机数)\n    第四次挥手：发起方确认报文无误后响应接收方的断开请求，\n               标志位ACK=1，ack=seqS2+1，seq=seqC+1\n    第四次挥手后，接收方收到发起方的确认请求后就会进入CLOSED状态，而发起方会等待2MSL的时间后进入CLOSED状态\n\n#### 示意图\n\n  {% img  /image/HTTP/http-request3.png  '\"三次握手\"' %}\n\n#### 何时断开\n\n  在了解TCP四次挥手后，有两个疑问：\n  1. 何时去断开连接？\n     在确认数据传输完毕后就可以断开连接\n     (但为了防止频繁的握手和挥手，客户端可以在请求头中指定Connection: Keep-Alive保持连接)\n  2. 由哪一方发起断开请求？\n     这个视具体情况而定，也就是哪一方能够确认数据传输完毕。\n     举个例子：\n     {% img  /image/HTTP/http-request2.png  '\"三次握手\"' %}\n\n     这里访问搜索引擎首页，一般来说这种首页静态资源是固定的。\n     所以可以看到服务端响应头信息中content-length指定了具体数据，那么客户端会根据这个大小判断是否完成数据传输然后发起断开请求。\n\n     另一种情况就是如果服务端无法确认传输数据的大小，那么会采用块传输的方式或者短连接(也就是服务端判断数据传输完了就直接断开连接)\n\n#### 为何发起方最后要等待2MSL\n\n  主要考虑到第四次握手，也就是响应接收方的二次确认请求失败的情况。如果此时发起方直接关闭，那么就收不到接收方因重试发送的请求。\n> MSL: Maximum Segment Lifetime 即报文最大生存时间，超过这个时间的报文将被丢弃\n\n### TCP标志位\n\n> 标志位代表TCP连接的状态，有以下六种：\nSYN：表示请求建立一个连接）\nURG：紧急标志\nACK：确认数据包的接收\nPSH：推送标志，提高数据传输的优先级\nRST：要求对方重新建立连接\nFIN：表示要断开连接\n\n### 参考\n\n>[TCP三次握手和四次挥手过程](https://www.cnblogs.com/Andya/p/7272462.html)\n>[Http协议Content-Length详解](https://www.cnblogs.com/nxlhero/p/11670942.html)\n>[HTTP协议的Keep-Alive 模式](https://www.jianshu.com/p/49551bda6619)","source":"_posts/2021/05/http-request.md","raw":"---\ntitle: http请求过程分析\ndate: 2021-05-16 20:44:46\ntags:\n- 计算机网络\ncategories:\n- 计算机网络\n---\n\n### 前言\n\n  本章想通过一次http请求过程，分析总结下相关的知识点。\n<!-- more -->\n\n### 请求过程\n\n  先概括一下整个请求过程：\n  1. 当输入一个网址后，浏览器会进行域名解析，找到对应的IP地址\n  2. 浏览器通过IP找到对应服务器请求建立连接\n  3. 建立连接后就会发送请求给服务器\n  4. 服务器返回响应结果\n  5. 断开连接\n\n### DNS解析\n\n  DNS解析会把输入的域名映射到对应的IP地址上，然后通过IP地址找到服务器。\n  其目的就是为了方便大众使用，有规律的域名更方便用户记忆。\n\n> 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。\n  它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。\n  DNS使用UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。\n  --- 摘自百度百科\n\n### TCP三次握手\n\n  在得到服务器IP地址后，客户端就需要发起请求连接，通过TCP三次握手与服务器建立连接。\n  \n    第一次握手：客户端发送请求，\n               标志位SYN=1，seq=seqC(随机数)\n    第二次握手：服务端响应新建连接请求，\n               标志位SYN=1，标志位ACK=1，ack=seqC+1，seq=seqS(随机数)\n    第三次握手：客户端确认报文(检查ack是否正确)，确认无误后，响应请求\n               标志位ACK=1，ack=seqS+1，seq=seqC+1\n               服务端接收到报文后，同样会检查ack是否正确，无误后建立连接\n\n#### 示意图\n  \n  {% img  /image/HTTP/http-request1.png  '\"三次握手\"' %}\n\n#### 为何要三次握手\n\n> 如果只依赖两次握手建立连接，那么会有以下几个问题：\n  1. 客户端延迟的连接请求发送到服务端，导致重复建立连接\n  2. 如果客户端没有收到服务端的确认，此时进入连接状态的服务端会一直等待客户端传输数据，浪费资源\n\n> 而三次握手能实现以下目的：\n  1. 第一次握手请求连接\n  此时，服务端确认自己接收消息的功能完好\n  2. 第二次握手服务端响应第一次握手\n  此时，客户端可以确认自己发送消息和接收消息的功能完好\n  3. 第三次客户端响应第二次握手\n  此时，服务端确认自己发送消息的功能完好\n  至此，双发互相确认了发送，接收功能的完好，可以创建连接开始通信\n\n\n### TCP四次挥手\n  \n  在请求完成后，需要断开客户端与服务端建立的连接。类似于三次握手创立连接，此时需要经过四次挥手去完成断开连接的过程(因为可能还有数据没传送完，所以多一次确认请求)。\n\n    第一次挥手：发起方发起断开请求，\n               标志位FIN=1，seq=seqC(随机数)\n    第二次挥手：接收方返回确认，\n               标志位ACK=1，ack=seqC+1，seq=seqS1(随机数)\n    第三次挥手：待接收方完成传输处理，会向发起方发送确认断开的请求\n               标志位FIN=1，ACK=1，ack=seqC+1，seq=seqS2(随机数)\n    第四次挥手：发起方确认报文无误后响应接收方的断开请求，\n               标志位ACK=1，ack=seqS2+1，seq=seqC+1\n    第四次挥手后，接收方收到发起方的确认请求后就会进入CLOSED状态，而发起方会等待2MSL的时间后进入CLOSED状态\n\n#### 示意图\n\n  {% img  /image/HTTP/http-request3.png  '\"三次握手\"' %}\n\n#### 何时断开\n\n  在了解TCP四次挥手后，有两个疑问：\n  1. 何时去断开连接？\n     在确认数据传输完毕后就可以断开连接\n     (但为了防止频繁的握手和挥手，客户端可以在请求头中指定Connection: Keep-Alive保持连接)\n  2. 由哪一方发起断开请求？\n     这个视具体情况而定，也就是哪一方能够确认数据传输完毕。\n     举个例子：\n     {% img  /image/HTTP/http-request2.png  '\"三次握手\"' %}\n\n     这里访问搜索引擎首页，一般来说这种首页静态资源是固定的。\n     所以可以看到服务端响应头信息中content-length指定了具体数据，那么客户端会根据这个大小判断是否完成数据传输然后发起断开请求。\n\n     另一种情况就是如果服务端无法确认传输数据的大小，那么会采用块传输的方式或者短连接(也就是服务端判断数据传输完了就直接断开连接)\n\n#### 为何发起方最后要等待2MSL\n\n  主要考虑到第四次握手，也就是响应接收方的二次确认请求失败的情况。如果此时发起方直接关闭，那么就收不到接收方因重试发送的请求。\n> MSL: Maximum Segment Lifetime 即报文最大生存时间，超过这个时间的报文将被丢弃\n\n### TCP标志位\n\n> 标志位代表TCP连接的状态，有以下六种：\nSYN：表示请求建立一个连接）\nURG：紧急标志\nACK：确认数据包的接收\nPSH：推送标志，提高数据传输的优先级\nRST：要求对方重新建立连接\nFIN：表示要断开连接\n\n### 参考\n\n>[TCP三次握手和四次挥手过程](https://www.cnblogs.com/Andya/p/7272462.html)\n>[Http协议Content-Length详解](https://www.cnblogs.com/nxlhero/p/11670942.html)\n>[HTTP协议的Keep-Alive 模式](https://www.jianshu.com/p/49551bda6619)","slug":"http-request","published":1,"updated":"2021-07-11T13:45:06.460Z","_id":"ckor6840z00000wb52z8mfbl4","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章想通过一次http请求过程，分析总结下相关的知识点。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"请求过程\"><a href=\"#请求过程\" class=\"headerlink\" title=\"请求过程\"></a>请求过程</h3><p>  先概括一下整个请求过程：</p>\n<ol>\n<li>当输入一个网址后，浏览器会进行域名解析，找到对应的IP地址</li>\n<li>浏览器通过IP找到对应服务器请求建立连接</li>\n<li>建立连接后就会发送请求给服务器</li>\n<li>服务器返回响应结果</li>\n<li>断开连接</li>\n</ol>\n<h3 id=\"DNS解析\"><a href=\"#DNS解析\" class=\"headerlink\" title=\"DNS解析\"></a>DNS解析</h3><p>  DNS解析会把输入的域名映射到对应的IP地址上，然后通过IP地址找到服务器。<br>  其目的就是为了方便大众使用，有规律的域名更方便用户记忆。</p>\n<blockquote>\n<p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。<br>  它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。<br>  DNS使用UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。<br>  — 摘自百度百科</p>\n</blockquote>\n<h3 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP三次握手</h3><p>  在得到服务器IP地址后，客户端就需要发起请求连接，通过TCP三次握手与服务器建立连接。</p>\n<pre><code>第一次握手：客户端发送请求，\n           标志位SYN=1，seq=seqC(随机数)\n第二次握手：服务端响应新建连接请求，\n           标志位SYN=1，标志位ACK=1，ack=seqC+1，seq=seqS(随机数)\n第三次握手：客户端确认报文(检查ack是否正确)，确认无误后，响应请求\n           标志位ACK=1，ack=seqS+1，seq=seqC+1\n           服务端接收到报文后，同样会检查ack是否正确，无误后建立连接</code></pre><h4 id=\"示意图\"><a href=\"#示意图\" class=\"headerlink\" title=\"示意图\"></a>示意图</h4>  <img src=\"/image/HTTP/http-request1.png\" class=\"\" title=\"三次握手\">\n\n<h4 id=\"为何要三次握手\"><a href=\"#为何要三次握手\" class=\"headerlink\" title=\"为何要三次握手\"></a>为何要三次握手</h4><blockquote>\n<p>如果只依赖两次握手建立连接，那么会有以下几个问题：</p>\n</blockquote>\n<ol>\n<li>客户端延迟的连接请求发送到服务端，导致重复建立连接</li>\n<li>如果客户端没有收到服务端的确认，此时进入连接状态的服务端会一直等待客户端传输数据，浪费资源</li>\n</ol>\n<blockquote>\n<p>而三次握手能实现以下目的：</p>\n</blockquote>\n<ol>\n<li>第一次握手请求连接<br>此时，服务端确认自己接收消息的功能完好</li>\n<li>第二次握手服务端响应第一次握手<br>此时，客户端可以确认自己发送消息和接收消息的功能完好</li>\n<li>第三次客户端响应第二次握手<br>此时，服务端确认自己发送消息的功能完好<br>至此，双发互相确认了发送，接收功能的完好，可以创建连接开始通信</li>\n</ol>\n<h3 id=\"TCP四次挥手\"><a href=\"#TCP四次挥手\" class=\"headerlink\" title=\"TCP四次挥手\"></a>TCP四次挥手</h3><p>  在请求完成后，需要断开客户端与服务端建立的连接。类似于三次握手创立连接，此时需要经过四次挥手去完成断开连接的过程(因为可能还有数据没传送完，所以多一次确认请求)。</p>\n<pre><code>第一次挥手：发起方发起断开请求，\n           标志位FIN=1，seq=seqC(随机数)\n第二次挥手：接收方返回确认，\n           标志位ACK=1，ack=seqC+1，seq=seqS1(随机数)\n第三次挥手：待接收方完成传输处理，会向发起方发送确认断开的请求\n           标志位FIN=1，ACK=1，ack=seqC+1，seq=seqS2(随机数)\n第四次挥手：发起方确认报文无误后响应接收方的断开请求，\n           标志位ACK=1，ack=seqS2+1，seq=seqC+1\n第四次挥手后，接收方收到发起方的确认请求后就会进入CLOSED状态，而发起方会等待2MSL的时间后进入CLOSED状态</code></pre><h4 id=\"示意图-1\"><a href=\"#示意图-1\" class=\"headerlink\" title=\"示意图\"></a>示意图</h4>  <img src=\"/image/HTTP/http-request3.png\" class=\"\" title=\"三次握手\">\n\n<h4 id=\"何时断开\"><a href=\"#何时断开\" class=\"headerlink\" title=\"何时断开\"></a>何时断开</h4><p>  在了解TCP四次挥手后，有两个疑问：</p>\n<ol>\n<li><p>何时去断开连接？<br>在确认数据传输完毕后就可以断开连接<br>(但为了防止频繁的握手和挥手，客户端可以在请求头中指定Connection: Keep-Alive保持连接)</p>\n</li>\n<li><p>由哪一方发起断开请求？<br>这个视具体情况而定，也就是哪一方能够确认数据传输完毕。<br>举个例子：</p>\n<img src=\"/image/HTTP/http-request2.png\" class=\"\" title=\"三次握手\">\n\n<p>这里访问搜索引擎首页，一般来说这种首页静态资源是固定的。<br>所以可以看到服务端响应头信息中content-length指定了具体数据，那么客户端会根据这个大小判断是否完成数据传输然后发起断开请求。</p>\n<p>另一种情况就是如果服务端无法确认传输数据的大小，那么会采用块传输的方式或者短连接(也就是服务端判断数据传输完了就直接断开连接)</p>\n</li>\n</ol>\n<h4 id=\"为何发起方最后要等待2MSL\"><a href=\"#为何发起方最后要等待2MSL\" class=\"headerlink\" title=\"为何发起方最后要等待2MSL\"></a>为何发起方最后要等待2MSL</h4><p>  主要考虑到第四次握手，也就是响应接收方的二次确认请求失败的情况。如果此时发起方直接关闭，那么就收不到接收方因重试发送的请求。</p>\n<blockquote>\n<p>MSL: Maximum Segment Lifetime 即报文最大生存时间，超过这个时间的报文将被丢弃</p>\n</blockquote>\n<h3 id=\"TCP标志位\"><a href=\"#TCP标志位\" class=\"headerlink\" title=\"TCP标志位\"></a>TCP标志位</h3><blockquote>\n<p>标志位代表TCP连接的状态，有以下六种：<br>SYN：表示请求建立一个连接）<br>URG：紧急标志<br>ACK：确认数据包的接收<br>PSH：推送标志，提高数据传输的优先级<br>RST：要求对方重新建立连接<br>FIN：表示要断开连接</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://www.cnblogs.com/Andya/p/7272462.html\" target=\"_blank\" rel=\"noopener\">TCP三次握手和四次挥手过程</a><br><a href=\"https://www.cnblogs.com/nxlhero/p/11670942.html\" target=\"_blank\" rel=\"noopener\">Http协议Content-Length详解</a><br><a href=\"https://www.jianshu.com/p/49551bda6619\" target=\"_blank\" rel=\"noopener\">HTTP协议的Keep-Alive 模式</a></p>\n</blockquote>\n","site":{"data":{}},"length":1779,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  本章想通过一次http请求过程，分析总结下相关的知识点。</p>","more":"<h3 id=\"请求过程\"><a href=\"#请求过程\" class=\"headerlink\" title=\"请求过程\"></a>请求过程</h3><p>  先概括一下整个请求过程：</p>\n<ol>\n<li>当输入一个网址后，浏览器会进行域名解析，找到对应的IP地址</li>\n<li>浏览器通过IP找到对应服务器请求建立连接</li>\n<li>建立连接后就会发送请求给服务器</li>\n<li>服务器返回响应结果</li>\n<li>断开连接</li>\n</ol>\n<h3 id=\"DNS解析\"><a href=\"#DNS解析\" class=\"headerlink\" title=\"DNS解析\"></a>DNS解析</h3><p>  DNS解析会把输入的域名映射到对应的IP地址上，然后通过IP地址找到服务器。<br>  其目的就是为了方便大众使用，有规律的域名更方便用户记忆。</p>\n<blockquote>\n<p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。<br>  它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。<br>  DNS使用UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。<br>  — 摘自百度百科</p>\n</blockquote>\n<h3 id=\"TCP三次握手\"><a href=\"#TCP三次握手\" class=\"headerlink\" title=\"TCP三次握手\"></a>TCP三次握手</h3><p>  在得到服务器IP地址后，客户端就需要发起请求连接，通过TCP三次握手与服务器建立连接。</p>\n<pre><code>第一次握手：客户端发送请求，\n           标志位SYN=1，seq=seqC(随机数)\n第二次握手：服务端响应新建连接请求，\n           标志位SYN=1，标志位ACK=1，ack=seqC+1，seq=seqS(随机数)\n第三次握手：客户端确认报文(检查ack是否正确)，确认无误后，响应请求\n           标志位ACK=1，ack=seqS+1，seq=seqC+1\n           服务端接收到报文后，同样会检查ack是否正确，无误后建立连接</code></pre><h4 id=\"示意图\"><a href=\"#示意图\" class=\"headerlink\" title=\"示意图\"></a>示意图</h4>  <img src=\"/image/HTTP/http-request1.png\" class=\"\" title=\"三次握手\">\n\n<h4 id=\"为何要三次握手\"><a href=\"#为何要三次握手\" class=\"headerlink\" title=\"为何要三次握手\"></a>为何要三次握手</h4><blockquote>\n<p>如果只依赖两次握手建立连接，那么会有以下几个问题：</p>\n</blockquote>\n<ol>\n<li>客户端延迟的连接请求发送到服务端，导致重复建立连接</li>\n<li>如果客户端没有收到服务端的确认，此时进入连接状态的服务端会一直等待客户端传输数据，浪费资源</li>\n</ol>\n<blockquote>\n<p>而三次握手能实现以下目的：</p>\n</blockquote>\n<ol>\n<li>第一次握手请求连接<br>此时，服务端确认自己接收消息的功能完好</li>\n<li>第二次握手服务端响应第一次握手<br>此时，客户端可以确认自己发送消息和接收消息的功能完好</li>\n<li>第三次客户端响应第二次握手<br>此时，服务端确认自己发送消息的功能完好<br>至此，双发互相确认了发送，接收功能的完好，可以创建连接开始通信</li>\n</ol>\n<h3 id=\"TCP四次挥手\"><a href=\"#TCP四次挥手\" class=\"headerlink\" title=\"TCP四次挥手\"></a>TCP四次挥手</h3><p>  在请求完成后，需要断开客户端与服务端建立的连接。类似于三次握手创立连接，此时需要经过四次挥手去完成断开连接的过程(因为可能还有数据没传送完，所以多一次确认请求)。</p>\n<pre><code>第一次挥手：发起方发起断开请求，\n           标志位FIN=1，seq=seqC(随机数)\n第二次挥手：接收方返回确认，\n           标志位ACK=1，ack=seqC+1，seq=seqS1(随机数)\n第三次挥手：待接收方完成传输处理，会向发起方发送确认断开的请求\n           标志位FIN=1，ACK=1，ack=seqC+1，seq=seqS2(随机数)\n第四次挥手：发起方确认报文无误后响应接收方的断开请求，\n           标志位ACK=1，ack=seqS2+1，seq=seqC+1\n第四次挥手后，接收方收到发起方的确认请求后就会进入CLOSED状态，而发起方会等待2MSL的时间后进入CLOSED状态</code></pre><h4 id=\"示意图-1\"><a href=\"#示意图-1\" class=\"headerlink\" title=\"示意图\"></a>示意图</h4>  <img src=\"/image/HTTP/http-request3.png\" class=\"\" title=\"三次握手\">\n\n<h4 id=\"何时断开\"><a href=\"#何时断开\" class=\"headerlink\" title=\"何时断开\"></a>何时断开</h4><p>  在了解TCP四次挥手后，有两个疑问：</p>\n<ol>\n<li><p>何时去断开连接？<br>在确认数据传输完毕后就可以断开连接<br>(但为了防止频繁的握手和挥手，客户端可以在请求头中指定Connection: Keep-Alive保持连接)</p>\n</li>\n<li><p>由哪一方发起断开请求？<br>这个视具体情况而定，也就是哪一方能够确认数据传输完毕。<br>举个例子：</p>\n<img src=\"/image/HTTP/http-request2.png\" class=\"\" title=\"三次握手\">\n\n<p>这里访问搜索引擎首页，一般来说这种首页静态资源是固定的。<br>所以可以看到服务端响应头信息中content-length指定了具体数据，那么客户端会根据这个大小判断是否完成数据传输然后发起断开请求。</p>\n<p>另一种情况就是如果服务端无法确认传输数据的大小，那么会采用块传输的方式或者短连接(也就是服务端判断数据传输完了就直接断开连接)</p>\n</li>\n</ol>\n<h4 id=\"为何发起方最后要等待2MSL\"><a href=\"#为何发起方最后要等待2MSL\" class=\"headerlink\" title=\"为何发起方最后要等待2MSL\"></a>为何发起方最后要等待2MSL</h4><p>  主要考虑到第四次握手，也就是响应接收方的二次确认请求失败的情况。如果此时发起方直接关闭，那么就收不到接收方因重试发送的请求。</p>\n<blockquote>\n<p>MSL: Maximum Segment Lifetime 即报文最大生存时间，超过这个时间的报文将被丢弃</p>\n</blockquote>\n<h3 id=\"TCP标志位\"><a href=\"#TCP标志位\" class=\"headerlink\" title=\"TCP标志位\"></a>TCP标志位</h3><blockquote>\n<p>标志位代表TCP连接的状态，有以下六种：<br>SYN：表示请求建立一个连接）<br>URG：紧急标志<br>ACK：确认数据包的接收<br>PSH：推送标志，提高数据传输的优先级<br>RST：要求对方重新建立连接<br>FIN：表示要断开连接</p>\n</blockquote>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://www.cnblogs.com/Andya/p/7272462.html\" target=\"_blank\" rel=\"noopener\">TCP三次握手和四次挥手过程</a><br><a href=\"https://www.cnblogs.com/nxlhero/p/11670942.html\" target=\"_blank\" rel=\"noopener\">Http协议Content-Length详解</a><br><a href=\"https://www.jianshu.com/p/49551bda6619\" target=\"_blank\" rel=\"noopener\">HTTP协议的Keep-Alive 模式</a></p>\n</blockquote>"},{"title":"Go学习笔记-Hello Golang","date":"2021-08-01T12:01:36.000Z","_content":"\n### 前言\n  终于要开始Go的学习记录，本章先简单了解下Go。\n<!-- more -->\n\n### Hello Golang\n   按照惯例，学习一个语言要从Hello World开始：\n{% codeblock lang:go %}\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main(){\n\tvar str = \"Hello World，Hello Golang\"\n\tfmt.Println(str)\n}\n{% endcodeblock %}\n  \n   接下来，以这个Hello World为例，来初步了解下Go。\n\n#### package和import\n   package用来设置包名，import用来导入依赖的其他包。这一块与Java还是比较像的。\n\n#### func\n   func是定义函数的关键字，可执行的Go程序都必须定义一个名称为main的函数，作为程序启动的入口。\n   可以看到main的定义与Java就有些不同了，即没有定义返回类型，也没有入参等等。当然，只是简单\n   的main函数看不出太多差异点。\n\n#### var\n   var是创建对象的关键字，这里的语法更偏向C语言。\n   与java不同的是，并不需要指定类型。而且还能更简化的直接用*str := \"hello world\"* 替代。\n\n#### fmt.Println()\n   最后一行的*fmt.Println()* 是调用了导入的依赖包fmt的方法，来在控制台输出定义的字符串。\n\n### Go的诞生\n\n> Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为 Google 公司 20% 兼职项目，即\n> 相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。\n> 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上\n> 的版本。同年 11 月 22 日公布了 Windows 版本。\n\n### Go的特点   \n\n> Go 语言是一种类型安全和内存安全的编程语言\n\n> Go 语言的一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。\n> 设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现\n> 了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。\n> 这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。\n\n> Go 语言从本质上（程序和结构方面）来实现并发编程。\n\n> 因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。\n> Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。\n\n### 总结\n      初步了解了Go的诞生背景，特点后，免不了会与Java比较下。\n      Java基于多年发展的成熟生态，已经形成了一整套层次分明，行之有效的技术方案。不过与此同时，\n    Java的“沉重”也一直饱受诟病。\n      作为新生的编程语言的Go，不仅语法上做了很多减法，使其更简洁明了，同时在设计上没有Java中\n    类，继承，实现这些面向对象的概念。虽然没有了Java那种层次分明的感觉，但结构会变得更为简单。\n      而且Go对并发，网络通信这些场景的原生支持，也是让Go现在如此火热的重要的原因之一。\n\n### 参考\n> [Go语言设计与实现](https://draveness.me/golang/)\n> [Go简易教程](https://learnku.com/docs/the-little-go-book)\n> [Go入门指南](https://learnku.com/docs/the-way-to-go)\n\n### 下一章\n> [Go学习笔记-数据类型](https://rel-fly.com/2021/08/13/golang-study-2/)","source":"_posts/2021/08/golang-study-1.md","raw":"---\ntitle: Go学习笔记-Hello Golang\ndate: 2021-08-01 20:01:36\ntags:\n- Go学习笔记\ncategories:\n- Go\n- 学习笔记\n---\n\n### 前言\n  终于要开始Go的学习记录，本章先简单了解下Go。\n<!-- more -->\n\n### Hello Golang\n   按照惯例，学习一个语言要从Hello World开始：\n{% codeblock lang:go %}\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main(){\n\tvar str = \"Hello World，Hello Golang\"\n\tfmt.Println(str)\n}\n{% endcodeblock %}\n  \n   接下来，以这个Hello World为例，来初步了解下Go。\n\n#### package和import\n   package用来设置包名，import用来导入依赖的其他包。这一块与Java还是比较像的。\n\n#### func\n   func是定义函数的关键字，可执行的Go程序都必须定义一个名称为main的函数，作为程序启动的入口。\n   可以看到main的定义与Java就有些不同了，即没有定义返回类型，也没有入参等等。当然，只是简单\n   的main函数看不出太多差异点。\n\n#### var\n   var是创建对象的关键字，这里的语法更偏向C语言。\n   与java不同的是，并不需要指定类型。而且还能更简化的直接用*str := \"hello world\"* 替代。\n\n#### fmt.Println()\n   最后一行的*fmt.Println()* 是调用了导入的依赖包fmt的方法，来在控制台输出定义的字符串。\n\n### Go的诞生\n\n> Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为 Google 公司 20% 兼职项目，即\n> 相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。\n> 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上\n> 的版本。同年 11 月 22 日公布了 Windows 版本。\n\n### Go的特点   \n\n> Go 语言是一种类型安全和内存安全的编程语言\n\n> Go 语言的一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。\n> 设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现\n> 了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。\n> 这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。\n\n> Go 语言从本质上（程序和结构方面）来实现并发编程。\n\n> 因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。\n> Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。\n\n### 总结\n      初步了解了Go的诞生背景，特点后，免不了会与Java比较下。\n      Java基于多年发展的成熟生态，已经形成了一整套层次分明，行之有效的技术方案。不过与此同时，\n    Java的“沉重”也一直饱受诟病。\n      作为新生的编程语言的Go，不仅语法上做了很多减法，使其更简洁明了，同时在设计上没有Java中\n    类，继承，实现这些面向对象的概念。虽然没有了Java那种层次分明的感觉，但结构会变得更为简单。\n      而且Go对并发，网络通信这些场景的原生支持，也是让Go现在如此火热的重要的原因之一。\n\n### 参考\n> [Go语言设计与实现](https://draveness.me/golang/)\n> [Go简易教程](https://learnku.com/docs/the-little-go-book)\n> [Go入门指南](https://learnku.com/docs/the-way-to-go)\n\n### 下一章\n> [Go学习笔记-数据类型](https://rel-fly.com/2021/08/13/golang-study-2/)","slug":"golang-study-1","published":1,"updated":"2021-08-22T05:42:02.375Z","_id":"cksmrwxhf0000ywb541to36pd","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  终于要开始Go的学习记录，本章先简单了解下Go。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Hello-Golang\"><a href=\"#Hello-Golang\" class=\"headerlink\" title=\"Hello Golang\"></a>Hello Golang</h3><p>   按照惯例，学习一个语言要从Hello World开始：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str = <span class=\"string\">\"Hello World，Hello Golang\"</span></span><br><span class=\"line\">\tfmt.Println(str)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   接下来，以这个Hello World为例，来初步了解下Go。</p>\n<h4 id=\"package和import\"><a href=\"#package和import\" class=\"headerlink\" title=\"package和import\"></a>package和import</h4><p>   package用来设置包名，import用来导入依赖的其他包。这一块与Java还是比较像的。</p>\n<h4 id=\"func\"><a href=\"#func\" class=\"headerlink\" title=\"func\"></a>func</h4><p>   func是定义函数的关键字，可执行的Go程序都必须定义一个名称为main的函数，作为程序启动的入口。<br>   可以看到main的定义与Java就有些不同了，即没有定义返回类型，也没有入参等等。当然，只是简单<br>   的main函数看不出太多差异点。</p>\n<h4 id=\"var\"><a href=\"#var\" class=\"headerlink\" title=\"var\"></a>var</h4><p>   var是创建对象的关键字，这里的语法更偏向C语言。<br>   与java不同的是，并不需要指定类型。而且还能更简化的直接用<em>str := “hello world”</em> 替代。</p>\n<h4 id=\"fmt-Println\"><a href=\"#fmt-Println\" class=\"headerlink\" title=\"fmt.Println()\"></a>fmt.Println()</h4><p>   最后一行的<em>fmt.Println()</em> 是调用了导入的依赖包fmt的方法，来在控制台输出定义的字符串。</p>\n<h3 id=\"Go的诞生\"><a href=\"#Go的诞生\" class=\"headerlink\" title=\"Go的诞生\"></a>Go的诞生</h3><blockquote>\n<p>Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为 Google 公司 20% 兼职项目，即<br>相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。<br>2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上<br>的版本。同年 11 月 22 日公布了 Windows 版本。</p>\n</blockquote>\n<h3 id=\"Go的特点\"><a href=\"#Go的特点\" class=\"headerlink\" title=\"Go的特点\"></a>Go的特点</h3><blockquote>\n<p>Go 语言是一种类型安全和内存安全的编程语言</p>\n</blockquote>\n<blockquote>\n<p>Go 语言的一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。<br>设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现<br>了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。<br>这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。</p>\n</blockquote>\n<blockquote>\n<p>Go 语言从本质上（程序和结构方面）来实现并发编程。</p>\n</blockquote>\n<blockquote>\n<p>因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。<br>Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  初步了解了Go的诞生背景，特点后，免不了会与Java比较下。\n  Java基于多年发展的成熟生态，已经形成了一整套层次分明，行之有效的技术方案。不过与此同时，\nJava的“沉重”也一直饱受诟病。\n  作为新生的编程语言的Go，不仅语法上做了很多减法，使其更简洁明了，同时在设计上没有Java中\n类，继承，实现这些面向对象的概念。虽然没有了Java那种层次分明的感觉，但结构会变得更为简单。\n  而且Go对并发，网络通信这些场景的原生支持，也是让Go现在如此火热的重要的原因之一。</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://draveness.me/golang/\" target=\"_blank\" rel=\"noopener\">Go语言设计与实现</a><br><a href=\"https://learnku.com/docs/the-little-go-book\" target=\"_blank\" rel=\"noopener\">Go简易教程</a><br><a href=\"https://learnku.com/docs/the-way-to-go\" target=\"_blank\" rel=\"noopener\">Go入门指南</a></p>\n</blockquote>\n<h3 id=\"下一章\"><a href=\"#下一章\" class=\"headerlink\" title=\"下一章\"></a>下一章</h3><blockquote>\n<p><a href=\"https://rel-fly.com/2021/08/13/golang-study-2/\">Go学习笔记-数据类型</a></p>\n</blockquote>\n","site":{"data":{}},"length":1230,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  终于要开始Go的学习记录，本章先简单了解下Go。</p>","more":"<h3 id=\"Hello-Golang\"><a href=\"#Hello-Golang\" class=\"headerlink\" title=\"Hello Golang\"></a>Hello Golang</h3><p>   按照惯例，学习一个语言要从Hello World开始：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str = <span class=\"string\">\"Hello World，Hello Golang\"</span></span><br><span class=\"line\">\tfmt.Println(str)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   接下来，以这个Hello World为例，来初步了解下Go。</p>\n<h4 id=\"package和import\"><a href=\"#package和import\" class=\"headerlink\" title=\"package和import\"></a>package和import</h4><p>   package用来设置包名，import用来导入依赖的其他包。这一块与Java还是比较像的。</p>\n<h4 id=\"func\"><a href=\"#func\" class=\"headerlink\" title=\"func\"></a>func</h4><p>   func是定义函数的关键字，可执行的Go程序都必须定义一个名称为main的函数，作为程序启动的入口。<br>   可以看到main的定义与Java就有些不同了，即没有定义返回类型，也没有入参等等。当然，只是简单<br>   的main函数看不出太多差异点。</p>\n<h4 id=\"var\"><a href=\"#var\" class=\"headerlink\" title=\"var\"></a>var</h4><p>   var是创建对象的关键字，这里的语法更偏向C语言。<br>   与java不同的是，并不需要指定类型。而且还能更简化的直接用<em>str := “hello world”</em> 替代。</p>\n<h4 id=\"fmt-Println\"><a href=\"#fmt-Println\" class=\"headerlink\" title=\"fmt.Println()\"></a>fmt.Println()</h4><p>   最后一行的<em>fmt.Println()</em> 是调用了导入的依赖包fmt的方法，来在控制台输出定义的字符串。</p>\n<h3 id=\"Go的诞生\"><a href=\"#Go的诞生\" class=\"headerlink\" title=\"Go的诞生\"></a>Go的诞生</h3><blockquote>\n<p>Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为 Google 公司 20% 兼职项目，即<br>相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。<br>2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上<br>的版本。同年 11 月 22 日公布了 Windows 版本。</p>\n</blockquote>\n<h3 id=\"Go的特点\"><a href=\"#Go的特点\" class=\"headerlink\" title=\"Go的特点\"></a>Go的特点</h3><blockquote>\n<p>Go 语言是一种类型安全和内存安全的编程语言</p>\n</blockquote>\n<blockquote>\n<p>Go 语言的一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。<br>设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现<br>了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。<br>这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。</p>\n</blockquote>\n<blockquote>\n<p>Go 语言从本质上（程序和结构方面）来实现并发编程。</p>\n</blockquote>\n<blockquote>\n<p>因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。<br>Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><pre><code>  初步了解了Go的诞生背景，特点后，免不了会与Java比较下。\n  Java基于多年发展的成熟生态，已经形成了一整套层次分明，行之有效的技术方案。不过与此同时，\nJava的“沉重”也一直饱受诟病。\n  作为新生的编程语言的Go，不仅语法上做了很多减法，使其更简洁明了，同时在设计上没有Java中\n类，继承，实现这些面向对象的概念。虽然没有了Java那种层次分明的感觉，但结构会变得更为简单。\n  而且Go对并发，网络通信这些场景的原生支持，也是让Go现在如此火热的重要的原因之一。</code></pre><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><blockquote>\n<p><a href=\"https://draveness.me/golang/\" target=\"_blank\" rel=\"noopener\">Go语言设计与实现</a><br><a href=\"https://learnku.com/docs/the-little-go-book\" target=\"_blank\" rel=\"noopener\">Go简易教程</a><br><a href=\"https://learnku.com/docs/the-way-to-go\" target=\"_blank\" rel=\"noopener\">Go入门指南</a></p>\n</blockquote>\n<h3 id=\"下一章\"><a href=\"#下一章\" class=\"headerlink\" title=\"下一章\"></a>下一章</h3><blockquote>\n<p><a href=\"https://rel-fly.com/2021/08/13/golang-study-2/\">Go学习笔记-数据类型</a></p>\n</blockquote>"},{"title":"Go学习笔记-数据类型","date":"2021-08-13T02:11:36.000Z","_content":"\n### 前言\n  在简单了解了下Go语言后，开始进入正式的学习。\n  本章就先来学习Go的数据类型及使用方法。\n<!-- more -->\n\n### 基本类型\n\n#### 整数类型\n\n  Go的整数类型除了有符号的int类型外，还提供了无符号的uint类型。\n  同样类似Java的byte，short，int，long按照最大位数不同提供了int8，int16，int32，int64四种\n  类型（uint也是一样分为uint8，uint16，uint32，uint64）\n  若使用int，uint定义整数，则在32位系统下表示32位，64位系统下表示64位大小\n  所以建议使用int8，int16等进行精确的定义。\n\n#### 浮点数类型\n\n  浮点整数有两种：float32，float64，分别代表32位和64位，也就是单精度和双精度浮点类型\n  float32能精确到小数点后7位，而float64则能精确到小数点后15位\n\n#### 复数类型\n\n  复数类型同样按位数大小分为complex64和complex128两种类型\n\n> 我们把形如a+bi（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，i称为虚数单位。\n> 当虚部等于零时，这个复数可以视为实数；当z的虚部不等于零时，实部等于零时，常称z为纯虚数\n  \n  定义方式如下：\n{% codeblock lang:go %}\nvar complexNum complex64 = complex(1, 2)\n// complex的两个参数分别表示复数的实部与虚部，其类型都是用的float32类型\n{% endcodeblock %}\n\n#### 布尔类型\n\n  使用关键字bool定义，与Java基本一样，只有true和false两个值\n\n#### 字符类型\n\n  首先看看builtin.go文件中定义string类型的注释：\n\n{% codeblock lang:go %}\npackage builtin\n// string is the set of all strings of 8-bit bytes, conventionally but not\n// necessarily representing UTF-8-encoded text. A string may be empty, but\n// not nil. Values of string type are immutable.\ntype string string\n{% endcodeblock %}\n  可以看到，string是一个8字节byte类型的集合，且与Java一样，string的值也是不可变的\n\n  然后看看string.go文件中的定义：\n{% codeblock lang:go %}\nconst tmpStringBufSize = 32\n\ntype tmpBuf [tmpStringBufSize]byte\n{% endcodeblock %}\n\n  佐证了builtin.go文件中的注释，其是一个byte类型的数组。\n\n  下面看看string的用法示例：\n{% codeblock lang:go %}\n  // 定义方式\n  str1 := \"123\"\n  var str2 = \"one two three\"\n  // 以数组的形式遍历\n  for _ , e := range str1 {\n    fmt.Printf(\"%d,%q\\n\", e, e)\n  }\n  for i , _ := range str2 {\n    fmt.Printf(\"%d,%q\\n\", str2[i], str2[i])\n  }\n  // 输出结果：49,'1'\n  //          50,'2'\n  //          51,'3'\n  //          111,'o'\n  //          110,'n'\n  //          101,'e'\n  //          32,' '\n  //          116,'t'\n  //          119,'w'\n  //          111,'o'\n  //          32,' '\n  //          116,'t'\n  //          104,'h'\n  //          114,'r'\n  //          101,'e'\n  //          101,'e'\n  // 不可变 所以下述代码会报错\n  //str1[0] = \"1\"\n{% endcodeblock %}\n\n##### strings包\n   \n   在刚开始用string会疑惑，类似Java中split()，subString()这些方法到哪去了呢？\n   go其实也提供了类似的方法，不过并不能像Java中一样直接用String类型的对象调用对应方法，而是定义了一个strings包\n{% codeblock lang:go %}\n  str := \"hello world\"\n  // 分割\n  str1 := strings.Split(str, \" \")\n  for i, e := range str1 {\n    fmt.Printf(\"第%v个是:%v\\n\", i, e)\n  }\n  // 包含判断\n  fmt.Printf(\"是否包含：%v\\n\", strings.Contains(str, \"h\"))\n  // 在被统计字符串中出现的次数\n  fmt.Printf(\"出现次数：%v\\n\", strings.Count(\"aabbdddccc\", \"a\"))\n  fmt.Printf(\"出现次数：%v\\n\", strings.Count(\"aabbdddccc\", \"c\"))\n  // 比较字符串\n  fmt.Printf(\"比较结果:%v\\n\", strings.Compare(\"aaa\", \"aaa\"))\n  fmt.Printf(\"比较结果:%v\\n\", strings.Compare(\"aaa\", \"Aaa\"))\n{% endcodeblock %}\n\n### 指针类型\n\n   golang不同于Java，有指针类型，但又不同于C语言，其指针是不参与运算的，下面看看基本用法的示例\n{% codeblock lang:go %}\n  str := \"aaa\"\n  point1 := &str\n  fmt.Printf(\"输出地址值：%v\\n\", point1)\n  fmt.Printf(\"输出值：%v\\n\", *point1)\n  var pointArray []*int\n  for i := 0; i < 5; i++ {\n    // 此时i的地址不变\n    fmt.Printf(\"i的地址：%v\\n\", &i)\n    num := i\n    pointArray = append(pointArray, &num)\n  }\n  fmt.Printf(\"指针数组：%v\\n\", pointArray)\n  for i, e := range pointArray {\n    fmt.Printf(\"i的地址：%v，e的地址：%v;\", &i, &e)\n    fmt.Printf(\"第%v个指针元素：%v;\", i, e)\n    fmt.Printf(\"第%v个元素：%v\\n\", i, *e)\n  }\n// 输出结果：\n// 输出地址值：0xc000042240\n// 输出值：aaa\n// i的地址：0xc00000a0a8\n// i的地址：0xc00000a0a8\n// i的地址：0xc00000a0a8\n// i的地址：0xc00000a0a8\n// i的地址：0xc00000a0a8\n// 指针数组：[0xc00000a0d0 0xc00000a0d8 0xc00000a0e0 0xc00000a0e8 0xc00000a0f0]\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第0个指针元素：0xc00000a0d0;第0个元素：0\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第1个指针元素：0xc00000a0d8;第1个元素：1\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第2个指针元素：0xc00000a0e0;第2个元素：2\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第3个指针元素：0xc00000a0e8;第3个元素：3\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第4个指针元素：0xc00000a0f0;第4个元素：4\n{% endcodeblock%}\n\n### 数组与切片\n\n### 结构体","source":"_posts/2021/08/golang-study-2.md","raw":"---\ntitle: Go学习笔记-数据类型\ndate: 2021-08-13 10:11:36\ntags:\n- Go学习笔记\ncategories:\n- Go\n- 学习笔记\n---\n\n### 前言\n  在简单了解了下Go语言后，开始进入正式的学习。\n  本章就先来学习Go的数据类型及使用方法。\n<!-- more -->\n\n### 基本类型\n\n#### 整数类型\n\n  Go的整数类型除了有符号的int类型外，还提供了无符号的uint类型。\n  同样类似Java的byte，short，int，long按照最大位数不同提供了int8，int16，int32，int64四种\n  类型（uint也是一样分为uint8，uint16，uint32，uint64）\n  若使用int，uint定义整数，则在32位系统下表示32位，64位系统下表示64位大小\n  所以建议使用int8，int16等进行精确的定义。\n\n#### 浮点数类型\n\n  浮点整数有两种：float32，float64，分别代表32位和64位，也就是单精度和双精度浮点类型\n  float32能精确到小数点后7位，而float64则能精确到小数点后15位\n\n#### 复数类型\n\n  复数类型同样按位数大小分为complex64和complex128两种类型\n\n> 我们把形如a+bi（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，i称为虚数单位。\n> 当虚部等于零时，这个复数可以视为实数；当z的虚部不等于零时，实部等于零时，常称z为纯虚数\n  \n  定义方式如下：\n{% codeblock lang:go %}\nvar complexNum complex64 = complex(1, 2)\n// complex的两个参数分别表示复数的实部与虚部，其类型都是用的float32类型\n{% endcodeblock %}\n\n#### 布尔类型\n\n  使用关键字bool定义，与Java基本一样，只有true和false两个值\n\n#### 字符类型\n\n  首先看看builtin.go文件中定义string类型的注释：\n\n{% codeblock lang:go %}\npackage builtin\n// string is the set of all strings of 8-bit bytes, conventionally but not\n// necessarily representing UTF-8-encoded text. A string may be empty, but\n// not nil. Values of string type are immutable.\ntype string string\n{% endcodeblock %}\n  可以看到，string是一个8字节byte类型的集合，且与Java一样，string的值也是不可变的\n\n  然后看看string.go文件中的定义：\n{% codeblock lang:go %}\nconst tmpStringBufSize = 32\n\ntype tmpBuf [tmpStringBufSize]byte\n{% endcodeblock %}\n\n  佐证了builtin.go文件中的注释，其是一个byte类型的数组。\n\n  下面看看string的用法示例：\n{% codeblock lang:go %}\n  // 定义方式\n  str1 := \"123\"\n  var str2 = \"one two three\"\n  // 以数组的形式遍历\n  for _ , e := range str1 {\n    fmt.Printf(\"%d,%q\\n\", e, e)\n  }\n  for i , _ := range str2 {\n    fmt.Printf(\"%d,%q\\n\", str2[i], str2[i])\n  }\n  // 输出结果：49,'1'\n  //          50,'2'\n  //          51,'3'\n  //          111,'o'\n  //          110,'n'\n  //          101,'e'\n  //          32,' '\n  //          116,'t'\n  //          119,'w'\n  //          111,'o'\n  //          32,' '\n  //          116,'t'\n  //          104,'h'\n  //          114,'r'\n  //          101,'e'\n  //          101,'e'\n  // 不可变 所以下述代码会报错\n  //str1[0] = \"1\"\n{% endcodeblock %}\n\n##### strings包\n   \n   在刚开始用string会疑惑，类似Java中split()，subString()这些方法到哪去了呢？\n   go其实也提供了类似的方法，不过并不能像Java中一样直接用String类型的对象调用对应方法，而是定义了一个strings包\n{% codeblock lang:go %}\n  str := \"hello world\"\n  // 分割\n  str1 := strings.Split(str, \" \")\n  for i, e := range str1 {\n    fmt.Printf(\"第%v个是:%v\\n\", i, e)\n  }\n  // 包含判断\n  fmt.Printf(\"是否包含：%v\\n\", strings.Contains(str, \"h\"))\n  // 在被统计字符串中出现的次数\n  fmt.Printf(\"出现次数：%v\\n\", strings.Count(\"aabbdddccc\", \"a\"))\n  fmt.Printf(\"出现次数：%v\\n\", strings.Count(\"aabbdddccc\", \"c\"))\n  // 比较字符串\n  fmt.Printf(\"比较结果:%v\\n\", strings.Compare(\"aaa\", \"aaa\"))\n  fmt.Printf(\"比较结果:%v\\n\", strings.Compare(\"aaa\", \"Aaa\"))\n{% endcodeblock %}\n\n### 指针类型\n\n   golang不同于Java，有指针类型，但又不同于C语言，其指针是不参与运算的，下面看看基本用法的示例\n{% codeblock lang:go %}\n  str := \"aaa\"\n  point1 := &str\n  fmt.Printf(\"输出地址值：%v\\n\", point1)\n  fmt.Printf(\"输出值：%v\\n\", *point1)\n  var pointArray []*int\n  for i := 0; i < 5; i++ {\n    // 此时i的地址不变\n    fmt.Printf(\"i的地址：%v\\n\", &i)\n    num := i\n    pointArray = append(pointArray, &num)\n  }\n  fmt.Printf(\"指针数组：%v\\n\", pointArray)\n  for i, e := range pointArray {\n    fmt.Printf(\"i的地址：%v，e的地址：%v;\", &i, &e)\n    fmt.Printf(\"第%v个指针元素：%v;\", i, e)\n    fmt.Printf(\"第%v个元素：%v\\n\", i, *e)\n  }\n// 输出结果：\n// 输出地址值：0xc000042240\n// 输出值：aaa\n// i的地址：0xc00000a0a8\n// i的地址：0xc00000a0a8\n// i的地址：0xc00000a0a8\n// i的地址：0xc00000a0a8\n// i的地址：0xc00000a0a8\n// 指针数组：[0xc00000a0d0 0xc00000a0d8 0xc00000a0e0 0xc00000a0e8 0xc00000a0f0]\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第0个指针元素：0xc00000a0d0;第0个元素：0\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第1个指针元素：0xc00000a0d8;第1个元素：1\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第2个指针元素：0xc00000a0e0;第2个元素：2\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第3个指针元素：0xc00000a0e8;第3个元素：3\n// i的地址：0xc00000a0f8，e的地址：0xc000006038;第4个指针元素：0xc00000a0f0;第4个元素：4\n{% endcodeblock%}\n\n### 数组与切片\n\n### 结构体","slug":"golang-study-2","published":1,"updated":"2021-10-24T11:59:28.967Z","_id":"cksmrwxhk0001ywb59vbi5ffa","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  在简单了解了下Go语言后，开始进入正式的学习。<br>  本章就先来学习Go的数据类型及使用方法。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h3><h4 id=\"整数类型\"><a href=\"#整数类型\" class=\"headerlink\" title=\"整数类型\"></a>整数类型</h4><p>  Go的整数类型除了有符号的int类型外，还提供了无符号的uint类型。<br>  同样类似Java的byte，short，int，long按照最大位数不同提供了int8，int16，int32，int64四种<br>  类型（uint也是一样分为uint8，uint16，uint32，uint64）<br>  若使用int，uint定义整数，则在32位系统下表示32位，64位系统下表示64位大小<br>  所以建议使用int8，int16等进行精确的定义。</p>\n<h4 id=\"浮点数类型\"><a href=\"#浮点数类型\" class=\"headerlink\" title=\"浮点数类型\"></a>浮点数类型</h4><p>  浮点整数有两种：float32，float64，分别代表32位和64位，也就是单精度和双精度浮点类型<br>  float32能精确到小数点后7位，而float64则能精确到小数点后15位</p>\n<h4 id=\"复数类型\"><a href=\"#复数类型\" class=\"headerlink\" title=\"复数类型\"></a>复数类型</h4><p>  复数类型同样按位数大小分为complex64和complex128两种类型</p>\n<blockquote>\n<p>我们把形如a+bi（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，i称为虚数单位。<br>当虚部等于零时，这个复数可以视为实数；当z的虚部不等于零时，实部等于零时，常称z为纯虚数</p>\n</blockquote>\n<p>  定义方式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> complexNum <span class=\"keyword\">complex64</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// complex的两个参数分别表示复数的实部与虚部，其类型都是用的float32类型</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h4><p>  使用关键字bool定义，与Java基本一样，只有true和false两个值</p>\n<h4 id=\"字符类型\"><a href=\"#字符类型\" class=\"headerlink\" title=\"字符类型\"></a>字符类型</h4><p>  首先看看builtin.go文件中定义string类型的注释：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> builtin</span><br><span class=\"line\"><span class=\"comment\">// string is the set of all strings of 8-bit bytes, conventionally but not</span></span><br><span class=\"line\"><span class=\"comment\">// necessarily representing UTF-8-encoded text. A string may be empty, but</span></span><br><span class=\"line\"><span class=\"comment\">// not nil. Values of string type are immutable.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"keyword\">string</span> <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p>  可以看到，string是一个8字节byte类型的集合，且与Java一样，string的值也是不可变的</p>\n<p>  然后看看string.go文件中的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tmpStringBufSize = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> tmpBuf [tmpStringBufSize]<span class=\"keyword\">byte</span></span><br></pre></td></tr></table></figure>\n\n<p>  佐证了builtin.go文件中的注释，其是一个byte类型的数组。</p>\n<p>  下面看看string的用法示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义方式</span></span><br><span class=\"line\">str1 := <span class=\"string\">\"123\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">\"one two three\"</span></span><br><span class=\"line\"><span class=\"comment\">// 以数组的形式遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _ , e := <span class=\"keyword\">range</span> str1 &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"%d,%q\\n\"</span>, e, e)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i , _ := <span class=\"keyword\">range</span> str2 &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"%d,%q\\n\"</span>, str2[i], str2[i])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果：49,'1'</span></span><br><span class=\"line\"><span class=\"comment\">//          50,'2'</span></span><br><span class=\"line\"><span class=\"comment\">//          51,'3'</span></span><br><span class=\"line\"><span class=\"comment\">//          111,'o'</span></span><br><span class=\"line\"><span class=\"comment\">//          110,'n'</span></span><br><span class=\"line\"><span class=\"comment\">//          101,'e'</span></span><br><span class=\"line\"><span class=\"comment\">//          32,' '</span></span><br><span class=\"line\"><span class=\"comment\">//          116,'t'</span></span><br><span class=\"line\"><span class=\"comment\">//          119,'w'</span></span><br><span class=\"line\"><span class=\"comment\">//          111,'o'</span></span><br><span class=\"line\"><span class=\"comment\">//          32,' '</span></span><br><span class=\"line\"><span class=\"comment\">//          116,'t'</span></span><br><span class=\"line\"><span class=\"comment\">//          104,'h'</span></span><br><span class=\"line\"><span class=\"comment\">//          114,'r'</span></span><br><span class=\"line\"><span class=\"comment\">//          101,'e'</span></span><br><span class=\"line\"><span class=\"comment\">//          101,'e'</span></span><br><span class=\"line\"><span class=\"comment\">// 不可变 所以下述代码会报错</span></span><br><span class=\"line\"><span class=\"comment\">//str1[0] = \"1\"</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"strings包\"><a href=\"#strings包\" class=\"headerlink\" title=\"strings包\"></a>strings包</h5><p>   在刚开始用string会疑惑，类似Java中split()，subString()这些方法到哪去了呢？<br>   go其实也提供了类似的方法，不过并不能像Java中一样直接用String类型的对象调用对应方法，而是定义了一个strings包</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str := <span class=\"string\">\"hello world\"</span></span><br><span class=\"line\"><span class=\"comment\">// 分割</span></span><br><span class=\"line\">str1 := strings.Split(str, <span class=\"string\">\" \"</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, e := <span class=\"keyword\">range</span> str1 &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"第%v个是:%v\\n\"</span>, i, e)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 包含判断</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"是否包含：%v\\n\"</span>, strings.Contains(str, <span class=\"string\">\"h\"</span>))</span><br><span class=\"line\"><span class=\"comment\">// 在被统计字符串中出现的次数</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"出现次数：%v\\n\"</span>, strings.Count(<span class=\"string\">\"aabbdddccc\"</span>, <span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"出现次数：%v\\n\"</span>, strings.Count(<span class=\"string\">\"aabbdddccc\"</span>, <span class=\"string\">\"c\"</span>))</span><br><span class=\"line\"><span class=\"comment\">// 比较字符串</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"比较结果:%v\\n\"</span>, strings.Compare(<span class=\"string\">\"aaa\"</span>, <span class=\"string\">\"aaa\"</span>))</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"比较结果:%v\\n\"</span>, strings.Compare(<span class=\"string\">\"aaa\"</span>, <span class=\"string\">\"Aaa\"</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指针类型\"><a href=\"#指针类型\" class=\"headerlink\" title=\"指针类型\"></a>指针类型</h3><p>   golang不同于Java，有指针类型，但又不同于C语言，其指针是不参与运算的，下面看看基本用法的示例</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  str := <span class=\"string\">\"aaa\"</span></span><br><span class=\"line\">  point1 := &amp;str</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"输出地址值：%v\\n\"</span>, point1)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"输出值：%v\\n\"</span>, *point1)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> pointArray []*<span class=\"keyword\">int</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此时i的地址不变</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"i的地址：%v\\n\"</span>, &amp;i)</span><br><span class=\"line\">    num := i</span><br><span class=\"line\">    pointArray = <span class=\"built_in\">append</span>(pointArray, &amp;num)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"指针数组：%v\\n\"</span>, pointArray)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i, e := <span class=\"keyword\">range</span> pointArray &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"i的地址：%v，e的地址：%v;\"</span>, &amp;i, &amp;e)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"第%v个指针元素：%v;\"</span>, i, e)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"第%v个元素：%v\\n\"</span>, i, *e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">// 输出地址值：0xc000042240</span></span><br><span class=\"line\"><span class=\"comment\">// 输出值：aaa</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// 指针数组：[0xc00000a0d0 0xc00000a0d8 0xc00000a0e0 0xc00000a0e8 0xc00000a0f0]</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第0个指针元素：0xc00000a0d0;第0个元素：0</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第1个指针元素：0xc00000a0d8;第1个元素：1</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第2个指针元素：0xc00000a0e0;第2个元素：2</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第3个指针元素：0xc00000a0e8;第3个元素：3</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第4个指针元素：0xc00000a0f0;第4个元素：4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组与切片\"><a href=\"#数组与切片\" class=\"headerlink\" title=\"数组与切片\"></a>数组与切片</h3><h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3>","site":{"data":{}},"length":872,"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>  在简单了解了下Go语言后，开始进入正式的学习。<br>  本章就先来学习Go的数据类型及使用方法。</p>","more":"<h3 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h3><h4 id=\"整数类型\"><a href=\"#整数类型\" class=\"headerlink\" title=\"整数类型\"></a>整数类型</h4><p>  Go的整数类型除了有符号的int类型外，还提供了无符号的uint类型。<br>  同样类似Java的byte，short，int，long按照最大位数不同提供了int8，int16，int32，int64四种<br>  类型（uint也是一样分为uint8，uint16，uint32，uint64）<br>  若使用int，uint定义整数，则在32位系统下表示32位，64位系统下表示64位大小<br>  所以建议使用int8，int16等进行精确的定义。</p>\n<h4 id=\"浮点数类型\"><a href=\"#浮点数类型\" class=\"headerlink\" title=\"浮点数类型\"></a>浮点数类型</h4><p>  浮点整数有两种：float32，float64，分别代表32位和64位，也就是单精度和双精度浮点类型<br>  float32能精确到小数点后7位，而float64则能精确到小数点后15位</p>\n<h4 id=\"复数类型\"><a href=\"#复数类型\" class=\"headerlink\" title=\"复数类型\"></a>复数类型</h4><p>  复数类型同样按位数大小分为complex64和complex128两种类型</p>\n<blockquote>\n<p>我们把形如a+bi（a,b均为实数）的数称为复数，其中a称为实部，b称为虚部，i称为虚数单位。<br>当虚部等于零时，这个复数可以视为实数；当z的虚部不等于零时，实部等于零时，常称z为纯虚数</p>\n</blockquote>\n<p>  定义方式如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> complexNum <span class=\"keyword\">complex64</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// complex的两个参数分别表示复数的实部与虚部，其类型都是用的float32类型</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h4><p>  使用关键字bool定义，与Java基本一样，只有true和false两个值</p>\n<h4 id=\"字符类型\"><a href=\"#字符类型\" class=\"headerlink\" title=\"字符类型\"></a>字符类型</h4><p>  首先看看builtin.go文件中定义string类型的注释：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> builtin</span><br><span class=\"line\"><span class=\"comment\">// string is the set of all strings of 8-bit bytes, conventionally but not</span></span><br><span class=\"line\"><span class=\"comment\">// necessarily representing UTF-8-encoded text. A string may be empty, but</span></span><br><span class=\"line\"><span class=\"comment\">// not nil. Values of string type are immutable.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"keyword\">string</span> <span class=\"keyword\">string</span></span><br></pre></td></tr></table></figure>\n<p>  可以看到，string是一个8字节byte类型的集合，且与Java一样，string的值也是不可变的</p>\n<p>  然后看看string.go文件中的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> tmpStringBufSize = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> tmpBuf [tmpStringBufSize]<span class=\"keyword\">byte</span></span><br></pre></td></tr></table></figure>\n\n<p>  佐证了builtin.go文件中的注释，其是一个byte类型的数组。</p>\n<p>  下面看看string的用法示例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义方式</span></span><br><span class=\"line\">str1 := <span class=\"string\">\"123\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> str2 = <span class=\"string\">\"one two three\"</span></span><br><span class=\"line\"><span class=\"comment\">// 以数组的形式遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _ , e := <span class=\"keyword\">range</span> str1 &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"%d,%q\\n\"</span>, e, e)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> i , _ := <span class=\"keyword\">range</span> str2 &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"%d,%q\\n\"</span>, str2[i], str2[i])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果：49,'1'</span></span><br><span class=\"line\"><span class=\"comment\">//          50,'2'</span></span><br><span class=\"line\"><span class=\"comment\">//          51,'3'</span></span><br><span class=\"line\"><span class=\"comment\">//          111,'o'</span></span><br><span class=\"line\"><span class=\"comment\">//          110,'n'</span></span><br><span class=\"line\"><span class=\"comment\">//          101,'e'</span></span><br><span class=\"line\"><span class=\"comment\">//          32,' '</span></span><br><span class=\"line\"><span class=\"comment\">//          116,'t'</span></span><br><span class=\"line\"><span class=\"comment\">//          119,'w'</span></span><br><span class=\"line\"><span class=\"comment\">//          111,'o'</span></span><br><span class=\"line\"><span class=\"comment\">//          32,' '</span></span><br><span class=\"line\"><span class=\"comment\">//          116,'t'</span></span><br><span class=\"line\"><span class=\"comment\">//          104,'h'</span></span><br><span class=\"line\"><span class=\"comment\">//          114,'r'</span></span><br><span class=\"line\"><span class=\"comment\">//          101,'e'</span></span><br><span class=\"line\"><span class=\"comment\">//          101,'e'</span></span><br><span class=\"line\"><span class=\"comment\">// 不可变 所以下述代码会报错</span></span><br><span class=\"line\"><span class=\"comment\">//str1[0] = \"1\"</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"strings包\"><a href=\"#strings包\" class=\"headerlink\" title=\"strings包\"></a>strings包</h5><p>   在刚开始用string会疑惑，类似Java中split()，subString()这些方法到哪去了呢？<br>   go其实也提供了类似的方法，不过并不能像Java中一样直接用String类型的对象调用对应方法，而是定义了一个strings包</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str := <span class=\"string\">\"hello world\"</span></span><br><span class=\"line\"><span class=\"comment\">// 分割</span></span><br><span class=\"line\">str1 := strings.Split(str, <span class=\"string\">\" \"</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, e := <span class=\"keyword\">range</span> str1 &#123;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"第%v个是:%v\\n\"</span>, i, e)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 包含判断</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"是否包含：%v\\n\"</span>, strings.Contains(str, <span class=\"string\">\"h\"</span>))</span><br><span class=\"line\"><span class=\"comment\">// 在被统计字符串中出现的次数</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"出现次数：%v\\n\"</span>, strings.Count(<span class=\"string\">\"aabbdddccc\"</span>, <span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"出现次数：%v\\n\"</span>, strings.Count(<span class=\"string\">\"aabbdddccc\"</span>, <span class=\"string\">\"c\"</span>))</span><br><span class=\"line\"><span class=\"comment\">// 比较字符串</span></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"比较结果:%v\\n\"</span>, strings.Compare(<span class=\"string\">\"aaa\"</span>, <span class=\"string\">\"aaa\"</span>))</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">\"比较结果:%v\\n\"</span>, strings.Compare(<span class=\"string\">\"aaa\"</span>, <span class=\"string\">\"Aaa\"</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指针类型\"><a href=\"#指针类型\" class=\"headerlink\" title=\"指针类型\"></a>指针类型</h3><p>   golang不同于Java，有指针类型，但又不同于C语言，其指针是不参与运算的，下面看看基本用法的示例</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  str := <span class=\"string\">\"aaa\"</span></span><br><span class=\"line\">  point1 := &amp;str</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"输出地址值：%v\\n\"</span>, point1)</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"输出值：%v\\n\"</span>, *point1)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> pointArray []*<span class=\"keyword\">int</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++ &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 此时i的地址不变</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"i的地址：%v\\n\"</span>, &amp;i)</span><br><span class=\"line\">    num := i</span><br><span class=\"line\">    pointArray = <span class=\"built_in\">append</span>(pointArray, &amp;num)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  fmt.Printf(<span class=\"string\">\"指针数组：%v\\n\"</span>, pointArray)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> i, e := <span class=\"keyword\">range</span> pointArray &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"i的地址：%v，e的地址：%v;\"</span>, &amp;i, &amp;e)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"第%v个指针元素：%v;\"</span>, i, e)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">\"第%v个元素：%v\\n\"</span>, i, *e)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">// 输出地址值：0xc000042240</span></span><br><span class=\"line\"><span class=\"comment\">// 输出值：aaa</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0a8</span></span><br><span class=\"line\"><span class=\"comment\">// 指针数组：[0xc00000a0d0 0xc00000a0d8 0xc00000a0e0 0xc00000a0e8 0xc00000a0f0]</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第0个指针元素：0xc00000a0d0;第0个元素：0</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第1个指针元素：0xc00000a0d8;第1个元素：1</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第2个指针元素：0xc00000a0e0;第2个元素：2</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第3个指针元素：0xc00000a0e8;第3个元素：3</span></span><br><span class=\"line\"><span class=\"comment\">// i的地址：0xc00000a0f8，e的地址：0xc000006038;第4个指针元素：0xc00000a0f0;第4个元素：4</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组与切片\"><a href=\"#数组与切片\" class=\"headerlink\" title=\"数组与切片\"></a>数组与切片</h3><h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckdvmudxz0003nwb52wo6hndg","category_id":"ckdvmudy10005nwb5cmxjbbfo","_id":"ckdvmudy7000fnwb5d8vfbpkn"},{"post_id":"ckdvmudy30007nwb51bfjdigi","category_id":"ckdvmudy8000gnwb52awt2le6","_id":"ckdvmudyc000tnwb5hqnkan4b"},{"post_id":"ckdvmudy6000dnwb59kgc27ah","category_id":"ckdvmudyf000ynwb57gotgvjj","_id":"ckdvmudyi0018nwb5eszq89g6"},{"post_id":"ckdvmudy7000enwb5fz928sfs","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudyp001lnwb56e6s2akl"},{"post_id":"ckdvmudy7000enwb5fz928sfs","category_id":"ckdvmudyj001anwb5hfva9ayc","_id":"ckdvmudyq001onwb51psd5sfg"},{"post_id":"ckdvmudyk001enwb5hi4v54i6","category_id":"ckdvmudy10005nwb5cmxjbbfo","_id":"ckdvmudyr001rnwb5hvwbg2ks"},{"post_id":"ckdvmudyo001jnwb5e48jbgj9","category_id":"ckdvmudy8000gnwb52awt2le6","_id":"ckdvmudys001wnwb5fdgndc3i"},{"post_id":"ckdvmudy40008nwb5hawecc1z","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudyv0028nwb5gstu0es1"},{"post_id":"ckdvmudy40008nwb5hawecc1z","category_id":"ckdvmudyt0020nwb5g9s25g65","_id":"ckdvmudyw002anwb5abkk12by"},{"post_id":"ckdvmudy50009nwb57zvzgdyz","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudyy002jnwb57e1u3qnt"},{"post_id":"ckdvmudy50009nwb57zvzgdyz","category_id":"ckdvmudyw002cnwb5c6189e1b","_id":"ckdvmudyy002lnwb51wljf7j3"},{"post_id":"ckdvmudy00004nwb50dv20lum","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudz20032nwb59jf71x70"},{"post_id":"ckdvmudy00004nwb50dv20lum","category_id":"ckdvmudyh0013nwb56t31h8nv","_id":"ckdvmudz20034nwb5f5d1dtw2"},{"post_id":"ckdvmudy00004nwb50dv20lum","category_id":"ckdvmudz0002vnwb5cc0q1661","_id":"ckdvmudz20036nwb5bij2gp10"},{"post_id":"ckdvmudyj001cnwb5cmfhfn75","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudz3003anwb5ck2z2pnq"},{"post_id":"ckdvmudyj001cnwb5cmfhfn75","category_id":"ckdvmudz20031nwb5bmgk3sbp","_id":"ckdvmudz3003cnwb57eacbazr"},{"post_id":"ckdvmudyn001hnwb5cyiacgrc","category_id":"ckdvmudz20037nwb5cg9ibrtv","_id":"ckdvmudz3003enwb5axsnfiwy"},{"post_id":"ckdvmudy8000inwb5cldae7rj","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudz4003gnwb53h0pgzaz"},{"post_id":"ckdvmudy8000inwb5cldae7rj","category_id":"ckdvmudyh0013nwb56t31h8nv","_id":"ckdvmudz4003inwb57jnp4245"},{"post_id":"ckdvmudy8000inwb5cldae7rj","category_id":"ckdvmudz3003bnwb5b3xnd295","_id":"ckdvmudz4003jnwb58ahc8zvq"},{"post_id":"ckdvmudyp001nnwb599jg4z4h","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudz4003lnwb50cn65uu0"},{"post_id":"ckdvmudyp001nnwb599jg4z4h","category_id":"ckdvmudz3003fnwb549ur2tp7","_id":"ckdvmudz4003mnwb53v1ah5tq"},{"post_id":"ckdvmudy9000knwb59oqlbv79","category_id":"ckdvmudyp001knwb5e9hu9n8v","_id":"ckdvmudz5003onwb54h3ja7g7"},{"post_id":"ckdvmudy9000knwb59oqlbv79","category_id":"ckdvmudz4003hnwb5h5olhghm","_id":"ckdvmudz5003pnwb5d3bg39za"},{"post_id":"ckdvmudyq001qnwb53cb33r2b","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudz5003rnwb5gojib42v"},{"post_id":"ckdvmudyq001qnwb53cb33r2b","category_id":"ckdvmudyt0020nwb5g9s25g65","_id":"ckdvmudz5003snwb5ex8nge4u"},{"post_id":"ckdvmudyr001vnwb510h44ul6","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvmudz6003unwb565i24jsq"},{"post_id":"ckdvmudyr001vnwb510h44ul6","category_id":"ckdvmudyt0020nwb5g9s25g65","_id":"ckdvmudz6003vnwb536mz7wvq"},{"post_id":"ckdvmudyb000onwb5brwd3tao","category_id":"ckdvmudyr001tnwb56asdcwz6","_id":"ckdvmudz6003xnwb542mo2h4i"},{"post_id":"ckdvmudyb000onwb5brwd3tao","category_id":"ckdvmudz5003tnwb5dnrjh8v3","_id":"ckdvmudz7003znwb5hclb13uo"},{"post_id":"ckdvmudyc000qnwb57rfv4bwk","category_id":"ckdvmudyp001knwb5e9hu9n8v","_id":"ckdvmudz70042nwb5eimo1na2"},{"post_id":"ckdvmudyc000qnwb57rfv4bwk","category_id":"ckdvmudz4003hnwb5h5olhghm","_id":"ckdvmudz80043nwb555gm27mg"},{"post_id":"ckdvmudyd000vnwb51nqh13na","category_id":"ckdvmudyr001tnwb56asdcwz6","_id":"ckdvmudz80045nwb56zj0h6wr"},{"post_id":"ckdvmudyd000vnwb51nqh13na","category_id":"ckdvmudz5003tnwb5dnrjh8v3","_id":"ckdvmudz80046nwb52zyfgqvj"},{"post_id":"ckdvmudye000xnwb5h3un47mw","category_id":"ckdvmudyr001tnwb56asdcwz6","_id":"ckdvmudz90048nwb5ht4s79i0"},{"post_id":"ckdvmudye000xnwb5h3un47mw","category_id":"ckdvmudz5003tnwb5dnrjh8v3","_id":"ckdvmudz90049nwb51m0yajr8"},{"post_id":"ckdvmudyf0010nwb5ds1bdq4j","category_id":"ckdvmudyr001tnwb56asdcwz6","_id":"ckdvmudz9004bnwb512go2s3n"},{"post_id":"ckdvmudyf0010nwb5ds1bdq4j","category_id":"ckdvmudz5003tnwb5dnrjh8v3","_id":"ckdvmudzc004cnwb5g2485esg"},{"post_id":"ckdvmudyg0012nwb5evp1fgcz","category_id":"ckdvmudyr001tnwb56asdcwz6","_id":"ckdvmudzc004enwb571en79r5"},{"post_id":"ckdvmudyg0012nwb5evp1fgcz","category_id":"ckdvmudz5003tnwb5dnrjh8v3","_id":"ckdvmudzd004fnwb50zxw8lw4"},{"post_id":"ckdvmudyh0014nwb53r4l0jti","category_id":"ckdvmudyr001tnwb56asdcwz6","_id":"ckdvmudzd004hnwb5cue49khw"},{"post_id":"ckdvmudyh0014nwb53r4l0jti","category_id":"ckdvmudz5003tnwb5dnrjh8v3","_id":"ckdvmudzd004inwb51saj2exm"},{"post_id":"ckdvmudyi0017nwb531r1f4ta","category_id":"ckdvmudyr001tnwb56asdcwz6","_id":"ckdvmudze004knwb5fk65gnkv"},{"post_id":"ckdvmudyi0017nwb531r1f4ta","category_id":"ckdvmudz5003tnwb5dnrjh8v3","_id":"ckdvmudze004lnwb556gngohk"},{"post_id":"ckdvmudyi0019nwb55ax70afp","category_id":"ckdvmudyr001tnwb56asdcwz6","_id":"ckdvmudze004mnwb58nesgd1o"},{"post_id":"ckdvmudyi0019nwb55ax70afp","category_id":"ckdvmudz5003tnwb5dnrjh8v3","_id":"ckdvmudze004onwb5099db2ox"},{"post_id":"ckdvmudys001ynwb57oj59j7u","category_id":"ckdvmudz5003qnwb5h2wq9sn8","_id":"ckdvmudzf004pnwb58bfbd3a7"},{"post_id":"ckdvmudys001ynwb57oj59j7u","category_id":"ckdvmudzd004jnwb528vd67xm","_id":"ckdvmudzf004qnwb55lqt3p4c"},{"post_id":"ckdvnrwaa0000sgb53izt5wer","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckdvntkj70001xgb518oedw1e"},{"post_id":"ckdvnrwaa0000sgb53izt5wer","category_id":"ckdvmudz3003fnwb549ur2tp7","_id":"ckdvntkj70002xgb5babk38wm"},{"post_id":"ckf0wn68h0000ucb5c19acpa0","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckf0wn68m0002ucb5gy8i50m4"},{"post_id":"ckf0wn68h0000ucb5c19acpa0","category_id":"ckdvmudyt0020nwb5g9s25g65","_id":"ckf0wn68m0003ucb59r054qjg"},{"post_id":"ckffgd5e400005cb51z5dab68","category_id":"ckffgd5e900015cb5hn3b0y9e","_id":"ckffgd5eg00045cb5cceaa5mc"},{"post_id":"ckhan3gpw00008gb5f42y972r","category_id":"ckhan3gq200018gb5gvdv22l5","_id":"ckhan3gqa00048gb5chl56xeg"},{"post_id":"ckecwk71s0000b4b5h2dh4rbw","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckhan3gqd00078gb597w0ebdy"},{"post_id":"ckecwk71s0000b4b5h2dh4rbw","category_id":"ckdvmudz3003fnwb549ur2tp7","_id":"ckhan3gqd00088gb53ecr5o1g"},{"post_id":"ckdvmudyt0021nwb5b3xq6960","category_id":"ckhan3gq200018gb5gvdv22l5","_id":"ckhan6dxt0001mgb5aoef17lo"},{"post_id":"ckdvmudyt0021nwb5b3xq6960","category_id":"ckhan6dxs0000mgb5aghhf6hb","_id":"ckhan6dxt0002mgb58cqw3pcp"},{"post_id":"ckhan3gpw00008gb5f42y972r","category_id":"ckhan8xl00000jkb56cus9ir9","_id":"ckhan8xl10001jkb57ptr2spt"},{"post_id":"ckhevyvc80001twb551ou7hn7","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckhevyvcj0005twb552qa8jrh"},{"post_id":"ckhevyvc80001twb551ou7hn7","category_id":"ckdvmudz20031nwb5bmgk3sbp","_id":"ckhevyvcj0007twb54zmjf2pu"},{"post_id":"ckhevyvc20000twb563x30myv","category_id":"ckhevyvca0002twb53p4s5gyc","_id":"ckhevyvcj0008twb503l893ki"},{"post_id":"ckjzgmq6y0000dsb5gfi64u3x","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckjzgmq7c0004dsb51ff0hn7v"},{"post_id":"ckjzgmq6y0000dsb5gfi64u3x","category_id":"ckjzgmq7b0002dsb53atj2fff","_id":"ckjzgmq7c0005dsb59ior53q6"},{"post_id":"ckls21jr500002sb50r3r4ch8","category_id":"ckdvmudy8000gnwb52awt2le6","_id":"ckls21jra00022sb59r8x7sr4"},{"post_id":"cklx9xf3p0000gob5606408gl","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"cklx9xf3u0002gob5fgk4fzqv"},{"post_id":"cklx9xf3p0000gob5606408gl","category_id":"ckdvmudyj001anwb5hfva9ayc","_id":"cklx9xf3v0003gob56scz15r4"},{"post_id":"ckm0p6aew0000pwb52j1z3l33","category_id":"ckm0p6af40001pwb50ti8bj4a","_id":"ckm0p6afd0005pwb5gcpu1s4r"},{"post_id":"ckm0p6aew0000pwb52j1z3l33","category_id":"ckm0p6afc0004pwb57epj78vr","_id":"ckm0p6afd0006pwb5h79k8f6v"},{"post_id":"cknenrm3a0000vwb51t2w1w9m","category_id":"ckm0p6af40001pwb50ti8bj4a","_id":"cknenrm3o0002vwb541qt90lr"},{"post_id":"cknenrm3a0000vwb51t2w1w9m","category_id":"ckniyw28k0000okb5ehmybmzj","_id":"ckniyw28n0002okb556kh0le3"},{"post_id":"cknenrm3a0000vwb51t2w1w9m","category_id":"ckniyw28l0001okb55t923hmb","_id":"ckniyw28n0003okb554rwho61"},{"post_id":"cknn4imym0000hgb50wcses7c","category_id":"ckm0p6af40001pwb50ti8bj4a","_id":"cknn4imyr0002hgb5b7d15ia3"},{"post_id":"cknn4imym0000hgb50wcses7c","category_id":"ckniyw28k0000okb5ehmybmzj","_id":"cknn4imyr0003hgb51bku943z"},{"post_id":"cknn4imym0000hgb50wcses7c","category_id":"cknn4fcf40002awb54qxjcgud","_id":"cknn4imyr0004hgb53k0x6ww9"},{"post_id":"cknsy278g0000cwb50q7j4867","category_id":"ckm0p6af40001pwb50ti8bj4a","_id":"cknsy278w0003cwb5gc8zciw7"},{"post_id":"cknsy278g0000cwb50q7j4867","category_id":"ckniyw28k0000okb5ehmybmzj","_id":"cknsy278w0004cwb5byfqcwt9"},{"post_id":"cknsy278g0000cwb50q7j4867","category_id":"cknsy278n0002cwb5hb2i0oxw","_id":"cknsy278w0005cwb57dda2u2y"},{"post_id":"cko04d9qp00004gb54yhq664y","category_id":"ckm0p6af40001pwb50ti8bj4a","_id":"cko04d9r300034gb5hrqd3brg"},{"post_id":"cko04d9qp00004gb54yhq664y","category_id":"ckniyw28k0000okb5ehmybmzj","_id":"cko04d9r300044gb54h7cdthp"},{"post_id":"cko04d9qp00004gb54yhq664y","category_id":"cko04d9qv00024gb59nwmfkfx","_id":"cko04d9r300054gb5es6n86dc"},{"post_id":"cko54q05m0000nsb5dtq27jad","category_id":"ckdvmudy8000gnwb52awt2le6","_id":"cko54q05z0002nsb56e8taui3"},{"post_id":"cko8eg3fq0000kkb553iohf2m","category_id":"ckdvmudy8000gnwb52awt2le6","_id":"cko8eg3fz0002kkb527okgazk"},{"post_id":"ckopu6fjs00000kb5e9e0ctrs","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckopu6fk000040kb52dyocmqh"},{"post_id":"ckopu6fjs00000kb5e9e0ctrs","category_id":"ckdvmudyj001anwb5hfva9ayc","_id":"ckopu6fk000050kb5cj4w0ksg"},{"post_id":"ckopu6fjy00010kb5gqa7ebt6","category_id":"ckdvmudy5000anwb5af0t6hzw","_id":"ckopu6fk000060kb553o0e0me"},{"post_id":"ckopu6fjy00010kb5gqa7ebt6","category_id":"ckdvmudyt0020nwb5g9s25g65","_id":"ckopu6fk000070kb505gr2yji"},{"post_id":"ckor6840z00000wb52z8mfbl4","category_id":"ckpe2giit0000lob5grd13tbz","_id":"ckpe2gij20003lob51wr55zqs"},{"post_id":"cksmrwxhf0000ywb541to36pd","category_id":"cksmrwxhl0002ywb50vah0pnb","_id":"cksmrwxi0000aywb5dtqg340z"},{"post_id":"cksmrwxhf0000ywb541to36pd","category_id":"cksmrwxhy0007ywb5exv4fers","_id":"cksmrwxi0000bywb5170jfdfm"},{"post_id":"cksmrwxhk0001ywb59vbi5ffa","category_id":"cksmrwxhl0002ywb50vah0pnb","_id":"cksmrwxi0000cywb5byb62mh1"},{"post_id":"cksmrwxhk0001ywb59vbi5ffa","category_id":"cksmrwxhy0007ywb5exv4fers","_id":"cksmrwxi0000dywb5bhiyhsee"}],"PostTag":[{"post_id":"ckdvmudxz0003nwb52wo6hndg","tag_id":"ckdvmudy30006nwb5cicwbu02","_id":"ckdvmudy6000cnwb5gpcf2hm7"},{"post_id":"ckdvmudy00004nwb50dv20lum","tag_id":"ckdvmudy6000bnwb541klaags","_id":"ckdvmudy9000jnwb550433dpa"},{"post_id":"ckdvmudy7000enwb5fz928sfs","tag_id":"ckdvmudy6000bnwb541klaags","_id":"ckdvmudy9000lnwb5eqlx2yip"},{"post_id":"ckdvmudy8000inwb5cldae7rj","tag_id":"ckdvmudy6000bnwb541klaags","_id":"ckdvmudyb000pnwb54dj6d6mr"},{"post_id":"ckdvmudy30007nwb51bfjdigi","tag_id":"ckdvmudy8000hnwb54b443eg5","_id":"ckdvmudyc000rnwb54zjq6lp5"},{"post_id":"ckdvmudy40008nwb5hawecc1z","tag_id":"ckdvmudy6000bnwb541klaags","_id":"ckdvmudye000wnwb51vy7hf6f"},{"post_id":"ckdvmudy50009nwb57zvzgdyz","tag_id":"ckdvmudyd000unwb53rcc2mlw","_id":"ckdvmudyg0011nwb5c8up7fbg"},{"post_id":"ckdvmudy6000dnwb59kgc27ah","tag_id":"ckdvmudyf000znwb57p0yb5nh","_id":"ckdvmudyi0016nwb5aj1a9upr"},{"post_id":"ckdvmudy9000knwb59oqlbv79","tag_id":"ckdvmudyh0015nwb50t4a4cjh","_id":"ckdvmudyk001dnwb5d4rh8sc0"},{"post_id":"ckdvmudyb000onwb5brwd3tao","tag_id":"ckdvmudyj001bnwb5d15r5yep","_id":"ckdvmudyn001inwb5ea2026xw"},{"post_id":"ckdvmudyc000qnwb57rfv4bwk","tag_id":"ckdvmudyh0015nwb50t4a4cjh","_id":"ckdvmudyq001pnwb56mgyarky"},{"post_id":"ckdvmudyo001jnwb5e48jbgj9","tag_id":"ckdvmudy8000hnwb54b443eg5","_id":"ckdvmudyr001snwb5huwnh3lj"},{"post_id":"ckdvmudyd000vnwb51nqh13na","tag_id":"ckdvmudyj001bnwb5d15r5yep","_id":"ckdvmudys001xnwb58mbp1l7g"},{"post_id":"ckdvmudye000xnwb5h3un47mw","tag_id":"ckdvmudyj001bnwb5d15r5yep","_id":"ckdvmudyu0022nwb5auic0y16"},{"post_id":"ckdvmudyf0010nwb5ds1bdq4j","tag_id":"ckdvmudyj001bnwb5d15r5yep","_id":"ckdvmudyv0025nwb5cir2cxf1"},{"post_id":"ckdvmudyg0012nwb5evp1fgcz","tag_id":"ckdvmudyj001bnwb5d15r5yep","_id":"ckdvmudyv0029nwb5grcl0oa7"},{"post_id":"ckdvmudyh0014nwb53r4l0jti","tag_id":"ckdvmudyj001bnwb5d15r5yep","_id":"ckdvmudyw002dnwb53q9r8hef"},{"post_id":"ckdvmudyi0017nwb531r1f4ta","tag_id":"ckdvmudyj001bnwb5d15r5yep","_id":"ckdvmudyx002gnwb5efyp6ya9"},{"post_id":"ckdvmudyi0019nwb55ax70afp","tag_id":"ckdvmudyj001bnwb5d15r5yep","_id":"ckdvmudyy002knwb53v0b7npk"},{"post_id":"ckdvmudyj001cnwb5cmfhfn75","tag_id":"ckdvmudyx002hnwb5b5hqcqip","_id":"ckdvmudyy002onwb59j0fhid6"},{"post_id":"ckdvmudyk001enwb5hi4v54i6","tag_id":"ckdvmudyy002mnwb5af4sduu8","_id":"ckdvmudyz002rnwb5fbfa9uwi"},{"post_id":"ckdvmudyn001hnwb5cyiacgrc","tag_id":"ckdvmudyz002pnwb5bgy8gp0r","_id":"ckdvmudz0002unwb5enbb1uyj"},{"post_id":"ckdvmudyp001nnwb599jg4z4h","tag_id":"ckdvmudz0002tnwb5c5xidcx4","_id":"ckdvmudz1002xnwb5bvfo0cbo"},{"post_id":"ckdvmudyq001qnwb53cb33r2b","tag_id":"ckdvmudz1002wnwb55r80aza6","_id":"ckdvmudz10030nwb525621s8p"},{"post_id":"ckdvmudyr001vnwb510h44ul6","tag_id":"ckdvmudz1002wnwb55r80aza6","_id":"ckdvmudz20035nwb5atrz100h"},{"post_id":"ckdvmudys001ynwb57oj59j7u","tag_id":"ckdvmudz20033nwb5cl6p7pdy","_id":"ckdvmudz30039nwb58ys2hrq1"},{"post_id":"ckdvmudyt0021nwb5b3xq6960","tag_id":"ckdvmudz20038nwb5dm38gjuj","_id":"ckdvmudz3003dnwb55bcpexkd"},{"post_id":"ckdvnrwaa0000sgb53izt5wer","tag_id":"ckdvmudz0002tnwb5c5xidcx4","_id":"ckdvnsuwt0000xgb54dm2b3ee"},{"post_id":"ckecwk71s0000b4b5h2dh4rbw","tag_id":"ckdvmudz0002tnwb5c5xidcx4","_id":"ckecwk7250002b4b5aipo3j5e"},{"post_id":"ckf0wn68h0000ucb5c19acpa0","tag_id":"ckdvmudz1002wnwb55r80aza6","_id":"ckf0wn68m0001ucb59mmd4oq9"},{"post_id":"ckffgd5e400005cb51z5dab68","tag_id":"ckffgd5ef00025cb5al21043i","_id":"ckffgd5eg00035cb5cqmtejqa"},{"post_id":"ckhan3gpw00008gb5f42y972r","tag_id":"ckhan3gq800028gb5248s4lj0","_id":"ckhan3gqa00058gb5e5zi0fbf"},{"post_id":"ckhan3gpw00008gb5f42y972r","tag_id":"ckhan3gq900038gb567tf6av0","_id":"ckhan3gqa00068gb5f1hn6xwr"},{"post_id":"ckhevyvc20000twb563x30myv","tag_id":"ckhevyvch0003twb57i58dmc6","_id":"ckhevyvcj0006twb50xy6ahz0"},{"post_id":"ckhevyvc80001twb551ou7hn7","tag_id":"ckhevyvci0004twb5hgh7geup","_id":"ckhevyvck0009twb50hgr0vnp"},{"post_id":"ckjzgmq6y0000dsb5gfi64u3x","tag_id":"ckjzgmq740001dsb5g9pwfed5","_id":"ckjzgmq7c0003dsb56guoa8co"},{"post_id":"ckls21jr500002sb50r3r4ch8","tag_id":"ckdvmudy8000hnwb54b443eg5","_id":"ckls21jra00012sb5amml1bp7"},{"post_id":"cklx9xf3p0000gob5606408gl","tag_id":"ckdvmudy6000bnwb541klaags","_id":"cklx9xf3u0001gob5df63beln"},{"post_id":"ckm0p6aew0000pwb52j1z3l33","tag_id":"ckm0p6afb0002pwb5fh5nh11a","_id":"ckm0p6afc0003pwb5fsvogkoq"},{"post_id":"cknenrm3a0000vwb51t2w1w9m","tag_id":"ckniyumpw0002tcb5h0qh2qyy","_id":"ckniyumpx0003tcb57vfx8ewg"},{"post_id":"cknn4imym0000hgb50wcses7c","tag_id":"ckniyumpw0002tcb5h0qh2qyy","_id":"cknn4imyq0001hgb5cnjc33xs"},{"post_id":"cknsy278g0000cwb50q7j4867","tag_id":"ckniyumpw0002tcb5h0qh2qyy","_id":"cknsy278n0001cwb52aes6kfp"},{"post_id":"cko04d9qp00004gb54yhq664y","tag_id":"ckniyumpw0002tcb5h0qh2qyy","_id":"cko04d9qv00014gb532ek09b2"},{"post_id":"cko54q05m0000nsb5dtq27jad","tag_id":"cko54q05r0001nsb5fpbx589y","_id":"cko54q0600003nsb5gt5z8exa"},{"post_id":"cko54q05m0000nsb5dtq27jad","tag_id":"ckdvmudy8000hnwb54b443eg5","_id":"cko54q0600004nsb562wz09p1"},{"post_id":"cko8eg3fq0000kkb553iohf2m","tag_id":"ckdvmudy8000hnwb54b443eg5","_id":"cko8eg3fy0001kkb54cbl3o7k"},{"post_id":"ckopu6fjs00000kb5e9e0ctrs","tag_id":"ckdvmudy6000bnwb541klaags","_id":"ckopu6fjz00020kb55t30d1py"},{"post_id":"ckopu6fjy00010kb5gqa7ebt6","tag_id":"ckdvmudz1002wnwb55r80aza6","_id":"ckopu6fk000030kb5h1p47uvq"},{"post_id":"ckor6840z00000wb52z8mfbl4","tag_id":"ckpe2gij00001lob51n9i31gv","_id":"ckpe2gij10002lob52vkbc8y5"},{"post_id":"cksmrwxhf0000ywb541to36pd","tag_id":"cksmrwxht0003ywb51yci84u5","_id":"cksmrwxhx0006ywb515pv9i59"},{"post_id":"cksmrwxhk0001ywb59vbi5ffa","tag_id":"cksmrwxht0003ywb51yci84u5","_id":"cksmrwxhz0008ywb59c3kdsrj"}],"Tag":[{"name":"MySql索引","_id":"ckdvmudy30006nwb5cicwbu02"},{"name":"Java容器","_id":"ckdvmudy6000bnwb541klaags"},{"name":"redis","_id":"ckdvmudy8000hnwb54b443eg5"},{"name":"工具","_id":"ckdvmudyd000unwb53rcc2mlw"},{"name":"进程","_id":"ckdvmudyf000znwb57p0yb5nh"},{"name":"RocketMQ","_id":"ckdvmudyh0015nwb50t4a4cjh"},{"name":"ThinkingInJava","_id":"ckdvmudyj001bnwb5d15r5yep"},{"name":"位运算符","_id":"ckdvmudyx002hnwb5b5hqcqip"},{"name":"InnoDB锁","_id":"ckdvmudyy002mnwb5af4sduu8"},{"name":"JVM","_id":"ckdvmudyz002pnwb5bgy8gp0r"},{"name":"多线程","_id":"ckdvmudz0002tnwb5c5xidcx4"},{"name":"JUC","_id":"ckdvmudz1002wnwb55r80aza6"},{"name":"数据结构","_id":"ckdvmudz20033nwb5cl6p7pdy"},{"name":"AOP","_id":"ckdvmudz20038nwb5dm38gjuj"},{"name":"料理","_id":"ckffgd5ef00025cb5al21043i"},{"name":"缓存","_id":"ckhan3gq800028gb5248s4lj0"},{"name":"SpringCache","_id":"ckhan3gq900038gb567tf6av0"},{"name":"MyBatis","_id":"ckhevyvch0003twb57i58dmc6"},{"name":"final","_id":"ckhevyvci0004twb5hgh7geup"},{"name":"NIO","_id":"ckjzgmq740001dsb5g9pwfed5"},{"name":"排序算法","_id":"ckm0p6afb0002pwb5fh5nh11a"},{"name":"贪心算法","_id":"cknenrm3g0001vwb5c3pu92sk"},{"name":"算法笔记","_id":"ckniyumpw0002tcb5h0qh2qyy"},{"name":"分布式锁","_id":"cko54q05r0001nsb5fpbx589y"},{"name":"计算机网络","_id":"ckpe2gij00001lob51n9i31gv"},{"name":"Go学习笔记","_id":"cksmrwxht0003ywb51yci84u5"}]}}